;*	SOFTWARE OF JUNIOR COMPUTER
;*
;*      SOURCE LISTING OF ELEKTOR'S JUNIOR COMPUTER VERSION D
;*
;*	WRITTEN BY A. NACHTMANN
;*
;*	DATE: 7 FEB. 1980
;*
;*      THE FEATURES OF JUNIOR'S MONITOR ARE:
;*
;*      HEX ADDRESS DATA DISPLAY (ENTRY VIA RST)
;*      HEX EDITOR (START ADDRESS $1CB5)
;*	HEX ASSEMBLER (START ADDRESS $1F51)


*=$1C00


;EDITOR'S POINTERS AND TEMPS IN PAGE ZERO
                        
KEY     =       $00E1
BEGADL  =       $00E2           ;BEGIN ADDRESS POINTER
BEGADH  =       $00E3
ENDADL  =       $00E4           ;END ADDRESS POINTER
ENDADH  =       $00E5
CURADL  =       $00E6           ;CURRENT ADDRESS POINTER
CURADH  =       $00E7
CENDL   =       $00E8           ;CURRENT ADDRESS POINTER
CENDH   =       $00E9
MOVADL  =       $00EA
MOVADH  =       $00EB
TABLEL  =       $00EC
TABLEH  =       $00ED
LABELS  =       $00EE
BYTES   =       $00F6           ;NUMBER OF BYTES TO BE DISPLAYED
COUNT   =       $00F7

;MPU REGISTERS IN PAGE ZERO

PCL	=	$00EF
PCH	=	$00F0
PREG	=	$00F1
SPUSER	=	$00F2
ACC	=	$00F3
YREG	=	$00F4
XREG	=	$00F5

;HEX DISPLAY BUFFERS IN PAGE ZERO

INL     =       $00F8
INH     =       $00F9
POINTL  =       $00FA
POINTH  =       $00FB

;TEMPORARY DATA BUFFERS IN PAGE ZERO

TEMP    =       $00FC
TEMPX   =       $00FD
NIBBLE  =       $00FE
MODE    =       $00FF           ;(0 = DA MODE, !0 = AD MODE)

;MEMORY LOCATIONS IN THE 6532-IC

PAD	=	$1A80		;DATA REGISTER OF PORT A
PADD	=	$1A81		;DATA DIRECTION REGISTER OF PORT A
PBD     =       $1A82           ;DATA REGISTER OF PORT B
PBDD	=	$1A83		;DATA DIRECTION REGISTER OF PORT B

;WRITE EDGE DETECT CONTROL

EDETA   =	$1AE4		;NEG EDET DISABLE PA7-IRQ
EDETB   =       $1AE5		;POS EDET DISABLE PA7-IRQ
EDETC   =	$1AE6		;NEG EDET ENABLE PA7-IRQ
EDETD   =	$1AE7		;POS EDET ENABLE PA7-IRQ

;READ FLAG REGISTER AND CLEAR TIMER & IRQ FLAG

RDFLAG  =       $1AD5           ;BIT6=PA7-FLAG; BIT7=TIMER-FLAG

;WRITE COUNT INTO TIMER, DISABLE TIMER-IRQ

CNTA	=	$1AF4		;CLK1T
CNTB	=	$1AF5		;CLK8T
CNTC	=	$1AF6		;CLK64T
CNTD	=	$1AF7		;CLK1KT

;WRITE COUNT INTO TIMER, ENABLE TIMER-IRQ

CNTE	=	$1AFC		;CLK1T
CNTF	=	$1AFD		;CLK8T
CNTG	=	$1AFE		;CLK64T
CNTH	=	$1AFF		;CLK1KT

;INTERRUPT VECTORS: IRQ & NMI VECTORS SHOULD BE
;LOADED IN THE FOLLOWING MEMORY LOCATIONS FOR
;PROPER SYSTEM OPERATION.

NMIL    =       $1A7A           ;NMI LOWER BYTE
NMIH    =       $1A7B           ;NMI HIGHER BYTE
IRQL    =       $1A7E           ;IRQ LOWER BYTE
IRQH    =       $1A7F           ;IRQ HIGHER BYTE

;BEGINNERS MAY LOAD INTO THESE LOCATIONS
;$1C00 FOR STEP BY STEP MODUS AND BRK COMMAND


;JUNIOR'S MAIN ROUTINES


SAVE	STA ACC			;SAVE ACCU
	PLA			;GET CURRENT P-REGISTER
	STA PREG		;SAVE P-REGISTER
SAVEA	PLA	 		;GET CURRENT PCL
	STA PCL 		;SAVE CURRENT PCL
	STA POINTL		;PCL TO DISPLAY BUFFER
        PLA			;GET CURRENT PCH
	STA PCH			;SAVE CURRENT PCH
	STA POINTH 		;PCH TO DISPLAY BUFFER
SAVEB 	STY YREG		;SAVE CURRENT Y-REGISTER
	STX XREG 		;SAVE CURRENT X-REGISTER
        TSX			;GET CURRENT SP
        STX SPUSER 		;SAVE CURRENT SP
	LDX #$01		;SET AD-MODE
	STX MODE
        JMP START

RESET	LDA #$1E		;PB1---PB4
	STA PBDD		;IS OUTPUT
	LDA #$04		;SET P-REGISTER
	STA PREG
	LDA #$03
	STA MODE		;SET AD-MODE
	STA BYTES 		;DISPLAY POINTH,POINTL,INH
	LDX #$FF 		;ADJUST THE STACK POINTER
	TXS
	STX SPUSER
	CLD
	SEI

START	JSR SCAND		;DISPLAY DATA SPECIFIED BY POINTH,POINTL
        BNE START 		;WAIT UNTIL KEY IS RELEASED
STARA	JSR SCAND		;DISPLAY DATA SPECIFIED BY POINT
	BEQ STARA		;ANY KEY DEPRESSED
        JSR SCAND 		;DEB0UNCE KEY
        BEQ STARA 		;ANY KEY STILL DEPRESSED
        JSR GETKEY 		;IF YES DECODE KEY,RETURN WITH KEY IN ACCU

GOEXEC	CMP #$13		;GO-KEY?
        BNE ADMODE
	LDX SPUSER 		;GET CURRENT SP
	TXS
	LDA POINTH 		;START EXECUTION AT POINTH,POINTL
	PHA
	LDA POINTL
	PHA
	LDA PREG 		;RESTORE CURRENT P REGISTER
	PHA
	LDX XREG
	LDY YREG
	LDA ACC
	RTI			;EXECUTE PROGRAM
ADMODE	CMP #$10		;AD-KEY?
        BNE DAMODE
	LDA #$03 		;SET AD-MODE
	STA MODE
        BNE STEPA

DAMODE	CMP #$11		;DA-KEY?
	BNE STEP
	LDA #$00 		;SET DA-MODE
	STA MODE
        BEQ STEPA

STEP	CMP #$12		;PLUS-KEY?
	BNE PCKEY
	INC POINTL
        BNE STEPA
	INC POINTH
STEPA	JMP START

PCKEY	CMP #$14		;PC-KEY?
        BNE ILLKEY
	LDA PCL
	STA POINTL 		;LAST PC TO DISPLAY BUFFER
	LDA PCH
	STA POINTH
        JMP STEPA

ILLKEY	CMP #$15		;ILLEGAL KEY?
        BPL STEPA 		;IF YES, IGNORE IT

DATA	STA KEY			;SAVE KEY
	LDY MODE		;Y=0 IS DATA MODE,ELSE ADDRESS MODE
	BNE ADDRES
	LDA (POINTL),Y		;GET DATA SPECIFIED
	ASL A			;BY POINT
	ASL A			;SHIFT LOW ORDER
	ASL A			;NIBBLE INTO HIGH ORDER NIBBLE
	ASL A
	ORA KEY			;DATA WITH KEY
	STA (POINTL),Y		;RESTORE DATA
	JMP STEPA

ADDRES  LDX #$04                ;4 SHIFTS
ADLOOP	ASL POINTL		;POINTH,POINTL 4 POSITIONS TO LEFT
	ROL POINTH
	DEX
	BNE ADLOOP
	LDA POINTL
	ORA KEY			;RESTORE ADDRESS
	STA POINTL
	JMP STEPA


;JUNIOR'S HEX EDITOR
;FOLLOWING COMMANDS ARE VALID:
;
;"INSERT": INSERT A NEW LINE JUST BEFORE DISPLAYED LINE
;
;"INPUT": INSERT A NEW LINE JUST BEHIND THE DISPLAYED LINE
;
;"SEARCH": SEARCH IN WORKSPACE FOR A GIVEN 2 BYTE PATTERN
;
;"SKIP": SKIP TO NEXT INSTRUCTION
;
;"DELETE": DELETE CURRENT DISPLAYED INSTRUCTION
;CURAD IS OUT OF RANGE

EDITOR	JSR BEGIN		;CURAD := BEGAD
	LDY BEGADH
	LDX BEGADL
	INX
	BNE EDIT
	INY

EDIT	STX CENDL		;CEND := BEGAD + l
	STY CENDH
	LDA #$77		;DISPLAY "77"
	LDY #$00
	STA (CURADL),Y

CMND	JSR SCAN		;DISPLAY CURRENT INSTRUCTION,WAIT FOR A KEY

SEARCH  CMP #$14                ;SEARCH COMMAND?
	BNE INSERT
	JSR GETBYT		;READ 1ST BYTE
	BPL SEARCH		;COM. KEY?
	STA POINTH		;DISCARD DATA
	JSR GETBYT		;READ 2ND BYTE
	BPL SEARCH		;COM. KEY?
	STA POINTL		;DISCARD DATA
        JSR BEGIN               ;BEGIN CURAD := BEGAD

SELOOP  LDY #$00
	LDA (CURADL),Y		;COMPARE INSTRUCTION
	CMP POINTH		;AGAINST DATA TO BE SEARCHED
	BNE SEARA		;SKIP TO NEXT INSTRUCTION, IF NOT EQUAL
	INY
	LDA (CURADL),Y
	CMP POINTL
	BEQ CMND		;RETURN, IF 2 BYTE PATTERN IS FOUND

SEARA	JSR OPLEN		;GET LENGTH OF THE CURRENT INSTRUCTION
	JSR NEXT		;SKIP TO NEXT INSTRUCTION
	BMI SELOOP		;SEARCH AGAIN, IF CURAD IS LESS THAN CEND
	BPL ERRA

INSERT  CMP #$10		;INSERT COMMAND?
	BNE INPUT
	JSR RDINST		;READ INSTRUCTION AND COMPUTE LENGTH
	BPL SEARCH		;COM. KEY?
	JSR FILLWS		;MOVE DATA IN WS DOWNWARD BY THE AM. IN BYTES
	BEQ CMND		;RETURN TO DISPLAY THE INSEDTED INSTR.

INPUT   CMP #$13		;INPUT COMMAND?
	BNE SKIP
	JSR RDINST		;READ INSTRUCTION AND COMPUTE LENGTH
	BPL SEARCH		;COM. KEY?
	JSR OPLEN		;LENGTH OF THE CURRENT INSTR.
	JSR NEXT		;RETURN WITH N=1, IF CURAD IS LESS THAN CEND
	LDA TEMPX		;LENGTH OF INSTR. TO BE INSERTED
	STA BYTES
	JSR FILLWS		;MOVE DATA IN WS DOWNWARD BY THE AM. IN BYTES
	BEQ CMND		;RETURN TO DISPLAY THE INSERTED DATA

SKIP	CMP #$12		;SKIP COMMAND?
	BNE DELETE
	JSR NEXT		;SKIP TO NEXT INSTRUCTION, CURADD LESS THAN CEND?
	BMI CMND
	BPL ERRA

DELETE  CMP #$11		;DELETE COMMAND?
	BNE ERRA
	JSR UP			;DELETE CURRENT INSTR. BY MOVING UP THE WS
	JSR RECEND		;ADJUST CURRENT END ADDRESS
        JMP CMND

ERRA	LDA #$EE
	STA POINTH
	STA POINTL
	STA INH
	LDA #$03
	STA BYTES
ERRB	JSR SCANDS		;DISPLAY EEEEEE UNTIL KEY IS RELEASED
	BNE ERRB
	JMP CMND


;EDITOR'S SUBROUTINES


;SCAN IS A SUBROUTINE, FILLING UP
;THE DISPLAY BUFFER DETERMINED BY
;CURAD. THEN THE DISPLAY IS SCANNED
;DEPENDING OF THE LENGTH OF THE INSTRUCTION
;POINTED BY CURAD
;IF A DEPRESSED KEY IS DETECTED
;SCAN RETURNS WITH VALUE IN ACCU
SCAN	LDX #$02		;FILL UP THE DISPLAY BUFFER
	LDY #$00
FILBUF	LDA (CURADL),Y		;START FILLING AT OP CODE
        STA INH,X
	INY
	DEX
        BPL FILBUF
	JSR OPLEN		;STORE INSTRUCTION LENGTH IN BYTES
SCANA	JSR SCANDS		;DISPLAY CURRENT INSTRUCTION
	BNE SCANA		;KEY RELEASED?
SCANB	JSR SCANDS		;DISPLAY CURRENT INSTRUCTION
	BEQ SCANB		;ANY KEY DEPRESSED?
	JSR SCANDS		;DISPLAY CURRENT INSTRUCTION
	BEQ SCANB		;ANY KEY STILL DEPRESSED?
	JSR GETKEY		;IF YES, RETURN WITH KEY IN ACCU
	RTS

;GETBYT READS 2 HEXKEYS AND COMPOSES
;THEIR VALUES IN THE A REGISTER. IF ONLY
;HEXKEYS WERE DEPRESSED, IT RETURNS WITH
;N=1. IF A COMMAND KEY WAS DEPRESSED, IT
;RETURNS WITH N=0.
GETBYT	JSR SCANA		;READ HIGH ORDER NIBBLE
	CMP #$10
	BPL BYTEND		;COMMAND KEY?
	ASL A			;IF NOT, SAVE HIGH ORDER NIBBLE
	ASL A
	ASL A
	ASL A
	STA NIBBLE
	JSR SCANA		;READ LOW ORDER NIBBLE
	CMP #$10
	BPL BYTEND		;COMMAND KEY?
	ORA NIBBLE		;IF NOT, COMPOSE BYTE
	LDX #$FF		;SET N=1
BYTEND	RTS

;SCAND IS A SUBROUTINE SHOWING DATA SPECIfIED BY
;POINT.
;SCANDS IS A SUBROUTINE SHOWING THE CONTENTS OF
;DISPLAY BUFFER AS A FUNCTION Of BYTES.
;THE FOLLOWING SUBROUTINE AK SCANS THE KEYBOARD.
;IT RETURNS WITH A=0, If NO KEY IS DEPRESSED AND
;WITH A<>0 IF A KEY IS DEPRESSED.
;WHEN SCAND OR SCANDS ARE LEFT, PA0...PA7 IS INPUT.
SCAND	LDY #$00
	LDA (POINTL),Y		;GET DATA SPECIFIED BY POINT
	STA INH
SCANDS	LDA #$7F
	STA PADD		;PA0...PA6 IS OUTPUT
	LDX #$08 		;ENABLE DISPLAY
	LDY BYTES		;FETCH LENGTH FROM BYTES
SCDSA	LDA POINTH		;OUTPUT 1ST BYTE
	JSR SHOW
	DEY
	BEQ SCDSB		;MORE BYTES?
	LDA POINTL
	JSR SHOW 		;IF YES, OUTPUT 2ND BYTE
	DEY
	BEQ SCDSB		;MORE BYTES?
	LDA INH
	JSR SHOW		;IF YES, OUTPUT 3RD BYTE
SCDSB   LDA #$00
	STA PADD		;PA0...PA7 IS INPUT
AK	LDY #$03		;SCAN 3 ROWS
	LDX #$00		;RESET ROW COUNTER
ONEKEY	LDA #$FF
AKA	STX PBD			;OUTPUT ROW NUMBER
	INX			;ENABLE FOLLOWING ROW
	INX
	AND PAD			;INPUT ROW PATTERN
	DEY			;ALL ROWS SCANNED?
	BNE AKA
	LDY #$06		;TURN DISPLAY OFF
	STY PBD
        ORA #$80                ;SET BIT7=1
	EOR #$FF		;INVERT KEY PATTERN
	RTS

;THE SUBROUTINE SHOW TRANSPORTS THE
;CONTENTS OF ANY DISPLAY BUFFER TO THE
;DISPLAY. THE X REGISTER IS USED AS A
;SCAN COUNTER. IT DETERMINES, IF POINTH,
;POINTL OR INH IS TRANSPORTED TO THE
;DISPLAY.
SHOW	PHA			;SAVE DISPLAY
        STY TEMP                ;SAVE Y REGISTER
	LSR A
	LSR A 			;GET HIGH ORDER NIBBLE
	LSR A
	LSR A
	JSR CONVD		;OUTPUT HIGH ORDER NIBBLE
	PLA			;GET DISPLAY AGAIN
	AND #$0F		;MASK OFF HIGH ORDER NIBBLE
	JSR CONVD		;OUTPUT LOW ORDER NIBBLE
	LDY TEMP		;RESTORE Y REGISTER
	RTS

;THE SUBROUTINE CONVD CONTROLS THE DISPLAY SCAN.
;IT CONVERTS THE CONTENTS OF THE DISPLAY BUFFER
;TO BE DISPLAYED INTO A SEGMENT PATTERN.
CONVD	TAY			;USE NIBBLE AS INDEX
	LDA LOOK,Y		;FETCH SEGMENT PATTERN
	STA PAD			;OUTPUT SEGMENT PATTERN
	STX PBD			;OUTPUT DIGIT ENABLE
	LDY #$7F
DELAY	DEY			;DELAY 500 US APPROX.
	BPL DELAY
	STY PAD			;TURN SEGMENTS OFF
	LDY #$06
	STY PBD			;TURN DISPLAY OFF
	INX			;ENABLE NEXT DIGIT
	INX
	RTS

;GETKEY CONVERTS A DEPRESSED KEY INTO A
;HEX NUMBER. IT RETURNS WITH THE KEY VALUE
;IN ACCU. IF AN INVALID KEY WAS DEPRESSED.
GETKEY	LDX #$21		;START AT ROW 0
GETKEA	LDY #$01		;GET ONE ROW
	JSR ONEKEY		;A=0, NO KEY DEPRESSED
	BNE KEYIN
	CPX #$27
	BNE GETKEA		;EACH ROW SCANNED?
	LDA #$15		;RETURN IF INVALID KEY
	RTS
KEYIN	LDY #$FF
KEYINA	ASL A			;SHIFT LEFT UNTIL Y=KEY NUMBER
	BCS KEYINB
	INY
	BPL KEYINA
KEYINB  TXA
	AND #$0F		;MASK MSD
	LSR A			;DIVIDE BY 2
	TAX
	TYA
	BPL KEYIND
KEYINC	CLC
	ADC #$07		;ADD ROW OFFSET
KEYIND	DEX
	BNE KEYINC
	RTS

;RDINST TRANSFERS AN INSTRUCTION FROM KEYBOARD
;TO THE DISPLAY BUFFER. IT RETURNS WITH N=0 IF
;A COMMAND KEY WAS DEPRESSED. ONCE THE ENTIRE
;INSTRUCTION IS READ, RDINST RETURNS WITH N=1.
RDINST	JSR GETBYT		;READ OP CODE
        BPL RDB                 ;RETURN, IF COMMAND KEY
	STA POINTH		;STORE OP CODE IN DISPLAY BUFFER
	JSR LENACC		;COMPUTE INSTRUCTION LENGTH
	STY COUNT
	STY TEMPX
	DEC COUNT
	BEQ RDA			;1 BYTE INSTRUCTION?
	JSR GETBYT		;IF NOT, READ FIRST OPERAND
	BPL RDB			;RETURN, IF COMMAND KEY
	STA POINTL		;STORE 1ST OPERAND IN DISPLAY BUFFER
	DEC COUNT
	BEQ RDA			;2 BYTE INSTRUCTION?
	JSR GETBYT		;IF NOT, READ 2ND OPERAND
	BPL RDB			;RETURN IF COMMAND KEY
	STA INH			;STORE 2ND OPERAND IN DISPLAY BUFFER
RDA	LDX #$FF		;N=l
RDB	RTS

;FILLWS TRANSFERS THE DATA FROM DISPLAY TO
;WORKSPACE. IT'S ALWAYS LEFT WITH Z=1
FILLWS	JSR DOWN		;MOVE DATA DOWN BY THE AMOUNT IN BYTES
	JSR ADCEND		;ADJUST CURRENT END ADDRESS
	LDX #$02
	LDY #$00
WS	LDA INH,X		;FETCH DATA FROM DISPLAY BUFFER
	STA (CURADL),Y		;INSERT DATA INTO DATA FIELD
	DEX
	INY
	CPY BYTES		;ALL INSERTED?
	BNE WS			;IF NOT, CONTINUE
	RTS

;OPLEN COMPUTES THE LENGTH Of ANY 6502 INSTR.
;THE INSTR. LENGTH IS SAVED IN BYTES.
OPLEN	LDY #$00
	LDA (CURADL),Y		;FETCH OP CODE FROM WS
LENACC	LDY #$01		;LENGTH OF OP CODE IS 1 BYTE
	CMP #$00
	BEQ LENEND		;BRK INSTRUCTION?
	CMP #$40
	BEQ LENEND		;RTI INSTRUCTION?
	CMP #$60
	BEQ LENEND		;RTS INSTRUCTION?
	LDY #$03
	CMP #$20
	BEQ LENEND		;JSR INSTRUCTION?
	AND #$1F		;STRIP TO 5 BITS
	CMP #$19
	BEQ LENEND		;ANY ABS, Y INSTRUCTION?
	AND #$0F		;STRIP TO 4 BITS
	TAX			;USE NIBBLE AS INDEX
	LDY LEN,X		;FETCH LENGTH FROM LEN
LENEND	STY BYTES		;DISCARD LENGTH IN BYTES
	RTS

;UP MOVES A DATA FIELD BETWEEN CURAD AND CEND
;UPWARD BY THE AMOUNT IN BYTES
UP	LDA CURADL
	STA MOVADL
	LDA CURADH		;MOVAD := CURAD
	STA MOVADH
UPLOOP	LDY BYTES
	LDA (MOVADL),Y 		;MOVE UPWARD BY THE AMOUNT IN BYTES
	LDY #$00
	STA (MOVADL),Y
        INC MOVADL
	BNE UPA
        INC MOVADH              ;MOVADH := MOVADH + l
UPA	LDA MOVADL
	CMP CENDL
	BNE UPLOOP		;ALL DATA MOVED?
	LDA MOVADH		;IF NOT, CONTINUE
	CMP CENDH
	BNE UPLOOP
	RTS

;DOWN MOVES A DATA FIELD BETWEEN CURAD
;AND ENDAD DOWNWARD BY THE AMOUNT IN BYTES
DOWN	LDA CENDL
	STA MOVADL		;MOVAD := CEND
	LDA CENDH
	STA MOVADH
DNLOOP	LDY #$00
	LDA (MOVADL),Y		;MOVE DOWNWARD BY THE AMOUNT IN BYTES
	LDY BYTES
	STA (MOVADL),Y
	LDA MOVADL
	CMP CURADL
	BNE DNA			;ALL DATA MOVED?
	LDA MOVADH		;IF NOT, CONTINUE
	CMP CURADH
	BEQ DNEND
DNA	SEC
	LDA MOVADL
	SBC #$01
	STA MOVADL
	LDA MOVADH		;MOVAD := MOVAD - l
	SBC #$00
	STA MOVADH
	JMP DNLOOP
DNEND	RTS

;BEGIN SETS CURAD EQUAL TO BEGAD
BEGIN	LDA BEGADL
	STA CURADL
	LDA BEGADH		;CURAD := BEGAD
	STA CURADH
	RTS

;ADCEND ADVANCES CURRENT END ADDRESS
;DOWNWARD BY THE AMOUNT IN BYTES
ADCEND	CLC
	LDA CENDL
	ADC BYTES		;CEND := CEND + BYTES
	STA CENDL
        LDA CENDH
	ADC #$00
	STA CENDH
	RTS

;RECEND REDUCES THE CURRENT END ADDRESS
;BY THE AMOUNT IN BYTES
RECEND	SEC
	LDA CENDL
	SBC BYTES		;CEND := CEND - BYTES
	STA CENDL
	LDA CENDH
	SBC #$00
	STA CENDH
	RTS

;NEXT ADVANCES THE CURRENT DISPLAYED ADDRESS
;DOWNWARD BY THE AMOUNT IN BYTES
NEXT	CLC
	LDA CURADL
	ADC BYTES		;CURAD := CURAD + BYTES
	STA CURADL
	LDA CURADH
	ADC #$00
	STA CURADH
	SEC
	LDA CURADL
	SBC CENDL
	LDA CURADH
	SBC CENDH
	RTS

;THE LOOKUP TABLE "LOOK" IS USED TO CONVERT
;A HEX NUMBER INTO A 7 SEGMENT PATTERN.
;THE LOOKUP TABLE "LEN" IS USED TO CONVERT AN
;INSTRUCTION INTO AN INSTRUCTION LENGTH.
LOOK    .BYTE $40,$79,$24,$30,$19,$12,$02,$78   ;'01234567'
        .BYTE $00,$10,$08,$03,$46,$21,$06,$0E   ;'89ABCDEF'
LEN	.BYTE $02,$02,$02,$01,$02,$02,$02,$01
        .BYTE $01,$02,$01,$01,$03,$03,$03,$03

        JMP (NMIL)              ;JUMP TO A USER $ELECTABLE NMI VECTOR
        JMP (IRQL)              ;JUMP TO A USER SELECTABLE IRQ VECTOR

;GETLBL IS AN ASSEMBLER SUBROUTINE. IT SEARCHES FOR
;LABELS ON THE SYMBOL PSEUDO STACK. IF THIS STACK
;CONTAINS A VALID LABEL, IT RETURNS WITH THE
;HIGH ORDER LABEL ADDRESS IN X AND THE LOW ORDER LABEL
;ADDRESS IN A. IF NO VALID LABEL IS FOUND, IT RETURNS
;WITH Z=1.
GETLBL	LDA (CURADL),Y		;FETCH CURRENT LABEL NUMBER FROM WS
	LDY #$FF		;RESET PSEUDO STACK
SYMA	CPY LABELS		;UPPER MOST SYMBOL TABLE ADDRESS?
	BEQ SYMB		;IF YES, RETURN, NO LABEL ON PSEUDO STACK
	CMP (TABLEL),y		;LABEL NR. IN WS = LABEL NR. ON PSEUDO STACK?
	BNE SYMNXT
	DEY			;IF YES, GET HIGH ORDER ADD
	LDA (TABLEL),Y
	TAX			;DISCARD HIGH ORDER ADD IN X
	DEY
	LDA (TABLEL),Y		;GET LOW ORDER ADD
	LDY #$01		;PREPARE Y REGISTER
SYMB	RTS
SYMNXT  DEY                     ;***********     ***********
        DEY                     ;* X = ADH *     * A = ADL *
        DEY                     ;***********     ***********
        BNE SYMA
        RTS


;ASSEMBLER MAIN ROUTINE
;
;FOLLOWING INSTRUCTIONS ARE ASSEMBLED:
;
;JSR INSTRUCTION
;JMP INSTRUCTION
;BRANCH INSTRUCTIONS

ASSEMB	SEC
	LDA ENDADL
	SBC #$FF
	STA TABLEL		;TABLE := ENDAD - $FF
	LDA ENDADH
	SBC #$00
	STA TABLEH
	LDA #$FF
	STA LABELS
	JSR BEGIN		;CURAD := BEGAD

PASSA	JSR OPLEN		;START PASS ONE, GET CURR. INSTR.
	LDY #$00
	LDA (CURADL),Y		;FETCH CURRENT INSTRUCTION
	CMP #$FF		;IS THE CURRENT INSTR. A LABEL?
	BNE NXTINS
	INY
	LDA (CURADL),Y		;IF YES, FETCH LABEL NR.
	LDY LABELS
	STA (TABLEL),Y		;DEPOSIT LABEL NR. ON SYMBOL STACK
	DEY
	LDA CURADH		;GET HIGH ORDER ADD
	STA (TABLEL),Y		;DEPOSIT ON SYMBOL STACK
	DEY
	LDA CURADL		;GET LOW ORDER ADD
	STA (TABLEL),Y		;DEPOSIT ON SYMBOL STACK
	DEY
	STY LABELS		;ADJUST PSEUDO STACK POINTER
	JSR UP			;DELETE CURRENT LABEL IN WS
	JSR RECEND		;ADJUST CURRENT END ADD
	JMP PASSA		;LOOK FOR MORE LABELS

NXTINS	JSR NEXT		;IF NO LABEL, SKIP TO NEXT INSTR.
	BMI PASSA		;ALL LABELS IN WS COLLECTED?
	JSR BEGIN 		;START PASS 2

PASSB	JSR OPLEN		;GET LENGTH Of THE CURRENT INSTR.
	LDY #$00
	LDA (CURADL),Y		;FETCH CURRENT INSTR.
	CMP #$4C		;JMP INSTR.?
	BEQ JUMPS
	CMP #$20		;JSR INSTR.?
	BEQ JUMPS
	AND #$1F		;STRIP TO 5 BITS
	CMP #$10		;ANY BRANCH INSTRUCTION?
	BEQ BRINST
PB      JSR NEXT                ;IF NOT, RETURN
	BMI PASSB		;ALL LABELS BETWEEN CURAD AND ENDAD ASSEMBLED?
	LDA #$03		;ENABLE 3 DISPLAY BUFFERS
	STA BYTES
	JMP START		;EXIT HERE ********

JUMPS	INY			;SET POINTER TO LABEL NR.
	JSR GETLBL		;GET LABEL ADD
	BEQ PB			;RETURN, IF NOT FOUND
	STA (CURADL),Y		;STORE LOW ORDER ADD
	TXA
	INY
	STA (CURADL),Y		;STORE HIGH ORDER ADD
	BNE PB

BRINST	INY			;SET POINTER TO LABEL NR.
	JSR GETLBL		;GET LABEL ADD.
	BEQ PB			;RETURN, IF LABEL NOT FOUND
	SEC
	SBC CURADL		;COMPUTE BRANCH OFFSET
	SEC
	SBC #$02		;DESTINATION-SOURCE-2=OFFSET
	STA (CURADL),Y		;INSERT BRANCH OFFSET IN WS
	JMP PB


;THE SUBROUTINE BRANCH COMPUTES THE OFFSET OF BRANCH
;INSTRUCTIONS. THE 2 RIGHT HAND DISPLAYS SHOW THE
;COMPUTED OFFSET DEFINED BY THE 4 LEFT HAND DISPLAYS.
;THE PROGRAM MUST BE STOPPED WITH THE RESET KEY.
BRANCH	CLD
	LDA #$00		;RESET DISPLAY BUFFER
	STA POINTH
	STA POINTL
	STA INH
BR      JSR GETBYT              ;READ SOURCE
	BPL BRANCH		;COMMAND KEY?
	STA POINTH		;SAVE SOURCE IN BUFFER
	JSR GETBYT		;READ DESTINATION
	BPL BRANCH		;COMMAND KEY
	STA POINTL 		;SAVE DESTINATION IN BUFFER
	CLC
	LDA POINTL		;FETCH DESTINATION
	SBC POINTH		;SUBTRACT SOURCE
	STA INH
	DEC INH			;EQUALIZE AND SAVE OFFSET IN BUFFER
	JMP BR


;VECTORS AT THE END OF THE MEMORY:

*=$1FFA

	.WORD $1F2F		;NMI VECTOR
	.WORD $1C1D		;RESET VECTOR
	.WORD $1F32		;IRQ OR BRK VECTOR

;END OF JUNIOR'S MONITOR
