                        ;{ASSEMBLER=A65}
                        
                        ; ******************************************************************************
                        ; Junior Computer ][ BIOS Version 1.1.7
                        ; by Joerg Walke
                        ;
                        ; first implementation 28.12.2021
                        ; updated 30.10.2025
                        ; by Joerg Walke
                        ;
                        ; Assembled With A65
                        ;
                        ; 20.03.2023
                        ; A bug in the disassembler code was fixed by the
                        ; German Classic Computing forum user jet2bue. See version history
                        ;
                        ; 01.08.2023
                        ; A bug in SD_WR_BLK was fixed. The bug was found by German Classic Computing
                        ; forum user Dietrich Lausberg. See version history
                        ;
                        ; 29.04.2024
                        ; SPI & IRQ optimization by Dietrich Lausberg
                        ;
                        ; 26.05.24
                        ; Changes in Fast SPI by Dietrich Lausberg
                        ;
                        ; ******************************************************************************
                        ; To Do: (maybe in this order)
                        ;
                        ;  Paper Tape Reader Driver
                        ;  ...and many more...
                        ; ******************************************************************************
                        
   0031                 VERMAIN   	EQU     '1'    		; BIOS main version
   0031                 VERPSUB    	EQU     '1'    		; BIOS primary sub version
   0037                 VERSSUB		EQU	'7'		; BIOS secondary sub version
                        
   0001                 RETURN_VECT     EQU     $0001           ; return vector to monitor caller
   1C1D                 RESET     	EQU  	$1C1D       	; original junior monitor reset vector
                        
                        ; Buffers **********************************************************************
                        
   1400                 STRBUF	  	EQU   	$1400    	; input string buffer at $1400
                        
   1500                 RBUFF     	EQU   	$1500    	; xmodem receive buffer at $1500
                        
                        ; Card Base Addresses **********************************************************
                        
   0014                 IOBASE		EQU	$14		; pointer to IO card base
   0014                 IOBASEL		EQU	$14		; always $00
   0015                 IOBASEH		EQU	$15		; K2 = $08, K3 = $0C, K4 = $10
                        
   0016                 FGCBASE	        EQU	$16		; pointer to Floppy-/Graphics-Controller card base
   0016                 FGCBASEL	EQU	$16		; always $00
   0017                 FGCBASEH	EQU	$17		; (K2 = $08, K3 = $0C,) should always K4 = $10
                        
   0018                 CARD3BASE	EQU	$18		; reserved (controller base)
   0018                 CARD3BASEL	EQU	$18		; always $00
   0019                 CARD3BASEH	EQU	$19		; K2 = $08, K3 = $0C, K4 = $10
                        
                        ; ******************************************************************************
                        
   00C1                 FDC_MOTOR       EQU     $C1             ; current motor status
                        
                        ; ******************************************************************************
                        
   00DA                 TICKCNT         EQU     $DA             ; current tick counter
                        
                        ; SPI/SD-Card Reader Variables *************************************************
                        
   00DB                 SD_TYPE		EQU	$DB		; SD Card Type
                        
                        ; ACIA And Terminal Variables **************************************************
                        
   00EA                 PSTR      	EQU   	$EA      	; output string Pointer
   00EA                 PSTRL     	EQU   	$EA      	; lower address byte of output string pointer
   00EB                 PSTRH     	EQU   	$EB      	; upper address byte of output string pointer
   00EC                 WBUF      	EQU   	$EC      	; ACIA character output buffer
                        
                        ; ******************************************************************************
                        
   0003                 DEVID		EQU	$03		; temp device id
                        
                        ; Device Driver Variables ******************************************************
                        
   00DE                 PDEV		EQU	$DE		; device descriptor pointer
   00DE                 PDEVL    	EQU   	$DE      	; device descriptor pointer lo byte
   00DF                 PDEVH    	EQU   	$DF      	; device descriptor pointer hi byte
                        
                        ; XModem Transfer Variables ****************************************************
                        
   00DC                 CRCL      	EQU   	$DC      	; CRC lo byte
   00DD                 CRCH      	EQU   	$DD     	; CRC hi byte
                        
   00DE                 RETRYL    	EQU   	$DE      	; retry counter lo byte
   00DF                 RETRYH    	EQU   	$DF      	; retry counter hi byte
                        
   00E0                 BLKEND      	EQU     $E0		; block end flag
   00E1                 BFLAG     	EQU   	$E1      	; block flag
   00E2                 BLKNO     	EQU   	$E2      	; block number
   00E3                 ERRCNT    	EQU   	$E3      	; error counter 10 is the limit
                        
                        ; Disassembler Variables *******************************************************
                        
   00E0                 OPCODE		EQU	$E0		; current opcode
   00E1                 LINECNT		EQU	$E1		; number of disassembled lines
   00E2                 ADRMODE		EQU	$E2		; addressing mode
   00E3                 IBYTES		EQU	$E3		; instruction byte count
                        
                        ; I2C Variables ****************************************************************
                        
   00E0                 I2C_DATA	EQU	$E0		; current I2C data byte
                        
                        ; TTY Variables ****************************************************************
                        
   00E0                 BAUDRATE  	EQU   	$E0    		; current baud rate
                        
                        ; Tape Reader/Writer Variables *************************************************
                        
   00DC                 CHECKSUM	EQU	$DC		; file checksum
   00DD                 OUTBYTE		EQU	$DD		; data byte read/written from/to tape
                        
   00E1                 EQUFLAG		EQU	$E1		; file name equal flag
                        
   00E5                 KEY_SENSE	EQU	$E5		; datasette key sense flag
   00ED                 BITCNT		EQU	$ED		; current read bit count
                        
                        ; SD-Card Command Buffer *******************************************************
                        
   00DE                 SD_CMD		EQU	$DE		; CMD Byte
   00DF                 SD_PB3      	EQU   	$DF   		; Parameter Byte 3
   00E0                 SD_PB2		EQU   	$E0   		; Parameter Byte 2
   00E1                 SD_PB1      	EQU   	$E1   		; Parameter Byte 1
   00E2                 SD_PB0		EQU	$E2   		; Parameter Byte 0
   00E3                 SD_CRC		EQU	$E3   		; CRC Byte
                        
   00DC                 BLKBUF		EQU	$DC             ; pointer to block buffer
   00DC                 BLKBUFL		EQU	$DC             ; lower byte of block buffer pointer
   00DD                 BLKBUFH		EQU	$DD             ; upper byte of block buffer pointer
                        
                        ; Pointer to Logical Block Address *********************************************
                        
   00E6                 PLBA		EQU	$E6		; LBA pointer
   00E6                 PLBAL		EQU	$E6		; LBA pointer low byte
   00E7                 PLBAH		EQU	$E7		; LBA pointer high byte
                        
                        ; VIA2 Variables ***************************************************************
                        
   00E4                 VIA_STATUS 	EQU	$E4 		; current VIA2 PortB output status
                        
                        ; Hex Monitor Variables ********************************************************
                        
   00E6                 ASCL	  	EQU   	$E6     	; ASCII list start address low
   00E7                 ASCH      	EQU   	$E7     	; ASCII list start address high
                        
   00E8                 STOL      	EQU   	$E8     	; store address Low
   00E9                 STOH      	EQU   	$E9     	; store address High
                        
   00F8                 NUML      	EQU   	$F8     	; low number byte
   00F9                 NUMH	  	EQU   	$F9	 	; high number byte
   00FA                 ADRL      	EQU   	$FA     	; last address Low
   00FB                 ADRH      	EQU   	$FB     	; last address High
   00FC                 TEMP      	EQU   	$FC     	; temp storage
   00FD                 YSAV      	EQU   	$FD     	; Y register storage
   00FE                 PDBCNT    	EQU   	$FE     	; number of printed data bytes
   00FF                 MODE      	EQU   	$FF     	; current edit mode
                        
   00EE                 PSAV            EQU     $EE
                        
                        ; Number String ****************************************************************
                        
   00F8                 DIG0      	EQU   	$F8     	; 10^0 digit
   00F9                 DIG1	  	EQU   	$F9	 	; 10^1 digit
   00FA                 DIG2      	EQU   	$FA     	; 10^2 digit
                        
                        ; CPU Register Save ************************************************************
                        
   00EF                 PCL		EQU	$EF		; program counter Low
   00F0                 PCH		EQU	$F0		; program counter High
   00F1                 PREG		EQU	$F1		; processor status register
   00F2                 SPUSER		EQU	$F2		; stack pointer
   00F3                 ACC		EQU	$F3		; accumulator
   00F4                 YREG		EQU	$F4		; y-register
   00F5                 XREG		EQU	$F5		; x-register
                        
                        ; Clock Variables **************************************************************
                        
   00F2                 DIVCHAR		EQU	$F2             ; current divider char (. or / for date : for time)
                        
                        ; ACIA Registers ***************************************************************
                        
   1600                 DATA_REG  	EQU   	$1600    	; ACIA Data Register
   1601                 STAT_REG  	EQU   	$1601    	; ACIA Status Register
   1602                 COMM_REG  	EQU   	$1602    	; ACIA Command Register
   1603                 CTRL_REG  	EQU   	$1603    	; ACIA Control Register
                        
                        ; RIOT RAM Area ****************************************************************
                        
   1A00                 IO_INFO         EQU     $1A00           ; Initialization info call for IO card
                        
   1A24                 KEY_HANDLER     EQU     $1A24           ; character input handler
   1A26                 NKEY_HANDLER    EQU     $1A26           ; no character input handler
   1A28                 DEVLIST		EQU	$1A28		; start of device driver list
                        
   1A66                 STDBEEP		EQU	$1A66		; current standard beep routine
   1A68                 DEVIN		EQU	$1A68		; current opened device input routine
   1A6A                 DEVOUT		EQU	$1A6A		; current opened device output routine
   1A6C                 DEVCMD		EQU	$1A6C		; current opened device command routine
   1A6E                 STDIN		EQU	$1A6E		; current standard input routine
   1A70                 STDOUT		EQU	$1A70		; current standard output routine
   1A72                 STDCMD		EQU	$1A72		; current standard command routine
   1A74                 STDINDEV  	EQU   	$1A74    	; absolut standard input device id
   1A75                 STDOUTDEV  	EQU   	$1A75    	; absolut standard output device id
   1A76                 STDPRINTDEV	EQU	$1A76		; absolutstandard printer device id
   1A77                 STOACC		EQU	$1A77		; last accumulator before interrupt
                        
                        ; Interrupt Vectors ************************************************************
                        
   1A78                 BRKUSR		EQU	$1A78		; address of user BREAK vector
   1A7A                 NMIVECT		EQU     $1A7A           ; address of NMI vector
   1A7C                 IRQUSR  	EQU   	$1A7C    	; address of user IRQ vector
   1A7E                 IRQVECT  	EQU   	$1A7E    	; address of main IRQ vector
                        
                        ; Timer Register ***************************************************************
                        
   1A94                 CNTA	  	EQU	$1A94	 	; CLK/1T no interrupt
   1A95                 CNTB	  	EQU	$1A95	 	; CLK/8T no interrupt
   1A96                 CNTC	  	EQU	$1A96	 	; CLK/64T no interrupt
   1A97                 CNTD	  	EQU	$1A97    	; CLK/1024T no interrupt
                        
   1A9F                 CNTIRQ		EQU	$1A9F		; Timer Interrupt Register
                        
                        ; Port Register ****************************************************************
                        
   1A80                 PAD		EQU     $1A80		; Port A Data Register
   1A81                 PADD		EQU	$1A81		; Port A Data Direction Register
   1A82                 PBD		EQU	$1A82		; Port B Data Register
   1A83                 PBDD		EQU	$1A83		; Port B Data Direction Register
                        
   1A85                 WRDC		EQU	$1A85		; Write = set positive edge detection, no int.
                        					; Read = get Edge Control Interrupt Register
                        
                        ; IO Base Addresses ************************************************************
                        
   0800                 K2		EQU	$0800		; Base address of IO select K2
   0C00                 K3		EQU	$0C00		; Base address of IO select K3
   1000                 K4		EQU	$1000		; Base address of IO select K4
                        
                        ; PIA Register Indices *********************************************************
                        
   000C                 PIA_PORTA       EQU     $0C             ; Port A input/output register
   000D                 PIA_PORTB       EQU     $0D             ; Port B input/output register
   000E                 PIA_PORTC       EQU     $0E             ; Port C input/output register
   000F                 PIA_CONTROL     EQU     $0F             ; Control/Setup register
                        
                        ; VIA 1 Register Indices *******************************************************
                        
   0000                 VIA_PORTB     	EQU  	$00  		; Port B input/output register
   0001                 VIA_PORTA     	EQU  	$01  		; Port A input/output register
   0002                 VIA_DDRB   	EQU  	$02		; Port B data direction register
   0003                 VIA_DDRA   	EQU  	$03		; Port A data direction register
   0004                 VIA_T1CL   	EQU  	$04		; Timer 1 counter low byte register
   0005                 VIA_T1CH   	EQU  	$05		; Timer 1 counter high byte register
   0006                 VIA_T1LL   	EQU  	$06		; Timer 1 latched counter low byte register
   0007                 VIA_T1LH   	EQU  	$07		; Timer 1 latched counter high byte register
   0008                 VIA_T2CL   	EQU  	$08		; Timer 2 counter low byte register
   0009                 VIA_T2CH   	EQU  	$09		; Timer 2 counter high byte register
   000A                 VIA_SR     	EQU  	$0A		; Shift register
   000B                 VIA_ACR    	EQU  	$0B		; Auxilary control register
   000C                 VIA_PCR    	EQU  	$0C		; Periheral control register
   000D                 VIA_IFR    	EQU  	$0D		; Interrupt flag register
   000E                 VIA_IER    	EQU  	$0E		; Interrupt enable register
   000F                 VIA_PANOHS 	EQU  	$0F
                        
                        ; VIA 2 Register Indices *******************************************************
                        
   0010                 PORTB     	EQU  	$10  		; Port B input/output register
   0011                 PORTA     	EQU  	$11  		; Port A input/output register
   0012                 DDRB   		EQU  	$12		; Port B data direction register
   0013                 DDRA   		EQU  	$13		; Port A data direction register
   0014                 T1CL   		EQU  	$14		; Timer 1 counter low byte register
   0015                 T1CH   		EQU  	$15		; Timer 1 counter high byte register
   0016                 T1LL   		EQU  	$16		; Timer 1 latched counter low byte register
   0017                 T1LH   		EQU  	$17		; Timer 1 latched counter high byte register
   0018                 T2CL   		EQU  	$18		; Timer 2 counter low byte register
   0019                 T2CH   		EQU  	$19		; Timer 2 counter high byte register
   001A                 SR     		EQU  	$1A		; Shift register
   001B                 ACR    		EQU  	$1B		; Auxilary control register
   001C                 PCR    		EQU  	$1C		; Peripheral control register
   001D                 IFR    		EQU  	$1D		; Interrupt flag register
   001E                 IER    		EQU  	$1E		; Interrupt enable register
   001F                 PANOHS 		EQU  	$1F
                        
                        ; Pointer To Programming Language Name *****************************************
                        
   DFF0                 LANGKEY		EQU     $DFF0
   DFF1                 LANGNAME	EQU	LANGKEY+1
                        
                        ; Constants ********************************************************************
                        
   0020                 CENTURY		EQU	$20		; the 20th century. change to travel in time
                        
   002E                 DATEDIV		EQU	'.'		; divider char for date string
   003A                 TIMEDIV		EQU	':'		; divider char for time string
                        
   002A                 PROMPT    	EQU     '*'    		; prompt character
   002D                 ADIV      	EQU     '-'    		; address divider
   0008                 BS        	EQU     $08    		; backspace key
   000D                 CR        	EQU     $0D    		; carriage return
   000A                 LF	  	EQU     $0A    		; line feed
   0018                 CAN		EQU     $18		; Cancel
   001B                 ESC       	EQU     $1B    		; ESC
   0020                 SPC		EQU     $20		; space char
                        
   0001                 SOH       	EQU     $01    		; start of header
   0004                 EOT       	EQU     $04    		; end of text
   0006                 ACK       	EQU     $06    		; acknowledged
   0015                 NAK       	EQU     $15    		; not acknowledged
                        
                        ; Tape Reader/Writer Constants *************************************************
                        
   002E                 SYNCMARK	EQU	$2E		; synchronisation mark
   00A0                 NAMEMARK	EQU	$A0		; start of name mark
   00A1                 ADDRMARK	EQU	$A1		; start of address mark
   001F                 FILEMARK	EQU	$1F		; start of file mark
                        
   0031                 RPTIME		EQU	49		; read point time   49x8uS     = 392uS
   00BE                 LPTIME		EQU	190		; long pulse time   190uS+50uS = 240uS
   003C                 SPTIME		EQU	60		; short pulse time  60uS+50uS  = 120uS
                        
                        ; Device Driver Constants ******************************************************
                        
   0081                 KBD_MAGIC_NUM   EQU	129             ; magic number of keyboard ROM
                        
   0010                 COM_DEV	        EQU	$10             ; COM devices base ID
   0020                 STORAGE_DEV	EQU	$20             ; STORAGE devices base ID
                        
   0000                 NULL_ID		EQU	$00             ; the NULL device
                        
   0010                 TTY1_ID		EQU	COM_DEV+0       ; TTY 1 device ID
   0011                 PRINTER1_ID	EQU	COM_DEV+1       ; Printer 1 device ID
   0012                 PRINTER2_ID	EQU	COM_DEV+2       ; Printer 2 device ID
   0013                 KEYBD1_ID	EQU	COM_DEV+3       ; Keyboard 1 device ID (ASCII Keyboard)
   0014                 KEYBD2_ID	EQU	COM_DEV+4       ; Keyboard 2 device ID (PS/2 Keyboard)
   0015                 VDP1_ID         EQU     COM_DEV+5       ; Video Display Processor device ID
                        
   0020                 XMODEM1_ID	EQU	STORAGE_DEV+0   ; XModem device ID
   0021                 TAPE1_ID	EQU	STORAGE_DEV+1   ; Tape 1 device ID
   0022                 FDD1_ID         EQU     STORAGE_DEV+2   ; Floppy drive 1 device ID
   0023                 FDD2_ID         EQU     STORAGE_DEV+3   ; Floppy drive 2 device ID
   0024                 SDC1_ID		EQU	STORAGE_DEV+4   ; SD-Card device ID
   0025                 HDD1_ID		EQU	STORAGE_DEV+5   ; Harddisk 1 device ID
   0026                 HDD2_ID		EQU	STORAGE_DEV+6   ; Harddisk 2 device ID
                        
                        ; Device Command Constants *****************************************************
                        
   0000                 CMD_INIT	EQU	0               ; Init device
   0001                 CMD_IDENTIFY	EQU	1               ; Identify device
   0002                 CMD_NORMAL	EQU	2               ; Set normal text
   0003                 CMD_INVERSE	EQU	3               ; Set inverse text
   0004                 CMD_FLASH	EQU	4               ; Set blinking text
   0005                 CMD_HOME	EQU	5               ; Set cursor to home position
   0006                 CMD_CLRLINE	EQU	6               ; Clear line at cursor
   0007                 CMD_CLRSCRN	EQU	7               ; Clear screen
   0008                 CMD_MOVE_TO     EQU     8               ; Set pen position X,Y
   0008                 CMD_SETCURSOR	EQU	8               ; Set cursor position X,Y
   0009                 CMD_CRSR_ONOFF  EQU     9               ; Turn cursor on or off
   000A                 CMD_COLOR       EQU     10              ; Set pixel color
   000B                 CMD_TEXT_COLOR  EQU     11              ; Set text color
   000C                 CMD_BACK_COLOR  EQU     12              ; Set background color
   000D                 CMD_STD_PALETTE EQU     13              ; Reset to standard color palette
   000F                 CMD_MODE        EQU     15              ; Set text/graphics modes
                        
   0010                 CMD_SETSTARTADR	EQU	16              ; Set start address [X:Y]
   0011                 CMD_SETENDADR	EQU	17              ; Set end address [X:Y]
                        
   0020                 CMD_LOAD	EQU	32              ; Load data byte from device
   0021                 CMD_SAVE	EQU	33              ; Save data byte to device
   0022                 CMD_READ	EQU	34              ; Read data block from device
   0023                 CMD_WRITE	EQU	35              ; Write data block to device
   0024                 CMD_BOOT        EQU     36              ; Boot from device
   0025                 CMD_READ_BUF	EQU	37              ; Read data block from device to standard buffer
   0026                 CMD_WRITE_BUF	EQU	38              ; Write data block to device from standard buffer
                        
   0050                 CMD_PUT_PIXEL   EQU     $50             ; Draw pixel
   0051                 CMD_AND_PIXEL   EQU     $51
   0052                 CMD_OR_PIXEL    EQU     $52
   0053                 CMD_XOR_PIXEL   EQU     $53
   0054                 CMD_NOT_PIXEL   EQU     $54
   0058                 CMD_T_PUT_PIXEL EQU     $58
   0059                 CMD_T_AND_PIXEL EQU     $59
   005A                 CMD_T_OR_PIXEL  EQU     $5A
   005B                 CMD_T_XOR_PIXEL EQU     $5B
   005C                 CMD_T_NOT_PIXEL EQU     $5C
                        
   0060                 CMD_DRAW_RECT   EQU     $60             ; framed rectangle
   0061                 CMD_AND_RECT    EQU     $61
   0062                 CMD_OR_RECT     EQU     $62
   0063                 CMD_XOR_RECT    EQU     $63
   0064                 CMD_NOT_RECT    EQU     $64
   0068                 CMD_T_DRAW_RECT EQU     $68
   0069                 CMD_T_AND_RECT  EQU     $69
   006A                 CMD_T_OR_RECT   EQU     $6A
   006B                 CMD_T_XOR_RECT  EQU     $6B
   006C                 CMD_T_NOT_RECT  EQU     $6C
                        
   0070                 CMD_DRAW_LINE   EQU     $70             ; Draw line
   0071                 CMD_AND_LINE    EQU     $71
   0072                 CMD_OR_LINE     EQU     $72
   0073                 CMD_XOR_LINE    EQU     $73
   0074                 CMD_NOT_LINE    EQU     $74
   0078                 CMD_T_DRAW_LINE EQU     $78
   0079                 CMD_T_AND_LINE  EQU     $79
   007A                 CMD_T_OR_LINE   EQU     $7A
   007B                 CMD_T_XOR_LINE  EQU     $7B
   007C                 CMD_T_NOT_LINE  EQU     $7C
                        
   0080                 CMD_DRAW_BAR    EQU     $80             ; filled rectangle
   0081                 CMD_AND_BAR     EQU     $81
   0082                 CMD_OR_BAR      EQU     $82
   0083                 CMD_XOR_BAR     EQU     $83
   0084                 CMD_NOT_BAR     EQU     $84
   0088                 CMD_T_DRAW_BAR  EQU     $88
   0089                 CMD_T_AND_BAR   EQU     $89
   008A                 CMD_T_OR_BAR    EQU     $8A
   008B                 CMD_T_XOR_BAR   EQU     $8B
   008C                 CMD_T_NOT_BAR   EQU     $8C
                        
                        ; SD Command Constants *********************************************************
                        
   0040                 CMD0		EQU	$40		; Reset SD-Card
   0041                 CMD1		EQU	CMD0 + 1	; Initialize MMC/SDC
   0048                 CMD8		EQU	CMD0 + 8	; Check voltage range
   004D                 CMD13		EQU	CMD0 + 13	;
   0050                 CMD16		EQU	CMD0 + 16	; Change block size
   0051                 CMD17		EQU	CMD0 + 17	; Read single block
   0058                 CMD24		EQU	CMD0 + 24	; Write single block
   0077                 CMD55		EQU	CMD0 + 55	; Application command prefix
   007A                 CMD58		EQU	CMD0 + 58	; Get OCR
   0069                 ACMD41		EQU	CMD0 + 41	; Initialize SDC
                        
   00FE                 DATA_TOKEN	EQU	$FE             ; SD-Card Data Token
                        
                        ; Block Device Constants *******************************************************
                        
   0400                 MOUNT_TABLE     EQU     $0400           ; Table of mounted devices
   0400                 BOOT_PART       EQU     MOUNT_TABLE     ; Boot Medium Descriptor
   0600                 BLOCK_BUF	EQU	$0600           ; Block Device Block Buffer
   0600                 MBR             EQU     BLOCK_BUF       ; Master Boot Block Code
   07BE                 PART0		EQU	$07BE		; Partition 0 start
   07C6                 PART0_RS	EQU	PART0 + 8 	; Partition 0 relative sector field
   07CE                 PART0_SIZE	EQU	PART0 + 16	; Partition 0 sector size field
                        
   07FE                 BOOTBLK_TAG     EQU     $07FE           ; Address of Boot Block Tag ($55 $AA)
                        
                        ; Miscellanious Constants ******************************************************
                        
   0068                 I2C_RTC_ADR	EQU	$68		; I2C address of DS1307 Real Time Clock
                        
                        
   1000                 FGC_BASE        EQU     $1000
   1003                 FDC_OPT_REG     EQU     FGC_BASE+3
   1004                 FDC_MOTOR1_REG  EQU     FGC_BASE+4
   1005                 FDC_MOTOR2_REG  EQU     FGC_BASE+5
   1010                 FGC_INFO        EQU     FGC_BASE+$10
   1013                 FGC_SET_PAGE    EQU     FGC_BASE+$13
   1017                 FGC_FDC_CMD     EQU     FGC_BASE+$17
   101F                 FGC_VPU_CMD     EQU     FGC_BASE+$1F
   1027                 FGC_VPU_OUT     EQU     FGC_BASE+$27
                        
   1009                 VPU_PORT1       EQU     FGC_BASE+$09    ; VPU Port 1
   0080                 VPU_REG0        EQU     $80             ; VPU register 0
   008F                 VPU_REG15       EQU     VPU_REG0+15     ; VPU status register pointer
   0000                 VPU_STAT0       EQU     0               ; VPU status register 0
                        
                        
                        ; TEMP *************************************************************************
                        
   2000                 PPORTLOAD	EQU	$2000		; jump location for test code
   2003                 PPORTSAVE	EQU	$2003		; jump location for test code
                        
                        
                        ; ******************************************************************/***********
                        ; //////////////////////////////////////////////////////////////////////////////
                        ; ******************************************************************************
                        
   E000                 		ORG 	$E000       	; start address of Monitor
                        
                        ; ******************************************************************************
                        ; //////////////////////////////////////////////////////////////////////////////
                        ; ******************************************************************************
                        
   E000   4C 3C E4      MON_COLD_START	JMP  	MAINSTART	; jump to monitor cold start
   E003   4C 3B E6      MON_WARM_START	JMP	MONINP		; jump to monitor warm start
                        
                        ; **** Switch To RAM Page (B000..DFFF) *****************************************
                        
                        ; ******************************************************************************
                        
   E006   A0 20         SWITCH_TO_RAM	LDY	#$20		; load index to RAM annunciator
   E008   D0 02         		BNE	SWITCH		; branch always
                        
                        ; **** Switch To ROM Page (B000..DFFF) *****************************************
                        
                        ; ******************************************************************************
                        
   E00A   A0 30         SWITCH_TO_ROM	LDY	#$30		; load index to ROM annunciator
   E00C   B1 14         SWITCH		LDA	(IOBASE),Y	; trigger annunciator address
   E00E   60            		RTS
                        
                        ; **** Set Standard In/Out Routine ID ******************************************
                        
                        ; Input: A - ID Of Standard IO Device
                        
                        ; ******************************************************************************
                        
   E00F   20 D1 F7      SET_STDIOID	JSR	DEV_OPEN
                        
                        ; **** Set Standard In/Out Routine *********************************************
                        
                        ; Input: X - Low Byte Of Standard Device Descriptor
                        ;	 Y - High Byte Of Standard Device Descriptor
                        
                        ; ******************************************************************************
                        
   E012   20 32 E0      SET_STDIO	JSR	SET_STDIN
   E015   4C 1F E0      		JMP	SET_STDOUT0
                        
                        ; **** Set Standard Out Routine ID *********************************************
                        
                        ; Input: A - ID Of Standard Output Device
                        
                        ; ******************************************************************************
                        
   E018   20 D1 F7      SET_STDOUTID	JSR	DEV_OPEN
                        
                        ; **** Set Standard Out Routine ************************************************
                        
                        ; Input: X - Low Byte Of Standard Out Device Descriptor
                        ;	 Y - High Byte Of Standard Out Device Descriptor
                        
                        ; ******************************************************************************
                        
   E01B   86 DE         SET_STDOUT	STX	PDEVL
   E01D   84 DF         		STY	PDEVH
   E01F   A0 04         SET_STDOUT0	LDY	#$04
   E021   A2 00         		LDX	#$00
   E023   B1 DE         SET_STDOUT1	LDA	(PDEV),Y
   E025   9D 70 1A      		STA	STDOUT,X
   E028   C8            		INY
   E029   E8            		INX
   E02A   E0 04         		CPX	#$04
   E02C   D0 F5         		BNE	SET_STDOUT1
   E02E   60            		RTS
                        
                        ; **** Set Standard In Routine ID **********************************************
                        
                        ; Input: A - ID Of Standard Input Device
                        
                        ; ******************************************************************************
                        
   E02F   20 D1 F7      SET_STDINID	JSR	DEV_OPEN
                        
                        
                        ; **** Set Standard In Routine *************************************************
                        
                        ; Input: X - Low Byte Of Standard In Device Descriptor
                        ;	 Y - High Byte Of Standard In Device Descriptor
                        
                        ; ******************************************************************************
                        
   E032   86 DE         SET_STDIN	STX	PDEVL
   E034   84 DF         		STY	PDEVH
   E036   A0 02         		LDY	#$02
   E038   B1 DE         		LDA	(PDEV),Y
   E03A   8D 6E 1A      		STA	STDIN
   E03D   C8            		INY
   E03E   B1 DE         		LDA	(PDEV),Y
   E040   8D 6F 1A      		STA	STDIN+1
   E043   60                     	RTS
                        
                        ; **** Write Binary Routine ****************************************************
                        
                        ; Input: A - Output Byte to Standard Out
                        
                        ; ******************************************************************************
                        
   E044   6C 70 1A      BOUT		JMP	(STDOUT)
                        
                        ; **** Read Character Routine **************************************************
                        
                        ; Output: A - character read from standard in
                        
                        ; ******************************************************************************
                        
   E047   20 4D E0      CIN		JSR	CGET		; call standard in. Character available?
   E04A   90 FB         		BCC	CIN		; no, repeat
   E04C   60            		RTS
                        
                        ; **** Get Character (no wait) Routine *****************************************
                        
                        ; Output: A - character read from standard in
                        ;         C - 1 char get, 0 no char get
                        
                        ; ******************************************************************************
                        
   E04D   4C D4 E1      CGET            JMP     CHAR_GET
                        
                        ; **** Write LF Character Routine **********************************************
                        
                        ; ******************************************************************************
                        
   E050   A9 0A         LFOUT		LDA  	#LF        	; write a LF
                        					; fall through to COUT
                        
                        ; **** Write Character Routine *************************************************
                        
                        ; Input: A - character to write
                        
                        ; ******************************************************************************
                        
   E052   20 44 E0      COUT 		JSR     BOUT
   E055   C9 0D                         CMP  	#CR        	; character was a CR?
   E057   F0 F7         		BEQ  	LFOUT      	; yes, also write LF
   E059   60            		RTS
                        
                        ; **** Write CR/LF To Terminal *************************************************
                        
                        ; ******************************************************************************
                        
   E05A   A9 0D         CROUT		LDA	#CR		; write a CR
   E05C   D0 F4         		BNE	COUT
                        
                        ; **** Write Single Space Char To Terminal *************************************
                        
                        ; ******************************************************************************
                        
   E05E   A9 20         SPCOUT		LDA	#$20		; write a Space char
   E060   D0 E2         		BNE	BOUT
                        
                        ; **** Read String Routine *****************************************************
                        
                        ; Output:  (PSTRL, PSTRH) - pointer to CR terminated string data
                        
                        ; ******************************************************************************
                        
   E062   A2 02         STRIN           LDX  	#$02		; initialize character index
   E064   CA            BACKSPACE       DEX
   E065   F0 FB         		BEQ  	STRIN		; if line empty, restart
   E067   20 47 E0      NEXTCHR         JSR  	CIN        	; get next character from input buffer
   E06A   9D 00 14      		STA  	STRBUF,X   	; store character in string buffer
   E06D   C9 0D         		CMP  	#CR		; is it a CR?
   E06F   F0 0F                         BEQ  	ENDSTRIN	; yes, exit
   E071   20 52 E0                      JSR  	COUT		; echo character
   E074   C9 08         		CMP  	#BS        	; backspace key?
   E076   F0 EC         		BEQ  	BACKSPACE  	; yes
   E078   E8                            INX             	; advance string index
   E079   D0 EC                         BNE  	NEXTCHR    	; more then 255 characters? No, read next char
   E07B   A9 0D                         LDA  	#CR        	; yes, auto new line and stop reading
   E07D   9D 00 14      		STA  	STRBUF,X   	; store CR in string buffer
   E080   4C 52 E0      ENDSTRIN        JMP  	COUT       	; send CR
                        
                        ; **** Write String Routine ****************************************************
                        
                        ; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
                        
                        ; ******************************************************************************
                        
   E083   A0 00         STROUT		LDY  	#$00       	; index y is 0
                        
                        ; **** Write String From Index Routine *****************************************
                        
                        ; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
                        ;	  Y              - start index into string data
                        
                        ; ******************************************************************************
                        
   E085   B1 EA         WRSTR		LDA  	(PSTR),Y   	; load char at string pos y
   E087   F0 07         		BEQ  	ENDSTROUT  	; exit, if NULL char
   E089   20 52 E0      		JSR  	COUT       	; write character
   E08C   C8            		INY             	; next index
   E08D   4C 85 E0      		JMP  	WRSTR
   E090   60            ENDSTROUT	RTS
                        
                        ; **** Print A Byte In Hexadecimal *********************************************
                        
                        ; Input: A - data byte to print in hex
                        
                        ; ******************************************************************************
                        
   E091   48            HEXOUT          PHA             	; save A for lower hex digit
   E092   4A                            LSR  	A
   E093   4A                            LSR  	A
   E094   4A                            LSR  	A
   E095   4A                            LSR  	A
   E096   20 9A E0                      JSR  	HEXDIG		; write upper hex digit
   E099   68                            PLA             	; write lower hex digit
                        					; fall through to HEXDIG
                        
                        ; **** Print A Single Hexadecimal Digit ****************************************
                        
                        ; Input: A - data nibble in Bit 0-3 to print in hex
                        
                        ; ******************************************************************************
                        
   E09A   29 0F         HEXDIG          AND     #$0F    	; mask lower digit
   E09C   09 30                         ORA     #'0'    	; add 48
   E09E   C9 3A                         CMP     #'9'+1  	; decimal digit?
   E0A0   90 02                         BCC     PRHEX   	; yes, print it
   E0A2   69 06                         ADC     #6      	; add offset for letter digit
   E0A4   4C 44 E0      PRHEX		JMP     BOUT
                        
                        ; **** Print A Byte As Decimal Number ******************************************
                        
                        ; Input: A - number 00..FF (0..255)
                        
                        ; ******************************************************************************
                        
   E0A7   20 BD E0      NUMOUT		JSR	DEC2STR
   E0AA   A2 02         		LDX	#2
   E0AC   B5 F8         NEXTNUMOUT	LDA	DIG0,X
   E0AE   20 44 E0      		JSR	BOUT
   E0B1   CA            		DEX
   E0B2   10 F8         		BPL	NEXTNUMOUT
   E0B4   60            		RTS
                        
                        ; **** Clear Screen Routine ****************************************************
                        
                        ; ******************************************************************************
                        
   E0B5   A9 07         CLRSCRN		LDA	#CMD_CLRSCRN
                        
                        ; **** Call Standard Print Command Routine *************************************
                        
                        ; Input : A - command byte
                        ;         X - command data byte low
                        ;         Y - command data byte high
                        
                        ; ******************************************************************************
                        
   E0B7   6C 72 1A      CMDPRINT	JMP	(STDCMD)
                        
                        ; **** Call Opened Device Command Routine **************************************
                        
                        ; Input : A - command byte
                        ;         X - command data byte low
                        ;         Y - command data byte high
                        
                        ; ******************************************************************************
                        
   E0BA   6C 6C 1A      CMDDEV		JMP	(DEVCMD)
                        
                        ; **** Convert a Byte To Decimal String ****************************************
                        
                        ; Input:  A - number 00..FF (0..255)
                        ; Output; DIG0 (10^0), DIG1 (10^1), DIG2 (10^2)
                        
                        ; ******************************************************************************
                        
   E0BD   A2 30         DEC2STR		LDX	#48
   E0BF   86 F8         		STX	DIG0		; initialize digit counter 0 to '0'
   E0C1   86 F9         		STX	DIG1		; initialize digit counter 1 to '0'
   E0C3   86 FA         		STX	DIG2		; initialize digit counter 2 to '0'
   E0C5   C9 64         GETDIG2	CMP	#100			; is A >= 100?
   E0C7   90 06         		BCC	GETDIG1		; no, convert next digit
   E0C9   E9 64         		SBC	#100		; yes, subract 100 from A
   E0CB   E6 FA         		INC	DIG2		; and increment digit counter 2
   E0CD   D0 F6         		BNE	GETDIG2		; branch always
   E0CF   C9 0A         GETDIG1	CMP	#10			; is A >= 10?
   E0D1   90 06         		BCC	GETDIG0		; no, convert next digit
   E0D3   E9 0A         		SBC	#10		; yes, subract 10 from A
   E0D5   E6 F9         		INC	DIG1		; and increment digit counter 1
   E0D7   D0 F6         		BNE	GETDIG1		; branch always
   E0D9   65 F8         GETDIG0	ADC	DIG0			; add digit counter 0 to remainder in A
   E0DB   85 F8         		STA	DIG0		; and store it back to digit counter 0
   E0DD   60            		RTS
                        
                        ; **** Print Tab Routine *******************************************************
                        
                        ; Input: A - number of space characters to print
                        
                        ; ******************************************************************************
                        
   E0DE   85 FC         TAB		STA  	TEMP
   E0E0   A9 20         		LDA  	#SPC		; load SPC char
   E0E2   20 52 E0      PRINTTAB	JSR  	COUT		; write SPC
   E0E5   C6 FC         		DEC   	TEMP
   E0E7   D0 F9                         BNE   	PRINTTAB   	; all spaces written? No, repeat
   E0E9   60            		RTS
                        
                        ; **** Read Hex Number From Input String ***************************************
                        
                        ; Input:  Y - current input string position to read from
                        ; Output: (NUML, NUMH) - last 8 digits of read hex number
                        
                        ; ******************************************************************************
                        
   E0EA   A2 00         HEXINPUT	LDX   	#$00
   E0EC   86 F8         		STX   	NUML       	; clear input value
   E0EE   86 F9         		STX   	NUMH
   E0F0   B9 00 14      NEXTDIGIT       LDA   	STRBUF,Y   	; get next input char
   E0F3   C9 30         		CMP   	#'0'
   E0F5   90 21         		BCC   	NOTHEX     	; char < '0'? Yes, no hex digit
   E0F7   C9 3A         		CMP   	#':'
   E0F9   90 0C         		BCC   	NUMDIGIT   	; char is in '0'..'9'
   E0FB   29 DF         		AND   	#$DF	 	; uppercase chars only
   E0FD   C9 41         HEXDIGIT	CMP   	#'A'
   E0FF   90 17         		BCC   	NOTHEX     	; char < 'A'? Yes, no hex digit
   E101   C9 47         		CMP   	#'G'
   E103   B0 13         		BCS   	NOTHEX     	; char > 'F'? Yes, no hex digit
   E105   E9 36         		SBC   	#'A'-11	 	; char 'A'..'F' to value 10..16
   E107   0A            NUMDIGIT        ASL   	A
   E108   0A            		ASL   	A
   E109   0A            		ASL   	A
   E10A   0A            		ASL   	A		; digit shifted to upper nibble
   E10B   A2 04         		LDX   	#$04      	; load shift loop counter
   E10D   0A            SHIFT		ASL   	A		; shift msb in C
   E10E   26 F8         		ROL   	NUML
   E110   26 F9         		ROL   	NUMH
   E112   CA            		DEX
   E113   D0 F8         		BNE   	SHIFT	 	; 4 times shifted? No, repeat
   E115   C8            		INY		 	; increment string index
   E116   D0 D8         		BNE   	NEXTDIGIT	; branch always
   E118   60            NOTHEX		RTS
                        
                        ; **** Read String From Input Buffer *******************************************
                        
                        ; Input:  Y - current input string position to read from
                        ; Output: C = 1, string found C = 0, string not found
                        ;         PSTRL = low byte of string pointer
                        ;	  PSTRH = high byte of string pointer
                        
                        ; ******************************************************************************
                        
   E119   18            STRINPUT	CLC
   E11A   B9 00 14      NEXTSTRCHAR	LDA  	STRBUF,Y   	; get next input char
   E11D   C8            		INY
   E11E   C9 20         		CMP  	#' '
   E120   F0 F8         		BEQ  	NEXTSTRCHAR 	; ignore spaces
   E122   C9 0D         		CMP  	#CR
   E124   F0 19         		BEQ  	ENDSTRING 	; end of input line, no filename found
   E126   C9 22         		CMP	#'"'
   E128   D0 15         		BNE	ENDSTRING
   E12A   A2 00         		LDX	#$00
   E12C   38            		SEC
   E12D   B9 00 14      READSTRING	LDA  	STRBUF,Y   	; get next input char
   E130   C9 0D         		CMP	#CR
   E132   F0 0B         		BEQ	ENDSTRING
   E134   C9 22         		CMP	#'"'
   E136   F0 07         		BEQ	ENDSTRING
   E138   9D 00 15      		STA	RBUFF,X		; char to buffer
   E13B   C8            		INY
   E13C   E8            		INX
   E13D   D0 EE         		BNE	READSTRING	; read next char of filename
   E13F   A9 00         ENDSTRING	LDA	#$00
   E141   9D 00 15      		STA	RBUFF,X		; terminate filename string with NULL
                        
                        ; **** Set String Pointer To Read Buffer ***************************************
                        
                        ; Output: X - low byte of string pointer
                        ;	  Y - high byte of string pointer
                        
                        ; ******************************************************************************
                        
   E144   A2 00         SETSTRBUFF	LDX	#LOW RBUFF	; set string pointer to filename buffer
   E146   A0 15         		LDY	#HIGH RBUFF
   E148   86 EA         SETSTRBUFF0	STX	PSTRL
   E14A   84 EB         		STY	PSTRH
   E14C   60            		RTS
                        
                        ; **** Delay Routine ***********************************************************
                        
                        ; Input: A - milliseconds to wait
                        
                        ; ******************************************************************************
                        
   E14D   8D 97 1A      DELAY           STA  	CNTD
   E150   D0 04         		BNE	LOOPDELAY
                        
                        ; **** Short Delay Routine *****************************************************
                        
                        ; Input: A - microseconds to wait
                        
                        ; ******************************************************************************
                        
   E152   A8            SHORTDELAY	TAY
   E153   8C 94 1A      SHORTDELAY1	STY  	CNTA		; set counter
   E156   2C 9F 1A      LOOPDELAY	BIT  	CNTIRQ		; check if counter reached 0
   E159   10 FB         		BPL  	LOOPDELAY	; no, check again
   E15B   60            		RTS
                        
                        ; **** Check ESC Routine *******************************************************
                        
                        ; Output: C = 1 ESC pressed, 0 ESC not pressed
                        ; Beep if ESC pressed
                        
                        ; ******************************************************************************
                        
   E15C   20 4D E0      CHKESC		JSR     CGET            ; key pressed?
   E15F   90 05         		BCC	NOTESC		; no
   E161   C9 1B         		CMP     #ESC		; ESC pressed?
   E163   F0 02         		BEQ	BEEP		; yes, exit and beep.
   E165   18            		CLC			; no, clear carry flag
   E166   60            NOTESC		RTS
                        
                        ; **** System Beep Routine *****************************************************
                        
                        ; ******************************************************************************
                        
   E167   6C 66 1A      BEEP		JMP	(STDBEEP)	; call standard BEEP routine
                        
                        ; **** Simple Beep Routine *****************************************************
                        
                        ; ******************************************************************************
                        
   E16A   AD 83 1A      DOBEEP		LDA	PBDD		; save port b data direction register
   E16D   48            		PHA
   E16E   A2 60         		LDX     #$60		; repeat 60 times
   E170   A9 21         		LDA     #$21
   E172   A8            		TAY
   E173   8D 83 1A      		STA     PBDD		; turn speaker on
   E176   8C 82 1A      BEEPLOOP	STY     PBD		; set PB0 high
   E179   A9 01         		LDA     #$01
   E17B   20 4D E1      		JSR     DELAY		; delay of ~1ms
   E17E   88            		DEY
   E17F   8C 82 1A      		STY	PBD		; set PB0 low
   E182   A9 01         		LDA	#$01
   E184   20 4D E1      		JSR	DELAY		; delay of ~1ms
   E187   A0 21         		LDY	#$21
   E189   CA            		DEX
   E18A   D0 EA         		BNE	BEEPLOOP	; not finished, repeat
   E18C   68            		PLA
   E18D   8D 83 1A      		STA	PBDD		; restore port b data direction register
   E190   38            		SEC
   E191   60            		RTS
                        
                        ; ******************************************************************************
                        ; REAL TIME CLOCK ROUTINES ALIASES
                        ; ******************************************************************************
                        
                        ; **** Print Date And Time *****************************************************
                        
                        ; ******************************************************************************
                        
   E192   4C F6 EB      PRINT_DATETIME	JMP	PRINTDATETIME
                        
                        ; **** Print Time *************************************************************
                        
                        ; ******************************************************************************
                        
   E195   4C 02 EC      PRINT_TIME	JMP	PRINTTIME
                        
                        ; **** Print Date **************************************************************
                        
                        ; ******************************************************************************
                        
   E198   4C 28 EC      PRINT_DATE	JMP	PRINTDATE
                        
                        ; **** Print Date Including Day Of Week ****************************************
                        
                        ; ******************************************************************************
                        
   E19B   4C 14 EC      PRINT_FULLDATE	JMP	PRINTFULLDATE
                        
                        ; **** Set Date And Time *******************************************************
                        
                        ; ******************************************************************************
                        
   E19E   4C 56 EB      SET_DATETIME	JMP	SETDATETIME
                        
                        ; **** Set Time ****************************************************************
                        
                        ; ******************************************************************************
                        
   E1A1   4C 83 EB      SET_TIME	JMP	SETTIME
                        
                        ; **** Set Date ****************************************************************
                        
                        ; ******************************************************************************
                        
   E1A4   4C 59 EB      SET_DATE	JMP	SETDATE
                        
                        ; **** Add Device Driver *******************************************************
                        
                        ; Input:   X - device descriptor pointer low
                        ;          Y - device descriptor pointer high
                        ; Output - C = 1 Success, C = 0 Error
                        ;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
                        
                        ; ******************************************************************************
                        
   E1A7   4C 82 F7      ADD_DEVICE	JMP	DEV_ADD
                        
                        ; **** Open Device For Read/Write **********************************************
                        
                        ; Input:  A - device id
                        ; Output: C = 1 Success, C = 0 Error
                        ;         X - device descriptor pointer low
                        ;         Y - device descriptor pointer high
                        
                        ; ******************************************************************************
                        
   E1AA   4C D1 F7      OPEN_DEVICE	JMP	DEV_OPEN
                        
                        ; **** Reset Standard I/O To First Screen Device *******************************
                        
                        ; ******************************************************************************
                        
   E1AD   AD 74 1A      RESET_STDIO	LDA	STDINDEV	; open base In device
   E1B0   20 2F E0      		JSR	SET_STDINID	; and set it as standard input
   E1B3   AD 75 1A      		LDA	STDOUTDEV	; open base Out device
   E1B6   4C 18 E0      		JMP	SET_STDOUTID	; and set it as standard output
                        
                        ; **** Read Joystick Port ******************************************************
                        
                        ; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
                        ;         X - horizontal joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
                        ;         Y - vertical joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
                        ;         C = 0 - No joystick port available; C = 1 - Joystickport available
                        
                        ; ******************************************************************************
                        
   E1B9   4C 28 F7      READ_JOYSTICK   JMP     READ_JOY_PORT
                        
                        ; **** Decode Joystick Data ****************************************************
                        
                        ; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
                        ;         X - horizontal joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
                        ;         Y - vertical joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
                        
                        ; ******************************************************************************
                        
   E1BC   4C 30 F7      DECODE_JOYSTICK JMP     DECODE_JOY_PORT
                        
                        ; **** Mute All Sound Chip Channels ********************************************
                        
                        ; ******************************************************************************
                        
   E1BF   4C D0 E3      SOUND_MUTE_ALL  JMP     SOUND_MUTEALL
                        
                        ; **** Mute A Sound Chip Channel ***********************************************
                        
                        ; Input: A - Channel # (0..3)
                        
                        ; ******************************************************************************
                        
   E1C2   4C DA E3      SOUND_MUTE_CHAN JMP     SOUND_MUTE
                        
                        ; **** Set Attenuation For A Sound Chip Channel ********************************
                        
                        ; Input: A - Channel # (0..3)
                        ; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
                        
                        ; ******************************************************************************
                        
   E1C5   4C DC E3      SOUND_SET_ATN   JMP     SOUND_SETATN
                        
                        ; **** Set Periodic Noise ******************************************************
                        
                        ; Input: X - Noise Shift Rate
                        
                        ; ******************************************************************************
                        
   E1C8   4C EA E3      SOUND_P_NOISE   JMP     SOUND_PNOISE
                        
                        ; **** Set White Noise *********************************************************
                        
                        ; Input: X - Noise Shift Rate
                        
                        ; ******************************************************************************
                        
   E1CB   4C EE E3      SOUND_W_NOISE   JMP     SOUND_WNOISE
                        
                        ; **** Set Noise ***************************************************************
                        
                        ; Input: A - 0 = Periodic Noise  1 = White Noise
                        ;	 X - Noise Shift Rate
                        
                        ; ******************************************************************************
                        
   E1CE   4C F0 E3      SOUND_SET_NOISE JMP     SOUND_SETNOISE
                        
                        ; **** Set Sound Frequency in HZ ***********************************************
                        
                        ; Input: A - Channel (0..2)
                        ;	 X - Frequency Low Bits 7..0
                        ;	 Y - Frequency High Bits 9..8
                        
                        ; ******************************************************************************
                        
   E1D1   4C FB E3      SOUND_SET_FREQ  JMP     SOUND_SETFREQ
                        
                        ; ******************************************************************************
                        ; INTERNAL
                        ; ******************************************************************************
                        
                        ; **** Extended Read-Character Handler *****************************************
                        
   E1D4   20 DF E1      CHAR_GET        JSR     READ_STD_IN
   E1D7   90 03                         BCC     NO_CHAR_GET
   E1D9   6C 24 1A                      JMP     (KEY_HANDLER)
   E1DC   6C 26 1A      NO_CHAR_GET     JMP     (NKEY_HANDLER)
   E1DF   6C 6E 1A      READ_STD_IN     JMP	(STDIN)
                        
                        ; ******************************************************************************
                        ; TTY DEVICE DRIVER
                        ; ******************************************************************************
                        
                        ; **** Terminal Command Routine ************************************************
                        
                        ; Input : A - command byte
                        ;         X - command data byte low
                        ;         Y - command data byte high
                        
                        ; ******************************************************************************
                        
   E1E2   C9 09         TTY_CMD		CMP	#9
   E1E4   B0 13         		BCS	END_TTY_CMD
   E1E6   84 FD         		STY	YSAV
   E1E8   0A            		ASL	A
   E1E9   A8            		TAY
   E1EA   B9 FA E1      		LDA	TTY_CMD_TABLE,Y
   E1ED   85 EA         		STA	PSTRL
   E1EF   B9 FB E1      		LDA	TTY_CMD_TABLE+1,Y
   E1F2   85 EB         		STA	PSTRH
   E1F4   A4 FD         		LDY	YSAV
   E1F6   6C EA 00      		JMP     (PSTR)
   E1F9   60            END_TTY_CMD	RTS
                        
   E1FA   0C E2 3A E2   TTY_CMD_TABLE	DW	TTY_INIT,TTY_IDENTIFY,TTY_NORMAL,TTY_INVERSE,TTY_FLASH
   E1FE   3E E2 42 E2   
   E202   46 E2         
   E204   4A E2 4E E2   		DW	TTY_HOME,TTY_CLRLINE,TTY_CLRSCRN,TTY_SETCURSOR
   E208   57 E2 6C E2   
                        
                        ; **** Initialize TTY Device ***************************************************
                        
                        ; ******************************************************************************
                        
   E20C   A9 00         TTY_INIT	LDA  	#$00
   E20E   85 E0         		STA  	BAUDRATE   	; initialize baud rate variable
   E210   A9 0B         		LDA  	#$0B       	; set ACIA to
   E212   8D 02 16               	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
   E215   A2 19         		LDX  	#$19		; start with 1 stop bit, 8 data bits, 2400 bps as the current baud rate
   E217   8E 03 16      NEXTBAUD	STX  	CTRL_REG	; set the baud rate
   E21A   20 3A E2      		JSR  	TTY_IDENTIFY	; send identify string to terminal
   E21D   A9 28         		LDA  	#40
   E21F   20 4D E1      		JSR  	DELAY		; wait for ~64ms
   E222   AD 01 16      		LDA  	STAT_REG
   E225   29 08         		AND  	#$08		; ACIA input register full?
   E227   F0 0B         		BEQ  	NOESC	 	; no, go on
   E229   AD 00 16      		LDA  	DATA_REG    	; read data register from ACIA
   E22C   C9 1B         		CMP  	#ESC	 	; is it a ESC char
   E22E   D0 04         		BNE  	NOESC	 	; no, go on
   E230   86 E0         		STX  	BAUDRATE    	; and store it
   E232   A2 1F         		LDX  	#$1F	 	; detection finished
   E234   E8            NOESC           INX  			; try next baud rate
   E235   E0 20         		CPX  	#$20
   E237   90 DE         		BCC  	NEXTBAUD   	; tried all baud rates?
   E239   60            		RTS
                        
                        ; **** Identify TTY Device *****************************************************
                        
                        ; ******************************************************************************
                        
   E23A   A0 09         TTY_IDENTIFY    LDY  	#ESCGID-STRINGP	; load sequence index
   E23C   D0 1B         		BNE  	PRINTESC   	; jump always
                        
                        ; **** Set Normal Text *********************************************************
                        
                        ; ******************************************************************************
                        
   E23E   A0 0C         TTY_NORMAL      LDY  	#ESCNORM-STRINGP; load sequence index
   E240   D0 17         		BNE  	PRINTESC   	; jump always
                        
                        ; **** Set Inverse Text ********************************************************
                        
                        ; ******************************************************************************
                        
   E242   A0 0E         TTY_INVERSE     LDY  	#ESCINV-STRINGP ; load sequence index
   E244   D0 13         		BNE  	PRINTESC   	; jump always
                        
                        ; **** Set Blinking Text *******************************************************
                        
                        ; ******************************************************************************
                        
   E246   A0 11         TTY_FLASH       LDY  	#ESCBLNK-STRINGP; load sequence index
   E248   D0 0F         		BNE  	PRINTESC   	; jump always
                        
                        ; **** Set Cursor To Home Position *********************************************
                        
                        ; ******************************************************************************
                        
   E24A   A0 04         TTY_HOME        LDY  	#ESCHOME-STRINGP; load sequence index
   E24C   D0 0B         		BNE  	PRINTESC   	; jump always
                        
                        ; **** Clear Line **************************************************************
                        
                        ; ******************************************************************************
                        
   E24E   A9 0D         TTY_CLRLINE     LDA	#$0D
   E250   20 44 E0      		JSR	BOUT
   E253   A0 06         		LDY  	#ESCCLL-STRINGP	; load sequence index
   E255   D0 02         		BNE  	PRINTESC   	; jump always
                        
                        ; **** Clear Screen And Set Cursor To Home Position ****************************
                        
                        ; ******************************************************************************
                        
   E257   A0 00         TTY_CLRSCRN     LDY  	#ESCCLS-STRINGP	; load sequence index
                        					; fall through to PRINTESC
                        
                        ; **** VT100 ESC Sequence Loader ***********************************************
                        
                        ; ******************************************************************************
                        
   E259   20 62 E2      PRINTESC        JSR	TTY_ESCCODE
   E25C   20 40 E5      		JSR	LOADSTRING
   E25F   4C 85 E0      		JMP  	WRSTR
                        
                        ; **** VT100 ESC Start Code ****************************************************
                        
                        ; ******************************************************************************
                        
   E262   A9 1B         TTY_ESCCODE	LDA	#$1B
   E264   20 44 E0      		JSR	BOUT
   E267   A9 5B         		LDA	#'['
   E269   4C 44 E0      		JMP	BOUT
                        
                        ; **** Set Cursor Location *****************************************************
                        
                        ; Input: X - x position of cursor.  Y - y position of cursor
                        
                        ; ******************************************************************************
                        
   E26C   8A            TTY_SETCURSOR	TXA
   E26D   48            		PHA
   E26E   20 62 E2      		JSR	TTY_ESCCODE
   E271   98            		TYA
   E272   20 A7 E0      		JSR	NUMOUT
   E275   A9 3B         		LDA	#';'
   E277   20 44 E0      		JSR	BOUT
   E27A   68            		PLA
   E27B   20 A7 E0      		JSR	NUMOUT
   E27E   A9 48         		LDA	#'H'
   E280   4C 44 E0      		JMP	BOUT
                        
                        ; ******************************************************************************
                        ; LOW LEVEL REAL TIME CLOCK CODE
                        ; ******************************************************************************
                        
                        ; **** Set Day Of Week *********************************************************
                        
                        ; Input: A - Day Of Week 1 (MON) - 7 (SUN)
                        
                        ; ******************************************************************************
                        
   E283   85 F3         WRITEDOW	STA	ACC
   E285   A9 03         		LDA	#$03
   E287   20 13 E3      		JSR	SETRTCADR
   E28A   A5 F3         		LDA	ACC
   E28C   20 67 E3      		JSR	I2C_SEND	; set day of week
   E28F   4C 35 E3      		JMP	I2C_STOP
                        
                        ; **** Get Day Of Week *********************************************************
                        
                        ; Output: A - Day Of Week 1 (MON) - 7 (SUN)
                        
                        ; ******************************************************************************
                        
   E292   A9 03         READDOW		LDA	#$03
   E294   20 E6 E2      		JSR	READCLOCK
   E297   98            		TYA
   E298   60            		RTS
                        
                        ; **** Write Time **************************************************************
                        
                        ; Input: A - HOUR 	in BCD ($00-$23)
                        ;	 X - MINUTE 	in BCD ($00-$59)
                        ;	 Y - SECOND	in BCD ($00-$59)
                        
                        ; ******************************************************************************
                        
   E299   85 F3         WRITETIME	STA	ACC
   E29B   86 F5         		STX	XREG
   E29D   84 F4         		STY	YREG
   E29F   A9 00         WRITETIME2	LDA	#$00		; start at register 0
   E2A1   20 C9 E2      		JSR	WRITECLOCK	; write time bytes to clock registers
   E2A4   A9 08         		LDA	#$08		; set address pointer to ram
   E2A6   20 13 E3      		JSR	SETRTCADR
   E2A9   A9 65         		LDA	#$65		; time set mark
   E2AB   20 67 E3      		JSR	I2C_SEND
   E2AE   4C 35 E3      		JMP	I2C_STOP
                        
                        ; **** Write Date **************************************************************
                        
                        ; Input: A - YEAR 	in BCD ($00-$99)
                        ;	 X - MONTH 	in BCD ($01-$12)
                        ;	 Y - DAY	in BCD ($01-$31)
                        
                        ; ******************************************************************************
                        
   E2B1   85 F3         WRITEDATE	STA	ACC
   E2B3   86 F5         		STX	XREG
   E2B5   84 F4         		STY	YREG
   E2B7   A9 04         WRITEDATE2	LDA	#$04		; start at register 4
   E2B9   20 C9 E2      		JSR	WRITECLOCK	; write date bytes to clock register
   E2BC   A9 09         		LDA	#$09		; set address pointer to ram
   E2BE   20 13 E3      		JSR	SETRTCADR
   E2C1   A9 02         		LDA	#$02		; date set mark
   E2C3   20 67 E3      		JSR	I2C_SEND
   E2C6   4C 35 E3      		JMP	I2C_STOP
                        
                        ; **** Write Data To Clock *****************************************************
                        
                        ; ******************************************************************************
                        
   E2C9   20 13 E3      WRITECLOCK	JSR	SETRTCADR
   E2CC   A5 F4         		LDA	YREG
   E2CE   20 67 E3      		JSR	I2C_SEND	; set second or day
   E2D1   A5 F5         		LDA	XREG
   E2D3   20 67 E3      		JSR	I2C_SEND	; set minute or month
   E2D6   A5 F3         		LDA	ACC
   E2D8   20 67 E3      		JSR	I2C_SEND	; set hour or year
   E2DB   4C 35 E3      		JMP	I2C_STOP
                        
                        ; **** Read Time ***************************************************************
                        
                        ; Output: A - HOUR 	in BCD ($00-$23)
                        ;	  X - MINUTE 	in BCD ($00-$59)
                        ;	  Y - SECOND	in BCD ($00-$59)
                        
                        ; ******************************************************************************
                        
   E2DE   A9 00         READTIME	LDA	#$00
   E2E0   F0 04         		BEQ	READCLOCK
                        
                        ; **** Read Date ***************************************************************
                        
                        ; Output: A - YEAR 	in BCD ($00-$99)
                        ; 	  X - MONTH 	in BCD ($01-$12)
                        ; 	  Y - DAY	in BCD ($01-$31)
                        
                        
                        ; ******************************************************************************
                        
   E2E2   A9 04         READDATE	LDA	#$04
   E2E4   D0 00         		BNE	READCLOCK
                        
                        ; **** Read Data From Clock ****************************************************
                        
                        ; ******************************************************************************
                        
   E2E6   20 13 E3      READCLOCK	JSR	SETRTCADR	; set read pointer
   E2E9   20 26 E3      		JSR	I2C_START	; send start condition
   E2EC   A9 68         		LDA	#I2C_RTC_ADR	; the I2C address
   E2EE   20 62 E3      		JSR	I2C_READ_DEV	; send device id and set read mode
   E2F1   20 9F E3      		JSR	I2C_RCV		; receive first data byte
   E2F4   85 F4         		STA	YREG		; and store it
   E2F6   20 44 E3      		JSR	I2C_ACK		; send acknowlege
   E2F9   20 9F E3      		JSR	I2C_RCV		; receive second data byte
   E2FC   85 F5         		STA	XREG		; and store it
   E2FE   20 44 E3      		JSR	I2C_ACK		; send acknowlege
   E301   20 9F E3      		JSR	I2C_RCV		; receive third data byte
   E304   85 F3         		STA	ACC		; and store it
   E306   20 53 E3      		JSR	I2C_NACK	; no more data
   E309   20 35 E3      		JSR	I2C_STOP	; stop communication
   E30C   A5 F3         		LDA	ACC		; load third data byte into A
   E30E   A6 F5         		LDX	XREG		; load second data byte into X
   E310   A4 F4         		LDY	YREG		; load first data byte into Y
   E312   60            		RTS
                        
                        ; **** Set RTC Address Read/Write Pointer **************************************
                        
                        ; Input: A - Register Address
                        
                        ; ******************************************************************************
                        
   E313   48            SETRTCADR	PHA			; save register address onto stack
   E314   20 26 E3      		JSR	I2C_START	; send start condition
   E317   A9 68         		LDA	#I2C_RTC_ADR	; the I2C device address
   E319   20 66 E3      		JSR	I2C_WRITE_DEV	; send device address and write bit
   E31C   68            		PLA			; restore register address
   E31D   4C 67 E3      		JMP	I2C_SEND	; send register address
                        
                        ; ******************************************************************************
                        ; START OF DATA INPUT/OUTPUT CODE
                        ; ******************************************************************************
                        
                        ; ******************************************************************************
                        ; START OF VIA1 INPUT/OUTPUT CODE
                        ; ******************************************************************************
                        
                        ; **** Write To VIA1 Register **************************************************
                        
                        ; Input:  Y - Destination Register index (VIA_PORTA,VIA_DDRA...)
                        ;	  A - Data to be written into the Register
                        
                        ; ******************************************************************************
                        
   E320   91 14         WRITE_VIA	STA	(IOBASE),Y
   E322   60            		RTS
                        
                        ; **** Read From VIA1 Register *************************************************
                        
                        ; Input:  Y - Source Register index (VIA_PORTA,VIA_DDRA...)
                        ; Output: A - Read Data from the Register
                        
                        ; ******************************************************************************
                        
   E323   B1 14         READ_VIA	LDA	(IOBASE),Y
   E325   60            		RTS
                        
                        
                        ; ******************************************************************************
                        ; START OF I2C CODE
                        ; ******************************************************************************
                        
                        ; **** Send I2C Start Condition ************************************************
                        
                        ; ******************************************************************************
                        
   E326   A0 12         I2C_START	LDY	#DDRB
   E328   A9 5E         		LDA	#%01011110	; SDA = 1; SCL = 1
   E32A   91 14         		STA	(IOBASE),Y
   E32C   A9 DE         		LDA	#%11011110	; SDA = 0; SCL = 1
   E32E   91 14         		STA	(IOBASE),Y
   E330   A9 DF         		LDA	#%11011111	; SDA = 0; SCL = 0
   E332   91 14         		STA	(IOBASE),Y
   E334   60            		RTS
                        
                        ; **** Send I2C Stop Condition *************************************************
                        
                        ; ******************************************************************************
                        
   E335   A0 12         I2C_STOP	LDY	#DDRB
   E337   A9 DF         		LDA	#%11011111	; SDA = 0; SCL = 0
   E339   91 14         		STA	(IOBASE),Y
   E33B   A9 DE         		LDA	#%11011110	; SDA = 0; SCL = 1
   E33D   91 14         		STA	(IOBASE),Y
   E33F   A9 5E         		LDA	#%01011110	; SDA = 1; SCL = 1
   E341   91 14         		STA	(IOBASE),Y
   E343   60            		RTS
                        
                        ; **** Send I2C Acknowledged ***************************************************
                        
                        ; ******************************************************************************
                        
   E344   A0 12         I2C_ACK		LDY	#DDRB
   E346   A9 DF         		LDA	#%11011111	; SDA = 0; SCL = 0
   E348   91 14         		STA	(IOBASE),Y
   E34A   A9 DE         		LDA	#%11011110	; SDA = 0; SCL = 1
   E34C   91 14         		STA	(IOBASE),Y
   E34E   A9 DF         		LDA	#%11011111	; SDA = 0; SCL = 0
   E350   91 14         		STA	(IOBASE),Y
   E352   60            		RTS
                        
                        ; **** Send I2C Not Acknowledged ***********************************************
                        
                        ; ******************************************************************************
                        
   E353   A0 12         I2C_NACK	LDY	#DDRB
   E355   A9 5F         		LDA	#%01011111	; SDA = 1; SCL = 0
   E357   91 14         		STA	(IOBASE),Y
   E359   A9 5E         		LDA	#%01011110	; SDA = 1; SCL = 1
   E35B   91 14         		STA	(IOBASE),Y
   E35D   A9 5F         		LDA	#%01011111	; SDA = 1; SCL = 0
   E35F   91 14         		STA	(IOBASE),Y
   E361   60            		RTS
                        
                        ; **** Read I2C Device *********************************************************
                        
                        ; Input:  A - Device Address
                        ; Output: C - 0 = not acknowledged, 1 = acknowledged
                        
                        ; ******************************************************************************
                        
   E362   38            I2C_READ_DEV	SEC			; set carry flag
   E363   2A            		ROL	A		; shift device address one bit left and rotate C in LSB. LSB = 1 = read
   E364   D0 01         		BNE	I2C_SEND	; and send it
                        
                        ; **** Write I2C Device ********************************************************
                        
                        ; Input:  A - Device Address
                        ; Output: C - 0 = not acknowledged, 1 = acknowledged
                        
                        ; ******************************************************************************
                        
   E366   0A            I2C_WRITE_DEV	ASL	A		; shift device address one bit left. LSB is now 0 = write
                        					; directly fallthrough to I2C_SEND
                        
                        ; **** Send a Byte to I2C Device ***********************************************
                        
                        ; Input:  A - Data Byte
                        ; Output: C - 0 = not acknowledged, 1 = acknowledged
                        
                        ; ******************************************************************************
                        
   E367   85 E0         I2C_SEND	STA	I2C_DATA
   E369   A2 08         		LDX	#$08		; send 8 bits
   E36B   A0 12         		LDY	#DDRB
   E36D   06 E0         SENDLOOP	ASL	I2C_DATA	; get next bit into C flag
   E36F   B0 04         		BCS	SENDH		; is it a 1 bit?
   E371   A9 DF         		LDA	#%11011111	; no, SDA = 0; SCL = 0
   E373   D0 02         		BNE	SETBIT		; branch always
   E375   A9 5F         SENDH		LDA	#%01011111	; yes, SDA = 1; SCL = 0
   E377   91 14         SETBIT		STA	(IOBASE),Y
   E379   29 FE         		AND	#%11111110	; SDA = X; SCL = 1
   E37B   91 14         		STA	(IOBASE),Y
   E37D   09 01         		ORA	#%00000001	; SDA = X, SCL = 0
   E37F   91 14         		STA	(IOBASE),Y
   E381   CA            		DEX
   E382   D0 E9         		BNE	SENDLOOP
                        
   E384   A0 12         I2C_ACK?	LDY	#DDRB
                        
   E386   A9 5F         		LDA	#%01011111	; SDA = 1; SCL = 0
   E388   91 14         		STA	(IOBASE),Y
                        
   E38A   A9 5E         		LDA	#%01011110	; SDA = 1; SCL = 1
   E38C   91 14         		STA	(IOBASE),Y
   E38E   A0 10         		LDY	#PORTB
   E390   B1 14         		LDA	(IOBASE),Y	; get SDA
   E392   10 03         		BPL	ISACK		; SDA = 1 ?
   E394   18            		CLC			; no, not acknowledeged
   E395   90 01         		BCC	CLKDOWN
   E397   38            ISACK		SEC			; yes, acknowledeged
   E398   A0 12         CLKDOWN		LDY	#DDRB
   E39A   A9 5F         		LDA	#%01011111	; SCL = 0
   E39C   91 14         		STA	(IOBASE),Y
   E39E   60            		RTS
                        
                        ; **** Receive a Byte from I2C Device ******************************************
                        
                        ; Output: A - Data Byte
                        
                        ; ******************************************************************************
                        
   E39F   A2 09         I2C_RCV		LDX	#$09
   E3A1   A0 12         RCVLOOP		LDY	#DDRB
   E3A3   A9 5F         		LDA	#%01011111	; SDA = 1; SCL = 0
   E3A5   91 14         		STA	(IOBASE),Y
   E3A7   CA            		DEX
   E3A8   F0 0E         		BEQ	RCVEND		; all eight bits received?
   E3AA   A9 5E         		LDA	#%01011110	; SDA = 1; SCL = 1
   E3AC   91 14         		STA	(IOBASE),Y
   E3AE   A0 10         		LDY	#PORTB
   E3B0   B1 14         		LDA	(IOBASE),Y	; get SDA
   E3B2   0A            		ASL	A		; and shift it into C
   E3B3   26 E0         		ROL	I2C_DATA	; shift byte buffer one bit left. C goes into LSB
   E3B5   4C A1 E3      		JMP	RCVLOOP
   E3B8   A5 E0         RCVEND		LDA	I2C_DATA	; load data into A
   E3BA   60            		RTS
                        
                        ; ******************************************************************************
                        ; START OF SOUND GENERATOR CODE
                        ; ******************************************************************************
                        
                        ; **** Send A Command Byte To The Sound Chip ***********************************
                        
                        ; Input: A - Data Byte
                        
                        ; ******************************************************************************
                        
   E3BB   84 FD         SOUND_SENDBYTE	STY	YSAV		; save current Y register
   E3BD   A0 11         		LDY	#PORTA
   E3BF   91 14         		STA	(IOBASE),Y	; set data
   E3C1   A0 10         		LDY	#PORTB
   E3C3   A9 FD         		LDA	#%11111101	; Set sound WE low
   E3C5   25 E4         		AND	VIA_STATUS
   E3C7   91 14         		STA	(IOBASE),Y	; enable sound data write
   E3C9   A5 E4         		LDA	VIA_STATUS	; set sound WE high
   E3CB   91 14         		STA	(IOBASE),Y	; disable sound data write
   E3CD   A4 FD         		LDY	YSAV		; restore Y register
   E3CF   60            		RTS
                        
                        ; **** Mute All Sound Chip Channels ********************************************
                        
                        ; ******************************************************************************
                        
   E3D0   A0 03         SOUND_MUTEALL	LDY	#$03		; channels 0..3 to mute
   E3D2   98            NEXTCHANNEL	TYA
   E3D3   20 DA E3      		JSR	SOUND_MUTE	; mute current channel
   E3D6   88            		DEY			; next channel
   E3D7   10 F9         		BPL	NEXTCHANNEL	; loop if not all four channels done
   E3D9   60            		RTS
                        
                        ; **** Mute A Sound Chip Channel ***********************************************
                        
                        ; Input: A - Channel # (0..3)
                        
                        ; ******************************************************************************
                        
   E3DA   A2 0F         SOUND_MUTE	LDX	#$0F		; set attenuation level to maximum
                        					; fall through to set attenuation level
                        
                        ; **** Set Attenuation For A Sound Chip Channel ********************************
                        
                        ; Input: A - Channel # (0..3)
                        ; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
                        
                        ; ******************************************************************************
                        
   E3DC   86 FC         SOUND_SETATN	STX	TEMP		; store attenuation level in TEMP variable
   E3DE   18            		CLC			; clear carry flag
   E3DF   6A            		ROR	A		; and rotate channel number to bit 5 and 6
   E3E0   6A            		ROR	A
   E3E1   6A            		ROR	A
   E3E2   6A            		ROR	A
   E3E3   05 FC         		ORA	TEMP		; combine channel number with attenuation value
   E3E5   09 90         		ORA	#$90		; and also set bit 7 and 4
   E3E7   4C BB E3      		JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
                        
                        ; **** Set Periodic Noise ******************************************************
                        
                        ; Input: X - Noise Shift Rate
                        
                        ; ******************************************************************************
                        
   E3EA   A9 00         SOUND_PNOISE	LDA	#$00
   E3EC   F0 04         		BEQ	SET_NOISE
                        
                        ; **** Set White Noise *********************************************************
                        
                        ; Input: X - Noise Shift Rate
                        
                        ; ******************************************************************************
                        
   E3EE   A9 01         SOUND_WNOISE	LDA	#$01
                        
                        ; **** Set Noise ***************************************************************
                        
                        ; Input: A - 0 = Periodic Noise  1 = White Noise
                        ;	 X - Noise Shift Rate
                        
                        ; ******************************************************************************
                        
   E3F0   0A            SOUND_SETNOISE	ASL	A
   E3F1   0A            		ASL	A
   E3F2   86 FC         SET_NOISE	STX	TEMP
   E3F4   05 FC         		ORA	TEMP
   E3F6   09 F0         		ORA	#$F0
   E3F8   4C BB E3      		JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
                        
                        ; **** Set Sound Frequency in HZ ***********************************************
                        
                        ; Input: A - Channel (0..2)
                        ;	 X - Frequency Low Bits 7..0
                        ;	 Y - Frequency High Bits 9..8
                        
                        ; *****************************************************************************
                        
   E3FB   18            SOUND_SETFREQ	CLC			; clear carry flag
   E3FC   6A            		ROR	A		; and rotate channel number to bit 5 and 6
   E3FD   6A            		ROR	A
   E3FE   6A            		ROR	A
   E3FF   6A            		ROR	A
   E400   09 80         		ORA	#$80		; set high bit
   E402   85 FC         		STA	TEMP		; and store it in TEMP variable
   E404   8A            		TXA			; load frequency low bits into A
   E405   29 0F         		AND	#$0F		; we first want to send the lower 4 bits
   E407   05 FC         		ORA	TEMP		; combined it with the channel number
   E409   20 BB E3      		JSR	SOUND_SENDBYTE	; send complete first command byte to the sound chip
   E40C   98            		TYA			; load frequency high bits into A
   E40D   86 FC         		STX	TEMP		; store frequency low bits to TEMP variable
   E40F   A2 04         		LDX	#$04		; we need four bits shifted
   E411   06 FC         LOOP_NXT	ASL	TEMP		; shift highest bit of low frequency to Carry flag
   E413   2A            		ROL	A		; and shift it into the high frequency bits
   E414   CA            		DEX			; decrement counter
   E415   D0 FA         		BNE	LOOP_NXT	; do we need more shifts?
   E417   4C BB E3      		JMP	SOUND_SENDBYTE	; send complete second command byte to the sound chip
                        
                        ; ******************************************************************************
                        ; ***************************** MAIN MONITOR ***********************************
                        ; ******************************************************************************
                        
                        ; **** Auto Terminal And Baud Rate Detection Routine ***************************
                        
                        ; ******************************************************************************
                        
   E41A   A2 2A         INITVECT        LDX	#LOW  NMI	; set NMI service routine
   E41C   A0 F3                         LDY	#HIGH NMI
   E41E   8E 7A 1A      		STX	NMIVECT
   E421   8C 7B 1A      		STY	NMIVECT+1
   E424   A2 15         		LDX	#LOW  IRQ
   E426   A0 F3         		LDY	#HIGH IRQ
   E428   20 46 ED      		JSR     SETIRQVECT      ; set IRQ service routine
   E42B   A2 2A         		LDX	#LOW  NMI	; set standard IRQ and BRK user service routines
   E42D   A0 F3         		LDY	#HIGH NMI       ; to same as NMI. May change in the future
   E42F   8E 78 1A      		STX	BRKUSR
   E432   8C 79 1A                      STY	BRKUSR+1
   E435   8E 7C 1A                      STX	IRQUSR
   E438   8C 7D 1A      		STY	IRQUSR+1
   E43B   60                            RTS
                                        
                        ; ******* OLD ******************************************************************
                        
                        ;INITVECT        LDX	#LOW  NMI	; set NMI service routine
                        ;                LDY	#HIGH NMI
                        ;		 STX	NMIVECT
                        ;		 STY	NMIVECT+1
                        ;		 JSR    SETIRQVECT      ; set IRQ service routine
                        ;		 LDX	#LOW  IRQ
                        ;		 LDY	#HIGH IRQ
                        ;		 JSR	SETIRQVECT
                        ;		 STX	IRQUSR
                        ;		 STY	IRQUSR+1
                        ;		 LDX	#LOW  BREAK	; set BRK service routine
                        ;		 LDY	#HIGH BREAK
                        ;		 STX	BRKUSR
                        ;                STY	BRKUSR+1
                        ;                RTS
                                        
                        ; ******************************************************************************
                        
   E43C   78            MAINSTART       SEI			; disable Interrupts
   E43D   A2 FF                         LDX     #$FF
   E43F   9A            		TXS			; initialize stack pointer
   E440   D8            		CLD			; set binary mode
                        
   E441   A9 62                         LDA     #LOW _HANDLER_  ; low address to empty event handler (RTS)
   E443   8D 24 1A                      STA     KEY_HANDLER     ; init character input handler low address
   E446   8D 26 1A                      STA     NKEY_HANDLER    ; init no character input handler low address
   E449   A9 F8                         LDA     #HIGH _HANDLER_ ; high address to empty event handler (RTS)
   E44B   8D 25 1A                      STA     KEY_HANDLER+1   ; init character input handler high address
   E44E   8D 27 1A                      STA     NKEY_HANDLER+1  ; init no character input handler high address
                        
   E451   20 1A E4                      JSR     INITVECT
                        
   E454   A2 03         INITRESET       LDX     #LOW  MON_WARM_START
   E456   A0 E0         		LDY     #HIGH MON_WARM_START
   E458   86 01                         STX     RETURN_VECT     ; set entry point for monitor warm start
   E45A   84 02                         STY     RETURN_VECT+1
                        
   E45C   A9 80         		LDA     #$80
   E45E   20 4D E1      		JSR  	DELAY		; wait for ~128ms after reset
   E461   20 67 EC      		JSR	INITIO		; find and initialize IO cards
   E464   20 4D E1      VTDETECT	JSR  	DELAY		; wait for ~128ms after reset
   E467   8D 01 16      		STA  	STAT_REG   	; reset ACIA
                        
                        ; ******************************************************************************
                        ; Set Fixed Baud Rate Patch
                        ; ******************************************************************************
                        
   E46A   A9 3E         		LDA	#$3E
   E46C   8D 83 1A      		STA	PBDD
   E46F   A9 06         		LDA	#$06		; set keyboard decoder Q3 to low
   E471   8D 82 1A      		STA	PBD		; write value to RIOT port B
   E474   AD F9 FF      		LDA	$FFF9		; load standard baud rate value (19200 8 N 1)
   E477   85 E0         		STA	BAUDRATE	; and store it in detected baud rate variable
   E479   A9 0B         		LDA  	#$0B       	; set ACIA to
   E47B   8D 02 16               	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
   E47E   AD 82 1A      		LDA	PBD		; read RIOT port B
   E481   A2 0F         		LDX	#$0F		; set all keyboard decoder outputs to high
   E483   8E 82 1A      		STX	PBD		; write value to RIOT port B
   E486   6A            		ROR	A		; rotate bit 0 into Carry
   E487   90 05         		BCC	INIT		; if Carry = 0 then skip autodetection
                        
                        ; ******************************************************************************
                        
   E489   A9 00         		LDA	#CMD_INIT
   E48B   20 B7 E0      		JSR	CMDPRINT	; try to detect connected terminal
                        
                        ; **** Main Initialization Routine *********************************************
                        
                        ; ******************************************************************************
                        
   E48E   20 67 E1      INIT            JSR     BEEP		; give some feedback
   E491   A5 E0         		LDA  	BAUDRATE   	; load selected baud rate
   E493   8D 03 16      		STA  	CTRL_REG	; set detected baud rate
   E496   D0 1A         		BNE     INIT_END	; terminal detected or fixed baud rate?
   E498   AD F9 FF      		LDA	$FFF9		; no, load standard baud rate value
   E49B   8D 03 16      		STA  	CTRL_REG	; set baud rate
   E49E   A5 03         		LDA     DEVID
   E4A0   C9 10         		CMP     #TTY1_ID        ; is TTY still the standard output device?
   E4A2   D0 03         		BNE     SET_CRTDEV      ; no, CRT controller is installed. Continue initialization
   E4A4   4C 52 E7      		JMP  	JCRESET		; TTY ist still sdtoutdev, but not connected. Jump to junior monitor
                        
   E4A7   8D 75 1A      SET_CRTDEV      STA     STDOUTDEV       ; make CRT controller the standard output device
   E4AA   20 18 E0                      JSR     SET_STDOUTID
   E4AD   A9 00                         LDA	#CMD_INIT
   E4AF   20 B7 E0      		JSR	CMDPRINT	; initialize standard output device
                        
   E4B2   58            INIT_END        CLI			; enable interrupts
                        
                        ; **** Main Program Loop *******************************************************
                        
                        ; ******************************************************************************
                        
   E4B3   20 4D E0      MAIN		JSR	CGET		; clear input buffer
   E4B6   20 3D E5      		JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
   E4B9   A9 1F         		LDA  	#$1F
   E4BB   20 DE E0      		JSR  	TAB		; send some space chars to center title
   E4BE   A0 14                 	LDY  	#TITLE-STRINGP 	; load title string
   E4C0   20 85 E0      		JSR  	WRSTR		; and write it
   E4C3   20 52 E5      		JSR     WRITE_IO_INFO
                        
   E4C6   A5 15         CHK_IO_CARD     LDA	IOBASEH		; language card available?
   E4C8   F0 70         		BEQ	SHOWMON		; no, just start monitor
   E4CA   A0 57         		LDY	#IOCARD-STRINGP ; load detect message
   E4CC   20 85 E0      		JSR	WRSTR		; and write it
   E4CF   A5 15         		LDA	IOBASEH
   E4D1   20 91 E0      		JSR	HEXOUT
   E4D4   A9 00         		LDA	#$00
   E4D6   20 91 E0      		JSR	HEXOUT
   E4D9   AD 74 1A      		LDA	STDINDEV
   E4DC   C9 13         		CMP	#KEYBD1_ID	; is ASCII keyboard the standard input device?
   E4DE   D0 08         		BNE	SHOW_CLOCK 	; no, show clock
   E4E0   A0 6E         		LDY	#KBDSTR-STRINGP	; yes, load detect message
   E4E2   20 85 E0      		JSR	WRSTR		; and write it
   E4E5   20 23 F4      		JSR	SETPPORTIN
   E4E8   20 31 EB      SHOW_CLOCK	JSR	CLOCKSTART	; call clock
                        
   E4EB   20 CB F6                      JSR     SYS_BOOT        ; try to boot from storage device
   E4EE   90 03                         BCC     NO_BOOT_DEV     ; no boot device found, show menu
   E4F0   4C 00 06                      JMP     BLOCK_BUF       ; jump to boot code
   E4F3   A9 00         NO_BOOT_DEV     LDA	#$00
   E4F5   A0 1B                         LDY	#ACR		; select auxilary control register
   E4F7   91 14         		STA	(IOBASE),Y	; disable shift operation
   E4F9   20 40 E5                      JSR     LOADSTRING
   E4FC   A0 89         		LDY	#SPACE-STRINGP
   E4FE   20 85 E0      		JSR	WRSTR		; write spacer lines
   E501   A9 1E         		LDA	#$1E		; send some space chars to center menu
   E503   20 DE E0      		JSR  	TAB
   E506   A0 8E         		LDY	#MENU-STRINGP   ; load menu string
   E508   20 85 E0      		JSR	WRSTR		; and write it
   E50B   A9 F1         		LDA	#LOW LANGNAME	; load language name
   E50D   85 EA         		STA	PSTRL
   E50F   A9 DF         		LDA	#HIGH LANGNAME
   E511   85 EB         		STA	PSTRH
   E513   20 83 E0      		JSR	STROUT		; and write it
   E516   A9 20         		LDA	#SPC
   E518   20 52 E0      		JSR	COUT
   E51B   A9 3F         		LDA	#'?'
   E51D   20 52 E0      		JSR	COUT
   E520   20 47 E0      MLOOP		JSR  	CIN		; main menu loop
   E523   29 DF                 	AND  	#$DF		; convert the input to uppercase char
   E525   C9 4D                 	CMP  	#'M'		; (M)onitor choosen?
   E527   D0 03         		BNE	MNEXT1
   E529   4C 30 E6      STARTMON	JMP  	MONITOR		; yes, start monitor
   E52C   CD F0 DF      MNEXT1		CMP	LANGKEY		; compare with language key char
   E52F   D0 06         		BNE	MNEXT
   E531   20 B5 E0      		JSR  	CLRSCRN    	; clear screen
   E534   4C 00 B0      		JMP	$B000		; jump to language start
   E537   4C 20 E5      MNEXT		JMP  	MLOOP		; no valid input choosen, try again
   E53A   4C 38 E6      SHOWMON		JMP	MONRESET
                        
                        ; Load String Pointer **********************************************************
                        
   E53D   20 B5 E0      CLRLOADSTR      JSR     CLRSCRN
   E540   A9 6F         LOADSTRING	LDA  	#LOW STRINGP 	; load string pointer 1
   E542   85 EA         		STA  	PSTRL
   E544   A9 E7         		LDA  	#HIGH STRINGP
   E546   85 EB         		STA  	PSTRH
   E548   60            		RTS
   E549   A9 5F         LOADSTRING2	LDA  	#LOW STRINGP2 	; load string pointer 2
   E54B   85 EA         		STA  	PSTRL
   E54D   A9 E8         		LDA  	#HIGH STRINGP2
   E54F   85 EB         		STA  	PSTRH
   E551   60            		RTS
                        
   E552   A9 10         WRITE_IO_INFO   LDA     #$10
   E554   8D 00 1A      		STA     IO_INFO
   E557   A5 17         CHK_IO_0	LDA     FGCBASEH        ; controller card 0 available?
   E559   F0 06         		BEQ     CHK_IO_1        ; no, check next card
   E55B   8D 01 1A      		STA     IO_INFO+1
   E55E   20 6C E5      		JSR     CALL_INFO
   E561   A5 19         CHK_IO_1        LDA     CARD3BASEH      ; controller card 1 available?
   E563   F0 06                         BEQ     IO_INFO_END     ; no, exit
   E565   8D 01 1A                      STA     IO_INFO+1
   E568   20 6C E5      		JSR     CALL_INFO
   E56B   60            IO_INFO_END	RTS
                        
   E56C   6C 00 1A      CALL_INFO       JMP     (IO_INFO)
                        
                        ; ******************************************************************************
                        ; MONITOR COMMAND EXECUTOR ROUTINES
                        ; ******************************************************************************
                        
                        ; print command ****************************************************************
                        
   E56F   84 FD         PRINTOUT	STY	YSAV		; save y register
   E571   AD 76 1A      		LDA	STDPRINTDEV	; get standard printer
   E574   20 18 E0      		JSR	SET_STDOUTID    ; and make it the current output device
   E577   A4 FD         		LDY	YSAV		; restore y register
   E579   C8            		INY
   E57A   B9 00 14      		LDA  	STRBUF,Y   	; get next input char
   E57D   29 DF         		AND  	#$DF		; uppercase chars only
   E57F   C9 44         		CMP  	#'D'		; print mem dump?
   E581   F0 06         		BEQ	PRINTDUMP
   E583   20 A9 E8      		JSR	DISASSEM
   E586   4C 91 E5      		JMP	ENDINP
   E589   20 C4 E6      PRINTDUMP	JSR	MEMDUMP		; print memory dump
   E58C   90 03         		BCC	ENDINP 		; normal termination?
   E58E   20 67 E1      		JSR	BEEP		; no, ESC pressed. Beep
   E591   20 5A E0      ENDINP		JSR	CROUT		; send CR/LF to print last line
   E594   AD 75 1A      		LDA	STDOUTDEV	; get standard output device
   E597   20 18 E0      		JSR	SET_STDOUTID    ; and make it the current output device
   E59A   4C 3B E6      		JMP	MONINP		; get next command line
                        
                        ; XMODEM load/save command *****************************************************
                        
   E59D   CA            XMODEM		DEX			; check read/write mode
   E59E   F0 09         		BEQ	XMODEML		; read mode?
   E5A0   A5 FF         		LDA	MODE		; no, test if valid address mode
   E5A2   F0 6A         		BEQ	NOTVALID	; not valid, get next input
   E5A4   20 03 F1      		JSR	XModemSnd	; call xmodem send
   E5A7   F0 03         		BEQ	XMODEME
   E5A9   20 12 F0      XMODEML		JSR	XModemRcv	; yes, call xmodem receive
   E5AC   4C 3B E6      XMODEME		JMP	MONINP		; get next command line
                        
                        ; parallel load/save command ***************************************************
                        
   E5AF   CA            PARALLEL	DEX			; check read/write mode
   E5B0   F0 0A         		BEQ	PARALLELL	; read mode?
   E5B2   A5 FF         		LDA	MODE		; no, test if valid address mode
   E5B4   F0 58         		BEQ	NOTVALID	; not valid, get next input
   E5B6   20 03 20      		JSR	PPORTSAVE	; call save pport ### not implemented yet
   E5B9   4C 3B E6      		JMP	MONINP
   E5BC   20 00 20      PARALLELL	JSR	PPORTLOAD	; call load pport ### not implemented yet
   E5BF   4C 3B E6      		JMP	MONINP		; get next command line
                        
                        ; tape load/save command *******************************************************
                        
   E5C2   C8            TAPE		INY
   E5C3   CA            		DEX			; check read/write mode
   E5C4   F0 08         		BEQ	TAPEL		; read mode?
   E5C6   A5 FF         		LDA	MODE		; no, test if valid address mode
   E5C8   F0 44         		BEQ	NOTVALID	; not valid, get next input
   E5CA   A9 21         		LDA	#CMD_SAVE	; set save to tape command
   E5CC   D0 02         		BNE	OPENTAPE
   E5CE   A9 20         TAPEL		LDA	#CMD_LOAD	; set load from tape command
   E5D0   48            OPENTAPE	PHA			; save command to stack
   E5D1   A9 21         		LDA	#TAPE1_ID	; open tape1 device
   E5D3   84 FD         		STY	YSAV		; save y register
   E5D5   20 D1 F7      		JSR	DEV_OPEN	; open tape device
   E5D8   A4 FD         		LDY	YSAV		; restore y register
   E5DA   20 19 E1      		JSR	STRINPUT	; check for filename
   E5DD   68            		PLA			; restore command
   E5DE   20 BA E0      		JSR	CMDDEV		; and send it to opened device
   E5E1   4C 3B E6      		JMP	MONINP		; get next command line
                        
                        ; load/save command ************************************************************
                        
   E5E4   A5 FF         LOADSAVE	LDA	MODE		; check address mode
   E5E6   0A            		ASL	A
   E5E7   30 06         		BMI	CHKNEXTCMD	; mode = $C0 (block mode)?
   E5E9   A9 FF         		LDA	#$FF		; no, set end address to $ffff
   E5EB   85 F8         		STA	NUML
   E5ED   85 F9         		STA	NUMH
   E5EF   C8            CHKNEXTCMD	INY
   E5F0   B9 00 14      		LDA  	STRBUF,Y   	; get next input char
   E5F3   29 DF         		AND  	#$DF		; uppercase chars only
   E5F5   C9 4D         		CMP  	#'M'		; load/save via xmodem
   E5F7   F0 A4         		BEQ  	XMODEM
   E5F9   C9 50         		CMP  	#'P'		; load/save via parallel port
   E5FB   F0 B2         		BEQ  	PARALLEL
   E5FD   C9 54         		CMP  	#'T'		; load/save via tape
   E5FF   F0 C1         		BEQ  	TAPE
   E601   C9 30         		CMP	#'0'
   E603   B0 09         		BCS	NOTVALID
   E605   CA            		DEX			; check load/save mode
   E606   D0 06         		BNE	NOTVALID	; if save mode, just get next input char
   E608   20 A9 E8      		JSR	DISASSEM	; last command was L, so call disassembler
   E60B   4C 3B E6      		JMP	MONINP		; we are finnished, get next input line
   E60E   A9 00         NOTVALID	LDA	#$00		; no valid command, so restore registers
   E610   AA            		TAX
   E611   4C 9E E6      		JMP  	SETMODE2   	; and get next input char
                        
                        ; save command *****************************************************************
                        
   E614   E8            SAVE		INX
                        
                        ; load command *****************************************************************
                        
   E615   E8            LOAD		INX
   E616   4C E4 E5      		JMP	LOADSAVE
                        
                        ; print command ****************************************************************
                        
   E619   4C 6F E5      PRINT		JMP	PRINTOUT
                        
                        ; call a program ***************************************************************
                        
   E61C   20 33 E7      RUN		JSR	PRADDRESS
   E61F   A9 52         		LDA	#'R'		; print R to signal run mode
   E621   20 52 E0      		JSR	COUT
   E624   20 5A E0      		JSR	CROUT
   E627   20 2D E6      		JSR     EXECPROG
   E62A   4C 3B E6      		JMP  	MONINP		; jump back from program call
   E62D   6C FA 00      EXECPROG	JMP  	(ADRL)     	; jump to program address; execute program
                        
                        ; **** Start Of Hex Monitor ****************************************************
                        
                        ; ******************************************************************************
                        
   E630   20 3D E5      MONITOR 	JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
   E633   A0 9A         		LDY  	#MONSTR-STRINGP
   E635   20 85 E0              	JSR  	WRSTR		; show monitor title
   E638   20 23 F4      MONRESET	JSR	SETPPORTIN	; initialize RIOT
   E63B   20 5A E0      MONINP		JSR  	CROUT
   E63E   A9 2A         		LDA  	#PROMPT
   E640   20 52 E0      		JSR  	COUT		; show monitor prompt
   E643   20 62 E0      		JSR  	STRIN      	; read input string
   E646   A0 00         		LDY  	#$00       	; reset string index
   E648   98            		TYA			; mode = 0 (none)
                        
   E649   AA            MONINIT		TAX
   E64A   85 FF         SETADRMODE	STA  	MODE
   E64C   C8            SKIPCMDCHR      INY			; increment string index
   E64D   B9 00 14      NEXTCMDCHR	LDA  	STRBUF,Y   	; get next input char
   E650   C9 0D         		CMP  	#CR
   E652   F0 52         		BEQ  	ENDCMD 		; end of input line, return to reader routine
   E654   C9 20         		CMP  	#' '
   E656   F0 F4         		BEQ  	SKIPCMDCHR 	; ignore spaces
   E658   C9 2E         		CMP  	#'.'
   E65A   F0 46         		BEQ  	SETBLKMODE 	; block mode
   E65C   C9 3A         		CMP	#':'
   E65E   F0 EA         		BEQ	SETADRMODE
   E660   29 DF         		AND  	#$DF		; uppercase chars only
   E662   C9 4C         		CMP  	#'L'		; LOAD/LIST command
   E664   F0 AF         		BEQ	LOAD 		; load or list data
   E666   C9 53         		CMP  	#'S'		; SAVE command
   E668   F0 AA         		BEQ	SAVE		; save data
   E66A   C9 50         		CMP	#'P'		; PRINT command
   E66C   F0 AB         		BEQ	PRINT		; print data
   E66E   C9 47         		CMP  	#'G'		; GO command
   E670   F0 AA         		BEQ  	RUN		; call program
   E672   C9 4D         		CMP  	#'M'		; JUNIOR MONITOR command
   E674   D0 03         		BNE  	NEXTCMD
   E676   4C 52 E7      		JMP	JCRESET		; execute original junior computer monitor
   E679   C9 51         NEXTCMD		CMP  	#'Q'		; QUIT command
   E67B   F0 30         		BEQ  	MONEND		; exit monitor program
   E67D   A5 FF         		LDA	MODE		; test if list command pending
   E67F   30 3C         		BMI	DUMP		; if mode = $80, dump last line
   E681   84 FD         		STY  	YSAV		; save Y
   E683   20 EA E0      		JSR  	HEXINPUT   	; read hex number
   E686   C4 FD         	 	CPY  	YSAV		; min 1 hex digit entered?
   E688   F0 C2         		BEQ  	SKIPCMDCHR     	; no, read next command
   E68A   A5 FF         		LDA  	MODE
   E68C   D0 0A         		BNE	SETMODE
   E68E   A5 F8         STOREADR	LDA  	NUML       	; yes, copy input value to last address
   E690   85 FA                         STA  	ADRL
   E692   A5 F9                         LDA  	NUMH
   E694   85 FB                         STA  	ADRH
   E696   A9 00         		LDA	#$00		; line list mode
   E698   C9 3A         SETMODE		CMP	#':'		; is it store mode?
   E69A   F0 14         		BEQ	STOREDATA	; yes, store data
   E69C   09 80         		ORA	#$80
   E69E   85 FF         SETMODE2	STA	MODE
   E6A0   D0 AB         		BNE	NEXTCMDCHR	; branch always
   E6A2   A9 40         SETBLKMODE	LDA	#$40		; set block list mode
   E6A4   D0 A4         		BNE	SETADRMODE
   E6A6   A5 FF         ENDCMD		LDA	MODE		; test if list command pending
   E6A8   30 13         		BMI	DUMP		; yes, dump last line
   E6AA   4C 3B E6      CMDEND		JMP	MONINP		; read next command line
   E6AD   6C 01 00      MONEND		JMP     (RETURN_VECT)   ; return to monitor caller
                        
                        ; store data *******************************************************************
                        
   E6B0   A5 F8         STOREDATA	LDA  	NUML       	; load lower byte of number
   E6B2   81 FA                         STA  	(ADRL,X)   	; store current store address (X=0)
   E6B4   E6 FA                         INC  	ADRL       	; increment lower store index.
   E6B6   D0 02                         BNE  	NEXTITEM    	; no overflow
   E6B8   E6 FB                         INC  	ADRH       	; add carry to upper store index
   E6BA   4C 4D E6      NEXTITEM        JMP  	NEXTCMDCHR    	; get next command string
                        
                        ; call memory dump *************************************************************
                        
   E6BD   20 C4 E6      DUMP		JSR	MEMDUMP
   E6C0   90 8B         		BCC	NEXTCMDCHR   	; get next input
   E6C2   B0 E6         		BCS	CMDEND		; yes, stop printing memory dump
                        
                        ; print memory dump ************************************************************
                        
   E6C4   A2 00         MEMDUMP		LDX	#$00
   E6C6   86 FE         		STX  	PDBCNT		; printed data byte count = 0
   E6C8   20 5C E1      		JSR	CHKESC		; ESC pressed?
   E6CB   90 01         		BCC	PRADR		; no, go on dumping
   E6CD   60            		RTS			; yes, exit leaving carry flag set
   E6CE   20 33 E7      PRADR		JSR	PRADDRESS	; print current address
                        
                        ; print current data byte ******************************************************
                        
   E6D1   20 5E E0      PRDATA		JSR  	SPCOUT		; print space
   E6D4   A1 FA                         LDA  	(ADRL,X)   	; get data from address (X=0)
   E6D6   20 91 E0                      JSR  	HEXOUT     	; print data in hex format
   E6D9   E6 FE         		INC  	PDBCNT     	; increment data counter
                        
                        ; examine next address *********************************************************
                        
   E6DB   20 49 E7      ADRNEXT		JSR	CMPADDR		; see if there's more to print
   E6DE   B0 18                         BCS  	FINISHED?  	; no more data to output
                        
   E6E0   20 7C E9      		JSR	INCADR          ; increment list index
   E6E3   A5 FE         DIVCHK          LDA  	PDBCNT
   E6E5   C9 08         		CMP  	#$08
   E6E7   D0 03         		BNE  	MOD16CHK	; do we need a divider?
   E6E9   20 5E E0      		JSR  	SPCOUT		; yes, print single SPC as block divider
   E6EC   A5 FA         MOD16CHK	LDA  	ADRL       	; if address MOD 16 = 0 start new line
   E6EE   29 0F                         AND  	#$0F
   E6F0   D0 DF         		BNE  	PRDATA
   E6F2   20 04 E7      		JSR  	PRASCII
   E6F5   4C C4 E6      		JMP  	MEMDUMP		; print next line
                        
                        ; check if line print completed ************************************************
                        
   E6F8   A5 FF         FINISHED?	LDA  	MODE		; examine last mode
   E6FA   86 FF         		STX  	MODE       	; set mode 0
   E6FC   0A            		ASL	A		; mode = $D0?
   E6FD   10 03         		BPL  	ENDDUMP		; no, get next input
   E6FF   20 04 E7      		JSR  	PRASCII		; yes, we are not finished, print ASCII output for last address
   E702   18            ENDDUMP		CLC			; normal exit, so clear carry flag
   E703   60            		RTS
                        
                        ; print a column with ASCII representation of data *****************************
                        
   E704   84 FD         PRASCII         STY  	YSAV       	; store Y
   E706   38            		SEC			; no carry to subtract
   E707   A9 34         		LDA  	#52		; max tabs
   E709   E5 FE         		SBC  	PDBCNT		; calc tab count to print ASCII column
   E70B   E5 FE         		SBC  	PDBCNT		; tab = 52-3*printed_data_bytes_count
   E70D   E5 FE         		SBC  	PDBCNT
   E70F   A4 FE         		LDY  	PDBCNT
   E711   C0 09         		CPY  	#9		; more than 8 bytes viewed?
   E713   B0 02         		BCS  	NOADJUST	; no
   E715   69 01         		ADC  	#1		; yes, adjust by one char for block divider
   E717   20 DE E0      NOADJUST	JSR  	TAB		; print tab spaces
                        
   E71A   A0 00         		LDY  	#$00
   E71C   B1 E6         NEXTASC		LDA  	(ASCL),Y   	; get data from address
   E71E   C9 7F         		CMP	#$7F
   E720   B0 04         		BCS  	NOASC      	; char >= ASCII 127? yes, print '.'
   E722   C9 20         		CMP  	#' '
   E724   B0 02         		BCS  	ASCOUT		; printable character?
   E726   A9 2E         NOASC		LDA  	#'.'       	; no, print '.'
   E728   20 52 E0      ASCOUT		JSR  	COUT
   E72B   C8            		INY
   E72C   C4 FE         		CPY  	PDBCNT
   E72E   D0 EC         		BNE  	NEXTASC
   E730   A4 FD         		LDY  	YSAV       	; restore Y
   E732   60            		RTS
                        
                        ; Prompt new line with current address *****************************************
                        
                        ;*******************************************************************************
                        
   E733   20 5A E0      PRADDRESS	JSR  	CROUT
   E736   A5 FB         		LDA  	ADRH
   E738   85 E7                         STA  	ASCH		; store current print address high-order byte
   E73A   20 91 E0      		JSR  	HEXOUT		; print high-order byte of address
   E73D   A5 FA                         LDA  	ADRL
   E73F   85 E6         		STA  	ASCL		; store current print address low-order byte
   E741   20 91 E0                      JSR  	HEXOUT		; print low-order byte of address
   E744   A9 2D         		LDA  	#ADIV      	; print '-'
   E746   4C 52 E0                      JMP  	COUT
                        
                        ; Compare if start address ADR is greater end address NUM **********************
                        
                        ;*******************************************************************************
                        
   E749   A5 FA         CMPADDR		LDA  	ADRL       	; see if there's more to print
   E74B   C5 F8                         CMP  	NUML
   E74D   A5 FB                         LDA  	ADRH
   E74F   E5 F9                         SBC  	NUMH
   E751   60            		RTS
                        
                        ; Jump to original Junior Computer reset vector ********************************
                        
                        ;*******************************************************************************
                        
   E752   A9 06         JCRESET		LDA	#$06		; set PB5 = L (WRITE)
   E754   8D 82 1A      		STA	PBD
   E757   78            		SEI
   E758   20 1A E4      		JSR     INITVECT
   E75B   20 C9 EF                      JSR     TAPEIRQ_OFF
   E75E   58            		CLI
   E75F   4C 1D 1C      		JMP	RESET		; jump to Junior Computer reset routine
                        
                        ; ******************************************************************************
                        ; String Data Section
                        ; ******************************************************************************
                        
   E762   65 22 65 22   MAGIC0		DB	$65,$22,$65,$22                 ; Magic number of IO-Card
   E766   18 90 00 90   MAGIC1          DB      $18,$90,$00,$90                 ; clc bcc 00 bcc
                        
   E76A   50 53 41 59   PSSTR		TEXT	"PSAYX"				; processor status string
   E76E   58            
                        
   E76F                 STRINGP							; *** string base pointer ***
                        
   E76F   32 4A 1B 5B   ESCCLS  	DB     	$32,$4A,$1B,$5B                 ; VT100 clear screen sequence
   E773   48 00         ESCHOME        	DB     	$48,$00                 	; VT100 cursor home sequence
   E775   32 4B 00      ESCCLL        	DB     	$32,$4B,$00         		; VT100 clear line sequence
   E778   30 63 00      ESCGID		DB     	$30,$63,$00	        	; VT100 get ID sequence
   E77B   6D 00         ESCNORM		DB     	$6D,$00	        		; VT100 set normal text mode
   E77D   37 6D 00      ESCINV		DB     	$37,$6D,$00	        	; VT100 set inverse text mode
   E780   35 6D 00      ESCBLNK		DB     	$35,$6D,$00	        	; VT100 set blinking text mode
                        
   E783   4A 75 6E 69   TITLE		TEXT   	"Junior Computer ]["
   E787   6F 72 20 43   
   E78B   6F 6D 70 75   
   E78F   74 65 72 20   
   E793   5D 5B         
   E795   0D 0D 0D              	DB     	CR,CR,CR
   E798   20 42 49 4F   		TEXT   	" BIOS Version "
   E79C   53 20 56 65   
   E7A0   72 73 69 6F   
   E7A4   6E 20         
   E7A6   31 2E 31 2E           	DB     	VERMAIN,$2E,VERPSUB,$2E,VERSSUB,CR
   E7AA   37 0D         
   E7AC   20 32 30 32           	TEXT   	" 2020/24 by Joerg Walke"
   E7B0   30 2F 32 34   
   E7B4   20 62 79 20   
   E7B8   4A 6F 65 72   
   E7BC   67 20 57 61   
   E7C0   6C 6B 65      
   E7C3   0D 0D 00      		DB     	CR,CR,$00
   E7C6   20 49 4F 2F   IOCARD		TEXT	" IO/Language-Card at $"
   E7CA   4C 61 6E 67   
   E7CE   75 61 67 65   
   E7D2   2D 43 61 72   
   E7D6   64 20 61 74   
   E7DA   20 24         
   E7DC   00            		DB	$00
   E7DD   0D            KBDSTR		DB	CR
   E7DE   20 41 53 43   		TEXT	" ASCII Keyboard connected"
   E7E2   49 49 20 4B   
   E7E6   65 79 62 6F   
   E7EA   61 72 64 20   
   E7EE   63 6F 6E 6E   
   E7F2   65 63 74 65   
   E7F6   64            
   E7F7   00            		DB	$00
   E7F8   0D 0D 0D 0D   SPACE    	DB     	CR,CR,CR,CR,$00
   E7FC   00            
   E7FD   28 4D 29 6F   MENU		TEXT   	"(M)onitor  "
   E801   6E 69 74 6F   
   E805   72 20 20      
   E808   00                    	DB     	$00
   E809   0D            MONSTR		DB	CR
   E80A   48 65 78 20   		TEXT   	"Hex Monitor"
   E80E   4D 6F 6E 69   
   E812   74 6F 72      
   E815   0D 00         		DB     	CR,$00
                        
   E817   0D 0D         DT_NOT_SET	DB	13,13
   E819   20 44 61 74   		TEXT	" Date/Time not set"
   E81D   65 2F 54 69   
   E821   6D 65 20 6E   
   E825   6F 74 20 73   
   E829   65 74         
   E82B   0D 00         		DB	13,0
   E82D   0D            DATEINPUT	DB	13
   E82E   20 44 61 74   		TEXT	" Date: "
   E832   65 3A 20      
   E835   44 44         		TEXT	"DD"
   E837   2E            		DB	DATEDIV
   E838   4D 4D         		TEXT	"MM"
   E83A   2E            		DB	DATEDIV
   E83B   59 59         		TEXT	"YY"
   E83D   08 08 08 08   		DB	8,8,8,8,8,8,8,8,0
   E841   08 08 08 08   
   E845   00            
   E846   0D            TIMEINPUT	DB	13
   E847   20 54 69 6D   		TEXT	" Time: "
   E84B   65 3A 20      
   E84E   48 48         		TEXT	"HH"
   E850   3A            		DB	TIMEDIV
   E851   4D 4D         		TEXT	"MM"
   E853   3A            		DB	TIMEDIV
   E854   53 53         		TEXT	"SS"
   E856   08 08 08 08   		DB	8,8,8,8,8,8,8,8,0
   E85A   08 08 08 08   
   E85E   00            
                        
   E85F                 STRINGP2
                        
   E85F   4D 4F 4E      DAYS		TEXT	"MON"
   E862   00            		DB	0
   E863   54 55 45      		TEXT	"TUE"
   E866   00            		DB	0
   E867   57 45 44      		TEXT	"WED"
   E86A   00            		DB	0
   E86B   54 48 55      		TEXT	"THU"
   E86E   00            		DB	0
   E86F   46 52 49      		TEXT	"FRI"
   E872   00            		DB	0
   E873   53 41 54      		TEXT	"SAT"
   E876   00            		DB	0
   E877   53 55 4E      		TEXT	"SUN"
   E87A   00            		DB	0
                        
   E87B   4A 43 4F 53   OSID            TEXT    "JCOS"
   E87F   0D            BOOTDEV         DB      CR
   E880   20 42 6F 6F                   TEXT    " Booting from "
   E884   74 69 6E 67   
   E888   20 66 72 6F   
   E88C   6D 20         
   E88E   00                            DB      0
   E88F   0D            NOBOOTDEV       DB      CR
   E890   20 4E 6F 20                   TEXT    " No Boot Disk found"
   E894   42 6F 6F 74   
   E898   20 44 69 73   
   E89C   6B 20 66 6F   
   E8A0   75 6E 64      
   E8A3   00                            DB      0
   E8A4   53 44 43 31   SDCDEV          TEXT    "SDC1"
   E8A8   00                            DB      0
                        
                        ; ******************************************************************************
                        ; START OF DISASSEMBLER
                        ; ******************************************************************************
                        
   E8A9   A5 FF         DISASSEM	LDA	MODE
   E8AB   0A            		ASL	A
   E8AC   10 0E         		BPL	SHOW1PAGE	; mode <> $C0 (block mode)?
   E8AE   20 5C E1      NEXTLINE1	JSR     CHKESC          ; ESC pressed?
   E8B1   B0 14         		BCS	ENDDISASSEM	; yes, quit disassembling
   E8B3   20 C8 E8      NEXTOP		JSR	LOADOPCODE	; load current opcode
   E8B6   20 49 E7      MORE?		JSR	CMPADDR		; see if there's more to print
   E8B9   90 F3                         BCC  	NEXTLINE1  	; no more data to output
   E8BB   60            		RTS
   E8BC   A9 17         SHOW1PAGE	LDA	#23		; show 23 disassembled lines
   E8BE   85 E1         		STA	LINECNT
   E8C0   20 C8 E8      NEXTLINE2	JSR	LOADOPCODE	; load current opcode
   E8C3   C6 E1         		DEC	LINECNT
   E8C5   D0 F9         		BNE	NEXTLINE2	; more lines to show?
   E8C7   60            ENDDISASSEM	RTS			; no, jump back to monitor
                        
                        ; load next opcode
                        
   E8C8   20 33 E7      LOADOPCODE	JSR	PRADDRESS	; print current address
   E8CB   A0 00         		LDY	#$00
   E8CD   B1 FA         		LDA	(ADRL),Y	; load opcode
   E8CF   A8            		TAY			; store opcode in Y
   E8D0   29 03         		AND	#$03
   E8D2   C9 03         		CMP	#$03		; is it a unused opcode?
   E8D4   D0 05         		BNE	DECODE  	; no, decode it
   E8D6   A0 02         		LDY	#$02		; Y points to unused opcode $02 to print '???'
   E8D8   98            		TYA			; and we also need it in A
   E8D9   D0 09         		BNE	DECODEMNEM	; branch always
                        
                        ; decode opcode index into compressed opcode instruction table
                        
   E8DB   98            DECODE		TYA			; reload opcode into A
   E8DC   4A            		LSR	A		; every fourth column in the opcode table is a (opcode) gap
   E8DD   4A            		LSR	A		; so we have to adjust the index because these columns are
                        					; stripped off in our indirect index table
   E8DE   85 FC         		STA	TEMP		; store number of bytes to subtract
   E8E0   98            		TYA			; reload opcode again
   E8E1   38            		SEC
   E8E2   E5 FC         		SBC	TEMP		; and subtract value in TEMP from the original opcode.
   E8E4   84 E0         DECODEMNEM	STY	OPCODE		; store opcode
   E8E6   A8            		TAY			; Y holds now the actual index to the stripped opcode table
   E8E7   B9 71 EA      		LDA	OPCODES,Y	; load packed mnemonic_index/instr._bytes from opcode table
   E8EA   A8            		TAY			; and save to Y
   E8EB   29 03         		AND	#$03		; the lower two bits are the number of instruction bytes
   E8ED   85 E3         		STA	IBYTES		; store it in IBYTES var
   E8EF   98            		TYA			; reload packed index
   E8F0   4A            		LSR	A		; and strip the lower two bits off
   E8F1   4A            		LSR	A
   E8F2   A8            		TAY			; Y holds now the index to the mnemonics table
   E8F3   B9 38 EA      		LDA   	MNEMONICSH,Y    ; load first packed byte of mnemonic string
   E8F6   85 E7         		STA   	ASCH            ; and store it as left byte of mnemonic
   E8F8   B9 FF E9      		LDA   	MNEMONICSL,Y    ; load second packed byte of mnemonic string
   E8FB   85 E6         		STA   	ASCL            ; and store it as right byte of mnemonic
   E8FD   20 A8 E9      		JSR	SHOWHEX		; first print out all instruction bytes as hex numbers
   E900   A2 03         		LDX   	#$03		; we have to unpack three chars
   E902   A9 00         NEXTMCHR        LDA   	#$00		; clear A
   E904   A0 05         		LDY   	#$05            ; shift 5 bits into A
   E906   06 E6         NEXTSHIFT       ASL   	ASCL           	; MSBit of ASCL in C
   E908   26 E7         		ROL   	ASCH		; C in LSBit of ASCH and MSBit of ASCH in C
   E90A   2A            		ROL   	A		; C in A
   E90B   88            		DEY
   E90C   D0 F8         		BNE   	NEXTSHIFT
   E90E   69 3F         		ADC   	#'?'		; add offset to result, to make it an ASCII char
   E910   20 52 E0      		JSR     COUT		; print one character of mnemonic
   E913   CA            		DEX
   E914   D0 EC         		BNE     NEXTMCHR	; more chars to decode?
   E916   A9 02         		LDA	#$02		; print two space chars
   E918   20 DE E0      		JSR	TAB
                        
                        ; decode address mode and print left part of mode string ('#', '(' or 'A')
                        
   E91B   A2 A0         		LDX     #$A0            ; default address mode is implied
   E91D   A0 FF         		LDY	#$FF
   E91F   C8            NEXTMASK	INY
   E920   C0 0F         		CPY	#$0F		; all masks tested?
   E922   F0 0D         		BEQ	ENDMASK		; yes, finish. Address mode is implied
   E924   B9 C2 E9      		LDA	ADRMODEM,Y	; load mask
   E927   25 E0         		AND	OPCODE		; mask opcode
   E929   D9 D1 E9      		CMP	ADRMODEC,Y	; is it the mask result?
   E92C   D0 F1         		BNE	NEXTMASK	; no, try next mask
   E92E   BE E0 E9      		LDX	ADRMODER,Y	; yes, load the resulting address mode
   E931   86 E2         ENDMASK		STX	ADRMODE		; save address mode
   E933   8A            		TXA			; address mode is in A
   E934   29 0F         		AND	#$0F		; A holds left mode string index
   E936   A8            		TAY
   E937   B9 EF E9      		LDA	ADRMSTRL,Y      ; load left mode string
   E93A   F0 03         		BEQ	PRINTVAL	; is it a NULL char? Then there is nothing to print
   E93C   20 52 E0      		JSR	COUT		; else print character
                        
                        ; print either one or two operand value bytes
                        
   E93F   20 7C E9      PRINTVAL	JSR	INCADR		; increment current address
   E942   A6 E3         		LDX	IBYTES		; load number of instruction bytes
   E944   CA            		DEX			; more than one IBs?
   E945   F0 3B         		BEQ	ENDINC		; no, just finish
   E947   A9 24         		LDA	#'$'		; yes, print operant value
   E949   20 52 E0      		JSR	COUT		; first print out '$' as hex number indicator
   E94C   A0 01         		LDY	#$01
   E94E   CA            		DEX			; more than two IBs?
   E94F   F0 05         		BEQ	HEX1		; no, just print one byte
   E951   B1 FA         		LDA	(ADRL),Y	; load high byte
   E953   20 91 E0      		JSR	HEXOUT		; and print it as hex number
   E956   88            HEX1		DEY
   E957   B1 FA         		LDA	(ADRL),Y	; load low byte
   E959   A6 E2         		LDX	ADRMODE
   E95B   E0 A4         		CPX	#$A4		; is it a branch opcode?
   E95D   F0 24         		BEQ	CALCADR		; yes, calculate branch destination address
   E95F   20 91 E0      		JSR	HEXOUT		; no, print byte as hex number
                        
                        ; print right part of mode string. (',X', ',Y', ',X)', '),Y' or ')' )
                        
   E962   8A            		TXA			; load address mode in A
   E963   4A            		LSR	A		; upper nibble is index to right address mode string
   E964   4A            		LSR	A		; so we have to shift it right by four bits
   E965   4A            		LSR	A
   E966   4A            		LSR	A
   E967   A8            		TAY
   E968   B9 F4 E9      NEXTAMCHR	LDA	ADRMSTRR,Y	; load one char of right mode string
   E96B   F0 06         		BEQ     ENDMODE		; if a NULL char then we are finished
   E96D   20 52 E0      		JSR	COUT		; else print char
   E970   C8            		INY
   E971   D0 F5         		BNE	NEXTAMCHR	; branch always
                        
                        ; finish current instruction
                        
   E973   A5 E3         ENDMODE		LDA	IBYTES		; how many address increments left?
   E975   C9 03         		CMP	#$03
   E977   D0 03         		BNE	INCADR		; just one?
   E979   20 7C E9      		JSR	INCADR		; no, two increments needed
                        
                        ; increment current address
                        
   E97C   E6 FA         INCADR  	INC  	ADRL    	; increment current address
   E97E   D0 02                 	BNE  	ENDINC  	; no carry!
   E980   E6 FB                 	INC  	ADRH
   E982   60            ENDINC		RTS			; end of disassembly
                        
                        ; calculate destination address for branch instructions
                        
   E983   38            CALCADR		SEC
   E984   A8            		TAY			; transfer A to Y for sign test
   E985   10 10         		BPL	ADDOFS		; is the branch offset positiv?
   E987   49 FF         		EOR	#$FF		; no, subtract offset from current address
   E989   85 E8         		STA	STOL
   E98B   A5 FA         		LDA	ADRL
   E98D   E5 E8         		SBC	STOL		; subtract branch offset from LSB current address
   E98F   A8            		TAY			; store low byte of address to Y
   E990   A5 FB         		LDA	ADRH
   E992   E9 00         		SBC	#$00		; substract carry from MSB of address
   E994   4C 9E E9      		JMP	PRINTOFFS
   E997   65 FA         ADDOFS		ADC	ADRL		; add branch offset to LSB of current address
   E999   A8            		TAY			; store low byte of address to Y
   E99A   A5 FB         		LDA	ADRH
   E99C   69 00         		ADC	#$00		; add carry to MSB of address
   E99E   20 91 E0      PRINTOFFS	JSR	HEXOUT		; print high byte of branch address
   E9A1   98            		TYA
   E9A2   20 91 E0      		JSR	HEXOUT		; print low byte of branch address
   E9A5   4C 7C E9      		JMP	INCADR		; and increment current address by one
                        
                        ; show instruction bytes as hex values and trailing variable number of space chars
                        
   E9A8   A0 00         SHOWHEX		LDY	#$00
   E9AA   20 5E E0      NEXTBYTE	JSR	SPCOUT		; print leading space char
   E9AD   B1 FA         		LDA	(ADRL),Y	; load data byte
   E9AF   20 91 E0      		JSR	HEXOUT		; and print it
   E9B2   C8            		INY
   E9B3   C4 E3         		CPY	IBYTES		; all data bytes printed?
   E9B5   D0 F3         		BNE	NEXTBYTE	; no, print next byte
   E9B7   A9 0C         		LDA	#$0C		; tab size is 12
   E9B9   38            		SEC
   E9BA   E9 03         CALCTAB		SBC	#$03		; reduce tab space by 3 for every data byte
   E9BC   88            		DEY
   E9BD   D0 FB         		BNE	CALCTAB		; all data bytes considered?
   E9BF   4C DE E0      		JMP	TAB
                        
                        ; Address Mode Decode Tables ***************************************************
                        
                        ; Mask, Mask Result and Mode tables. If Opcode and Mask = Mask Result then Mode
                        ; each Mode holds two indices (4 bits R | 4 bits L) to the mode string parts
                        
                        ; ******************************************************************************
                        
   E9C2   FF FF FF 1F   ADRMODEM	DB	$FF,$FF,$FF,$1F,$1F,$1F,$1F,$1F,$9F,$9F,$1C,$1C,$DF,$1C,$1C ; mask bits
   E9C6   1F 1F 1F 1F   
   E9CA   9F 9F 1C 1C   
   E9CE   DF 1C 1C      
                        
   E9D1   6C A2 BE 01   ADRMODEC	DB	$6C,$A2,$BE,$01,$09,$10,$11,$19,$0A,$80,$04,$0C,$96,$14,$1C ; mask result bits
   E9D5   09 10 11 19   
   E9D9   0A 80 04 0C   
   E9DD   96 14 1C      
                        
   E9E0   52 A1 80 32   ADRMODER	DB	$52,$A1,$80,$32,$A1,$A4,$72,$80,$A3,$A1,$A0,$A0,$80,$00,$00 ; packed mode bits
   E9E4   A1 A4 72 80   
   E9E8   A3 A1 A0 A0   
   E9EC   80 00 00      
                        
                        ; Address Mode Strings *********************************************************
                        
   E9EF   00 23 28 41   ADRMSTRL	DB	$00,$23,$28,$41,$00
   E9F3   00            
                        		;	 0   #   (   A   0
                        
   E9F4   2C 58 00 2C   ADRMSTRR	DB	$2C,$58,$00,$2C,$58,$29,$00,$29,$2C,$59,$00
   E9F8   58 29 00 29   
   E9FC   2C 59 00      
                        		;	 ,   X   0   ,   X   )   0   )   ,   Y   0
                        
                        ; Mnemonics Table **************************************************************
                        
                        ; three characters packed in two bytes. Each character uses 5 bits, last bit is
                        ; unused
                        
                        ; ******************************************************************************
                        
                        ; low bytes of table
                        
   E9FF   48 CA 1A 08   MNEMONICSL	DB	$48, $CA, $1A, $08, $28, $A4, $AA, $94
   EA03   28 A4 AA 94   
   EA07   CC 5A D8 C8        		DB	$CC, $5A, $D8, $C8, $E8, $48, $4A, $54
   EA0B   E8 48 4A 54   
   EA0F   6E A2 72 74        		DB	$6E, $A2, $72, $74, $88, $B2, $B4, $26
   EA13   88 B2 B4 26   
   EA17   C8 F2 F4 A2        		DB	$C8, $F2, $F4, $A2, $26, $44, $72, $74
   EA1B   26 44 72 74   
   EA1F   26 22 C4 44        		DB	$26, $22, $C4, $44, $62, $44, $62, $1A
   EA23   62 44 62 1A   
   EA27   26 54 68 C8        		DB	$26, $54, $68, $C8, $88, $8A, $94, $44
   EA2B   88 8A 94 44   
   EA2F   72 74 B2 B4        		DB	$72, $74, $B2, $B4, $32, $44, $68, $84, $00
   EA33   32 44 68 84   
   EA37   00            
                        
                        ; high bytes of table
                        
   EA38   11 13 15 19   MNEMONICSH	DB	$11, $13, $15, $19, $19, $19, $1A, $1B
   EA3C   19 19 1A 1B   
   EA40   1B 1C 1C 1D        		DB	$1B, $1C, $1C, $1D, $1D, $23, $23, $23
   EA44   1D 23 23 23   
   EA48   23 23 24 24        		DB	$23, $23, $24, $24, $29, $29, $29, $34
   EA4C   29 29 29 34   
   EA50   53 53 53 5B        		DB	$53, $53, $53, $5B, $5D, $69, $69, $69
   EA54   5D 69 69 69   
   EA58   6D 7C 84 8A        		DB	$6D, $7C, $84, $8A, $8A, $8B, $8B, $9C
   EA5C   8A 8B 8B 9C   
   EA60   9C 9D 9D A0        		DB	$9C, $9D, $9D, $A0, $A1, $A1, $A1, $A5
   EA64   A1 A1 A1 A5   
   EA68   A5 A5 A8 A8        		DB	$A5, $A5, $A8, $A8, $AD, $AE, $AE, $AE, $00
   EA6C   AD AE AE AE   
   EA70   00            
                        
                        ; Compressed Opcode Table ******************************************************
                        
                        ; each byte holds a 6 bit index to the mnemonic table and 2 bits instruction
                        ; byte count
                        ; empty opcode table columns (3,7,B,F) are stripped out
                        
                        ; ******************************************************************************
                        
   EA71   29 8A E1 E1   OPCODES         DB	$29, $8A, $E1, $E1, $8A, $0A, $91, $8A, $09, $E1, $8B, $0B
   EA75   8A 0A 91 8A   
   EA79   09 E1 8B 0B   
   EA7D   26 8A E1 E1        		DB	$26, $8A, $E1, $E1, $8A, $0A, $35, $8B, $E1, $E1, $8B, $0B
   EA81   8A 0A 35 8B   
   EA85   E1 E1 8B 0B   
   EA89   73 06 E1 1A        		DB	$73, $06, $E1, $1A, $06, $9E, $99, $06, $9D, $1B, $07, $9F
   EA8D   06 9E 99 06   
   EA91   9D 1B 07 9F   
   EA95   1E 06 E1 E1        		DB	$1E, $06, $E1, $E1, $06, $9E, $B1, $07, $E1, $E1, $07, $9F
   EA99   06 9E B1 07   
   EA9D   E1 E1 07 9F   
   EAA1   A5 5E E1 E1        		DB	$A5, $5E, $E1, $E1, $5E, $82, $8D, $5E, $81, $6F, $5F, $83
   EAA5   5E 82 8D 5E   
   EAA9   81 6F 5F 83   
   EAAD   2E 5E E1 E1        		DB	$2E, $5E, $E1, $E1, $5E, $82, $3D, $5F, $E1, $E1, $5F, $83
   EAB1   5E 82 3D 5F   
   EAB5   E1 E1 5F 83   
   EAB9   A9 02 E1 E1        		DB	$A9, $02, $E1, $E1, $02, $A2, $95, $02, $A1, $6F, $03, $A3
   EABD   02 A2 95 02   
   EAC1   A1 6F 03 A3   
   EAC5   32 02 E1 E1        		DB	$32, $02, $E1, $E1, $02, $A2, $B9, $03, $E1, $E1, $03, $A3
   EAC9   02 A2 B9 03   
   EACD   E1 E1 03 A3   
   EAD1   E1 BE E1 C6        		DB	$E1, $BE, $E1, $C6, $BE, $C2, $59, $E1, $D5, $C7, $BF, $C3
   EAD5   BE C2 59 E1   
   EAD9   D5 C7 BF C3   
   EADD   0E BE E1 C6        		DB	$0E, $BE, $E1, $C6, $BE, $C2, $DD, $BF, $D9, $E1, $BF, $E1
   EAE1   BE C2 DD BF   
   EAE5   D9 E1 BF E1   
   EAE9   7E 76 7A 7E        		DB	$7E, $76, $7A, $7E, $76, $7A, $CD, $76, $C9, $7F, $77, $7B
   EAED   76 7A CD 76   
   EAF1   C9 7F 77 7B   
   EAF5   12 76 E1 7E        		DB	$12, $76, $E1, $7E, $76, $7A, $41, $77, $D1, $7F, $77, $7B
   EAF9   76 7A 41 77   
   EAFD   D1 7F 77 7B   
   EB01   4E 46 E1 4E        		DB	$4E, $46, $E1, $4E, $46, $52, $69, $46, $55, $4F, $47, $53
   EB05   46 52 69 46   
   EB09   55 4F 47 53   
   EB0D   22 46 E1 E1        		DB	$22, $46, $E1, $E1, $46, $52, $39, $47, $E1, $E1, $47, $53
   EB11   46 52 39 47   
   EB15   E1 E1 47 53   
   EB19   4A AE E1 4A        		DB	$4A, $AE, $E1, $4A, $AE, $62, $65, $AE, $85, $4B, $AF, $63
   EB1D   AE 62 65 AE   
   EB21   85 4B AF 63   
   EB25   16 AE E1 E1        		DB	$16, $AE, $E1, $E1, $AE, $62, $B5, $AF, $E1, $E1, $AF, $63
   EB29   AE 62 B5 AF   
   EB2D   E1 E1 AF 63   
                        
                        ; ******************************************************************************
                        ; START OF HIGH LEVEL REAL TIME CLOCK CODE
                        ; ******************************************************************************
                        
                        ; **** Check If Date/Time Is Set And Show Date/Time ****************************
                        
   EB31   20 40 EB      CLOCKSTART	JSR	CHECKDATETIME
   EB34   20 5A E0      		JSR	CROUT
   EB37   20 5A E0      		JSR	CROUT
   EB3A   20 5E E0      		JSR	SPCOUT
   EB3D   4C F6 EB      		JMP	PRINTDATETIME
                        
                        ; **** Check If Date/Time Is Set ***********************************************
                        
                        ; ******************************************************************************
                        
   EB40   A9 08         CHECKDATETIME	LDA	#$08
   EB42   20 E6 E2      		JSR	READCLOCK
   EB45   C0 65         		CPY	#$65
   EB47   D0 05         		BNE	DATETIMELOST
   EB49   E0 02         		CPX	#$02
   EB4B   D0 01         		BNE	DATETIMELOST
   EB4D   60            		RTS
                        
   EB4E   20 40 E5      DATETIMELOST	JSR	LOADSTRING
   EB51   A0 A8         		LDY	#DT_NOT_SET-STRINGP
   EB53   20 85 E0      		JSR	WRSTR
                        
   EB56   20 83 EB      SETDATETIME	JSR	SETTIME
                        
   EB59   20 40 E5      SETDATE		JSR	LOADSTRING
   EB5C   A9 2E         		LDA	#'.'
   EB5E   85 F2         		STA	DIVCHAR
   EB60   A0 BE         		LDY	#DATEINPUT-STRINGP
   EB62   20 85 E0      		JSR	WRSTR
   EB65   A0 31         		LDY	#$31
   EB67   20 AD EB      		JSR	GETDIGIT
   EB6A   85 F4         		STA	YREG
   EB6C   20 46 EC      		JSR	PRINTDIVCHAR
   EB6F   A0 12         		LDY	#$12
   EB71   20 AD EB      		JSR	GETDIGIT
   EB74   85 F5         		STA	XREG
   EB76   20 46 EC      		JSR	PRINTDIVCHAR
   EB79   A0 99         		LDY	#$99
   EB7B   20 AD EB      		JSR	GETDIGIT
   EB7E   85 F3         		STA	ACC
   EB80   4C B7 E2      		JMP	WRITEDATE2
                        
   EB83   20 40 E5      SETTIME		JSR	LOADSTRING
   EB86   A9 3A         		LDA	#':'
   EB88   85 F2         		STA	DIVCHAR
   EB8A   A0 D7         		LDY	#TIMEINPUT-STRINGP
   EB8C   20 85 E0      		JSR	WRSTR
   EB8F   A0 23         		LDY	#$23
   EB91   20 AD EB      		JSR	GETDIGIT
   EB94   85 F3         		STA	ACC
   EB96   20 46 EC      		JSR	PRINTDIVCHAR
   EB99   A0 59         		LDY	#$59
   EB9B   20 AD EB      		JSR	GETDIGIT
   EB9E   85 F5         		STA	XREG
   EBA0   20 46 EC      		JSR	PRINTDIVCHAR
   EBA3   A0 59         		LDY	#$59
   EBA5   20 AD EB      		JSR	GETDIGIT
   EBA8   85 F4         		STA	YREG
   EBAA   4C 9F E2      		JMP	WRITETIME2
                        
   EBAD   C8            GETDIGIT	INY
   EBAE   84 FD         		STY	YSAV
   EBB0   20 E7 EB      GETDIGIT1	JSR	NUMINPUT
   EBB3   90 FB         		BCC	GETDIGIT1
   EBB5   AA            		TAX
   EBB6   E9 30         		SBC	#48
   EBB8   0A            		ASL	A
   EBB9   0A            		ASL	A
   EBBA   0A            		ASL	A
   EBBB   0A            		ASL	A
   EBBC   C5 FD         		CMP	YSAV
   EBBE   B0 F0         		BCS	GETDIGIT1
   EBC0   85 FC         		STA	TEMP
   EBC2   8A            		TXA
   EBC3   20 52 E0      		JSR	COUT
   EBC6   20 E7 EB      GETDIGIT2	JSR	NUMINPUT
   EBC9   90 FB         		BCC	GETDIGIT2
   EBCB   AA            		TAX
   EBCC   E9 30         		SBC	#48
   EBCE   05 FC         		ORA	TEMP
   EBD0   C5 FD         		CMP	YSAV
   EBD2   B0 F2         		BCS	GETDIGIT2
   EBD4   85 FC         		STA	TEMP
   EBD6   A9 2E         		LDA	#'.'
   EBD8   C5 F2         		CMP	DIVCHAR
   EBDA   D0 04         		BNE	GETDIGITEND
   EBDC   A5 FC         		LDA	TEMP
   EBDE   F0 E6         		BEQ	GETDIGIT2
   EBE0   8A            GETDIGITEND	TXA
   EBE1   20 52 E0      		JSR	COUT
   EBE4   A5 FC         		LDA	TEMP
   EBE6   60            		RTS
                        
                        
   EBE7   20 47 E0      NUMINPUT	JSR	CIN
   EBEA   C9 30         		CMP	#'0'
   EBEC   90 04         		BCC	NOTNUM
   EBEE   C9 3A         		CMP	#':'
   EBF0   90 02         		BCC	ISNUM
   EBF2   18            NOTNUM		CLC
   EBF3   60            		RTS
   EBF4   38            ISNUM		SEC
   EBF5   60            		RTS
                        
                        ; **** Print Date And Time *****************************************************
                        
                        ; ******************************************************************************
                        
   EBF6   20 28 EC      PRINTDATETIME	JSR	PRINTDATE	; print current date	; PRINTFULLDATE
   EBF9   20 5E E0      		JSR	SPCOUT
   EBFC   20 02 EC      		JSR	PRINTTIME	; print current time
   EBFF   4C 5A E0      		JMP	CROUT
                        
                        ; **** Print Time **************************************************************
                        
                        ; ******************************************************************************
                        
   EC02   A9 3A         PRINTTIME	LDA	#':'
   EC04   85 F2         		STA	DIVCHAR
   EC06   20 DE E2      		JSR	READTIME
   EC09   20 43 EC      		JSR	PRINTDIGIT
   EC0C   8A            		TXA
   EC0D   20 43 EC      		JSR	PRINTDIGIT
   EC10   98            		TYA
   EC11   4C 91 E0      		JMP	HEXOUT
                        
                        ; **** Print Date And Day Of Week **********************************************
                        
                        ; ******************************************************************************
                        
   EC14   20 92 E2      PRINTFULLDATE	JSR	READDOW
   EC17   0A            		ASL	A
   EC18   0A            		ASL	A
   EC19   A8            		TAY
   EC1A   A9 5B         		LDA  	#LOW DAYS-4
   EC1C   85 EA         		STA  	PSTRL
   EC1E   A9 E8         		LDA  	#HIGH DAYS-4
   EC20   85 EB         		STA  	PSTRH
   EC22   20 85 E0      		JSR	WRSTR
   EC25   20 5E E0      		JSR	SPCOUT
                        
                        ; **** Print Date **************************************************************
                        
                        ; ******************************************************************************
                        
   EC28   A9 2E         PRINTDATE	LDA	#DATEDIV	; load divider char
   EC2A   85 F2         		STA	DIVCHAR
   EC2C   20 E2 E2      		JSR	READDATE	; read current date
   EC2F   85 FC         		STA	TEMP		; store year value in TEMP
   EC31   98            		TYA
   EC32   20 43 EC      		JSR	PRINTDIGIT	; print day
   EC35   8A            		TXA
   EC36   20 43 EC      		JSR	PRINTDIGIT	; print month
   EC39   A9 20         		LDA	#CENTURY
   EC3B   20 91 E0      		JSR	HEXOUT		; print century
   EC3E   A5 FC         		LDA	TEMP
   EC40   4C 91 E0      		JMP	HEXOUT		; print year
                        
   EC43   20 91 E0      PRINTDIGIT	JSR	HEXOUT		; print digit
   EC46   A5 F2         PRINTDIVCHAR	LDA	DIVCHAR		; print divider char
   EC48   4C 52 E0      		JMP	COUT
                        
                        ; ******************************************************************************
                        ; START OF LOW LEVEL ROUTINES
                        ; ******************************************************************************
                        
                        ; **** Print Processor Status **************************************************
                        
                        ; ******************************************************************************
                        
   EC4B   20 33 E7      PRSTATUS	JSR	PRADDRESS	; print current program counter
   EC4E   A2 04         		LDX	#$04
   EC50   20 5E E0      NXTREG		JSR	SPCOUT		; print space char
   EC53   BD 6A E7      		LDA	PSSTR,X		; load register label
   EC56   20 52 E0      		JSR	COUT		; and print it
   EC59   A9 3D         		LDA	#'='
   EC5B   20 52 E0      		JSR	COUT		; print =
   EC5E   B5 F1         		LDA	PREG,X
   EC60   20 91 E0      		JSR	HEXOUT
   EC63   CA            		DEX
   EC64   10 EA         		BPL	NXTREG
   EC66   60            		RTS
                        
                        ; **** Initialize IO Devices ***************************************************
                        
                        ; ******************************************************************************
                        
   EC67   A9 00         INITIO          LDA     #$00
   EC69   A2 06                         LDX     #$06
   EC6B   95 14         INITIO1         STA     IOBASE,X        ; clear K2,K3 and K4 base address pointers
   EC6D   CA                            DEX
   EC6E   D0 FB                         BNE     INITIO1
                        
   EC70   20 77 F7                      JSR     DEV_INIT        ; initialize driver list
   EC73   A2 88         SET_TTY_DEV     LDX     #LOW  TTY_DEV
   EC75   A0 F9                         LDY     #HIGH TTY_DEV
   EC77   20 82 F7                      JSR     DEV_ADD         ; add terminal driver
   EC7A   8D 74 1A      		STA	STDINDEV        ; and initially set TTY as standard IO
   EC7D   8D 75 1A      		STA	STDOUTDEV
   EC80   85 03         		STA     DEVID
                        
   EC82   A2 A8         SET_XMODEM_DEV  LDX     #LOW  XMODEM_DEV
   EC84   A0 F9                         LDY     #HIGH XMODEM_DEV
   EC86   20 82 F7                      JSR     DEV_ADD         ; add xmodem driver
                        
   EC89   A2 90         SET_PRINTER_DEV LDX     #LOW  PPRINT_DEV
   EC8B   A0 F9                         LDY     #HIGH PPRINT_DEV
   EC8D   20 82 F7                      JSR     DEV_ADD         ; add parallel printer driver
   EC90   8D 76 1A                      STA	STDPRINTDEV     ; and initially set parallel port printer as standard printer
                        
   EC93   20 A6 EC      		JSR     DETECT_IO       ; detect IO cards
                        
                        ; TEMP #### future: Set std beep only if no language card found
                        
   EC96   A9 6A         INIT_BEEP	LDA	#LOW DOBEEP	; load low byte of address of system beep
   EC98   8D 66 1A      		STA	STDBEEP
   EC9B   A9 E1         		LDA	#HIGH DOBEEP	; load high byte of address of system beep
   EC9D   8D 67 1A      		STA	STDBEEP+1
                        
   ECA0   4C AD E1                      JMP     RESET_STDIO     ; reset to standard IO devices
                        
   ECA3   6C FA 00      IO_INITIALIZE   JMP     (ADRL)
                        
                        ; **** Scan Bus And Detect IO Cards ********************************************
                        ;
                        ; ******************************************************************************
                        
   ECA6   A9 FB         DETECT_IO       LDA     #$FB
   ECA8   85 FA                         STA     ADRL            ; set pointer to init routine
   ECAA   A9 07                         LDA     #$07
   ECAC   85 FB                         STA     ADRH
   ECAE   A9 03                         LDA     #$03            ; search on three slot base addresses
   ECB0   85 FE                         STA     PDBCNT
   ECB2   18            DETECT_LOOP     CLC
   ECB3   A5 FB                         LDA     ADRH
   ECB5   AA                            TAX
   ECB6   E8                            INX                     ; X holds slot base address high byte
   ECB7   69 04                         ADC     #$04
   ECB9   85 FB                         STA     ADRH            ; set high byte to init routine
   ECBB   A0 03                         LDY	#$03            ; test byte string in card ROM against magic number
   ECBD   B9 66 E7      COMP_LOOP	LDA	MAGIC1,Y        ; get one byte of magic number
   ECC0   D1 FA         		CMP	(ADRL),Y        ; and compare it with ROM content
   ECC2   D0 06         		BNE	NO_MATCH        ; byte does not match, exit inner detection loop
   ECC4   88            		DEY                     ; byte matched magic number, try next one
   ECC5   10 F6         		BPL	COMP_LOOP       ; more bytes to compare?
   ECC7   20 A3 EC      		JSR     IO_INITIALIZE   ; IO card detected. Call init routine
   ECCA   C6 FE         NO_MATCH        DEC     PDBCNT
   ECCC   D0 E4                         BNE     DETECT_LOOP     ; try next card base address
                                                                ; fall through to IO/Language Card detection
                        
                        ; **** Try To Detect IO/Language Card ******************************************
                        ;
                        ; ******************************************************************************
                        
   ECCE   A9 00         DETECT_IOL_CARD	LDA	#$00
   ECD0   85 14         		STA	IOBASEL		; set low byte of IO base pointer to $00
   ECD2   85 15         		STA	IOBASEH		; set high byte of IO base pointer to $00
   ECD4   AD 20 10      		LDA	K4+$20		; walk through all IO spaces
   ECD7   AD 20 0C      		LDA	K3+$20		; and trigger annunciator address
   ECDA   AD 20 08      		LDA	K2+$20		; to initially switch from ROM to RAM
   ECDD   A0 10         K4?		LDY	#$10
   ECDF   AD 30 10      		LDA	K4+$30		; try switching to ROM at base address $1000.
   ECE2   20 53 F3      		JSR	GETMAGIC	; get magic number?
   ECE5   F0 15         		BEQ	STOREBASE	; yes, store base address.
   ECE7   A0 0C         K3?		LDY	#$0C		; no,
   ECE9   AD 30 0C      		LDA	K3+$30		; try switching to ROM at base address $0C00.
   ECEC   20 53 F3      		JSR	GETMAGIC	; get magic number?
   ECEF   F0 0B         		BEQ	STOREBASE	; yes, store base address.
   ECF1   A0 08         K2?		LDY	#$08		; no,
   ECF3   AD 30 08      		LDA	K2+$30		; try switching to ROM at base address $0800.
   ECF6   20 53 F3      		JSR	GETMAGIC	; get magic number?
   ECF9   F0 01         		BEQ	STOREBASE	; yes, initialize IO card
   ECFB   60            NOCARD          RTS                     ; no card found
                        
   ECFC   84 15         STOREBASE	STY	IOBASEH		; card found, set high byte of base pointer.
                        
                        ; **** Initialize The IO/Language Card *****************************************
                        
                        ; ******************************************************************************
                        
   ECFE   AD 74 1A      INIT_IOCARD     LDA     STDINDEV
   ED01   C9 10                         CMP     #TTY1_ID
   ED03   D0 03                         BNE     INIT_VIA        ; is standard input device still TTY?
   ED05   20 D0 F3                      JSR	DETECT_ASCIIKBD	; yes, check if ASCII keyboard available, else skip it
   ED08   A0 10         INIT_VIA	LDY	#PORTB
   ED0A   A9 4E         		LDA	#%01001110	; SDA=0,/CAS_MOT=1,CAS_SENSE=0,CAS_WR=0,/SPI_LOAD=1,SPI_CS=1,/SND_WE=1,SCL=0
   ED0C   85 E4         		STA	VIA_STATUS	; store current PortB output status
   ED0E   91 14         		STA	(IOBASE),Y	; set SDA as input to pull it high, set SCL as input to pull it high
   ED10   A0 12         		LDY	#DDRB		; initialize data direction of port B
   ED12   A9 5E         		LDA	#%01011110	; SDA,/CAS_MOT,/CAS_SENSE,CAS_WR,/SPI_LOAD,SPI_CS,/SND_WE,SCL
   ED14   91 14         		STA	(IOBASE),Y
   ED16   A0 13         		LDY	#DDRA		; initialize data direction of port A
   ED18   A9 FF         		LDA	#$FF		; all pins of port A are outputs
   ED1A   91 14         		STA	(IOBASE),Y
   ED1C   20 D0 E3      		JSR	SOUND_MUTEALL	; mute sound output
   ED1F   20 39 F4      INIT_SDCARD     JSR     SPI_INIT        ; initialize SPI
   ED22   A2 B8                         LDX     #LOW  SDC_DEV
   ED24   A0 F9                         LDY     #HIGH SDC_DEV
   ED26   20 82 F7                      JSR     DEV_ADD         ; add sd-card driver
   ED29   A9 00         INIT_TAPE       LDA	#$00
   ED2B   A0 1B                         LDY	#ACR		; select auxilary control register
   ED2D   91 14         		STA	(IOBASE),Y	; set one shot timer mode
   ED2F   85 E5                         STA	KEY_SENSE	; reset tape sense line status
   ED31   A0 1C         		LDY	#PCR		; select peripheral control register
   ED33   91 14         		STA	(IOBASE),Y	; set interrupt on falling edge of CA1
                        		;LDY	#IER		; select interrupt enable register
   ED35   20 DC EF      		JSR	TAPERW_OFF	; turn tape read/write mode off
   ED38   20 96 EF      		JSR	RESET_TIMER2	; set Timer2 to 1/60 second
   ED3B   A2 B0                         LDX     #LOW  TAPE_DEV
   ED3D   A0 F9                         LDY     #HIGH TAPE_DEV
   ED3F   20 82 F7                      JSR     DEV_ADD         ; add tape driver
   ED42   A2 60         		LDX	#LOW  TAPEIRQ 	; set low address of clock interrupt routine
   ED44   A0 EF         		LDY	#HIGH TAPEIRQ   ; set low address of clock interrupt routine
   ED46   8E 7E 1A      SETIRQVECT	STX	IRQVECT
   ED49   8C 7F 1A      		STY	IRQVECT+1
   ED4C   60            		RTS
                        
                        ; ******************************************************************************
                        ; START OF TAPE READ/WRITE ROUTINES
                        ; ******************************************************************************
                        
   ED4D   4C EA ED      TAPEESC		JMP	BREAKSYNC
                        
                        ; *** Tape Load Routine ********************************************************
                        
                        ; ******************************************************************************
                        
   ED50   20 E4 EF      TAPELOAD	JSR	PREPFILENAME
   ED53   20 7E F2      		JSR	TAPE_PLAY_MSG	; print PLAY message
   ED56   20 82 F2      		JSR	TAPE_ESC_MSG
   ED59   20 5C E1      WAITPLAY	JSR	CHKESC		; <ESC> key pressed?
   ED5C   B0 EF         		BCS	TAPEESC		; yes -> exit
   ED5E   A5 E5         		LDA	KEY_SENSE	; check sense line status
   ED60   D0 F7         		BNE	WAITPLAY	; if <> 0, wait until datasette key pressed down
   ED62   20 D4 EF      		JSR	TAPERW_ON	; turn off key clock interrupt and turn on bit read interrupt
   ED65   20 6F F2      STARTLOAD	JSR	TAPE_LOAD_MSG	; print LOAD message
   ED68   20 B3 EF      		JSR	MOTOR_ON	; and turn motor on
   ED6B   A9 01         STARTSYNC	LDA	#$01		; we are in sync mode
   ED6D   85 ED         		STA	BITCNT		; so initialize bit counter to just one bit
   ED6F   A0 10         WAITBIT		LDY	#PORTB		; set index to Port B
   ED71   B1 14         		LDA	(IOBASE),Y	; load port B
   ED73   29 20         		AND	#$20		; test tape sense line at PB5
   ED75   D0 73         		BNE	BREAKSYNC	; if sense line is high, PLAY key is no longer down -> exit.
   ED77   A5 ED         READSYNC	LDA	BITCNT		; bit counter reached 0 ?
   ED79   D0 F4         		BNE	WAITBIT		; no, wait for more bits
   ED7B   A5 DD         		LDA	OUTBYTE		; yes, load current byte into A
   ED7D   C9 2E         		CMP	#SYNCMARK	; is it a valid sync mark?
   ED7F   D0 EA         		BNE	STARTSYNC	; no, resync
   ED81   A2 00         		LDX	#$00
   ED83   86 E3         		STX	IBYTES		; yes, reset sync block counter
   ED85   20 5D EE      GETBYTE?	JSR	BYTE_IN		; read next full byte
   ED88   A5 DD         		LDA	OUTBYTE		; and load it into A
   ED8A   C9 2E         		CMP	#SYNCMARK	; still a sync mark?
   ED8C   D0 0B         		BNE	SYNCEND?	; no, check if end of sync
   ED8E   E8            		INX			; yes, increment sync mark counter
   ED8F   D0 F4         		BNE	GETBYTE?	; 256 sync marks read? no read more
   ED91   20 52 E0      		JSR	COUT		; yes, print '.'
   ED94   E6 E3         		INC	IBYTES		; increment sync block counter
   ED96   4C 85 ED      		JMP	GETBYTE?	; and read next byte
   ED99   A5 E3         SYNCEND?	LDA	IBYTES
   ED9B   F0 CE         		BEQ	STARTSYNC	; at least one sync block read? no resync
   ED9D   20 F6 ED      		JSR	READHEADER	; yes, read header. C = 0 if no header mark is found. X returns 0
   EDA0   90 C9         		BCC	STARTSYNC	; no header mark found or names not equal. resync
   EDA2   86 E2         		STX	BLKNO		; BLKNO = 0
   EDA4   86 DC         		STX	CHECKSUM	; CHECKSUM = 0
   EDA6   A5 DD         NEXTBLK		LDA	OUTBYTE		; load current block number into A
   EDA8   C5 E2         		CMP	BLKNO		; is it the expected number?
   EDAA   D0 44         		BNE	ERRLOAD		; no, error.
   EDAC   20 5D EE      NEXTDATA	JSR	BYTE_IN		; yes, read next data byte
   EDAF   A5 DD         		LDA	OUTBYTE		; and load it into A
   EDB1   A0 00         		LDY	#$00
   EDB3   91 FA         		STA	(ADRL),Y	; store read data byte to destination address
   EDB5   45 DC         		EOR	CHECKSUM	; XOR it with checksum
   EDB7   85 DC         		STA	CHECKSUM	; and write result back to checksum
   EDB9   20 49 E7      		JSR	CMPADDR		; see if there's more to load
   EDBC   B0 17                         BCS  	ENDLDDATA  	; no, finish loading
   EDBE   20 7C E9      		JSR	INCADR		; yes, increment current destination address
   EDC1   E8            		INX
   EDC2   D0 E8         		BNE	NEXTDATA	; and read next byte
   EDC4   20 5D EE      		JSR	BYTE_IN		; read checksum
   EDC7   A5 DD         		LDA	OUTBYTE		; and load it int A
   EDC9   C5 DC         		CMP	CHECKSUM	; compare expected check sum with calculated checksum
   EDCB   D0 23         		BNE	ERRLOAD		; if checksum incorrect, exit with error
   EDCD   20 5D EE      		JSR	BYTE_IN		; read next block number
   EDD0   E6 E2         		INC	BLKNO		; increment internal block counter
   EDD2   4C A6 ED      		JMP	NEXTBLK		; read next block
   EDD5   20 5D EE      ENDLDDATA	JSR	BYTE_IN		; read last checksum
   EDD8   A5 DD         		LDA	OUTBYTE		; and load it int A
   EDDA   C5 DC         		CMP	CHECKSUM	; compare expected check sum with calculated checksum
   EDDC   D0 12         		BNE	ERRLOAD		; if checksum incorrect, exit with error
   EDDE   20 5C F2      		JSR	TAPE_OK_MSG	; print OK message
   EDE1   20 DC EF      ENDLOAD		JSR	TAPERW_OFF	; return to clock interrupt
   EDE4   4C BE EF      		JMP	MOTOR_OFF	; and turn motor off
                        
   EDE7   68            BREAKREAD	PLA			; clean up stack
   EDE8   68            		PLA
   EDE9   68            		PLA
   EDEA   20 66 F2      BREAKSYNC	JSR	TAPE_BREAK_MSG	; print BREAK message
   EDED   4C E1 ED      		JMP	ENDLOAD		; and exit
                        
   EDF0   20 61 F2      ERRLOAD		JSR	TAPE_ERR_MSG	; print error message
   EDF3   4C E1 ED      		JMP	ENDLOAD		; end exit
                        
                        ; *** Read Tape Header Routine *************************************************
                        
                        ; ******************************************************************************
                        
   EDF6   A5 DD         READHEADER	LDA	OUTBYTE		; load current byte
   EDF8   C9 A1         		CMP	#ADDRMARK	; is it a address mark?
   EDFA   D0 5A         		BNE	NOHDRMARK	; no, exit
   EDFC   A0 00         		LDY	#$00		; set string counter to 0
   EDFE   84 E1         		STY	EQUFLAG		; clear character compare flag
   EE00   A2 06         		LDX	#$06		; 6 bytes (start address, end address, reserved) to read
   EE02   20 5D EE      READADDR	JSR	BYTE_IN		; read new address byte
   EE05   A5 DD         		LDA	OUTBYTE		; and load it into A
   EE07   95 F5         		STA	NUML-3,X	; store it to pinter location
   EE09   B9 F8 F2      		LDA	TAPEFND,Y	; load one char of "found" message
   EE0C   20 52 E0      		JSR	COUT		; and print it
   EE0F   C8            		INY			; increment message pointer
   EE10   CA            		DEX			; decrement byte read counter
   EE11   D0 EF         		BNE	READADDR	; more address bytes to read?
   EE13   20 5D EE      		JSR	BYTE_IN		; read next byte
   EE16   A5 DD         		LDA	OUTBYTE		; and load it into A
   EE18   C9 A0         		CMP	#NAMEMARK	; is it a name mark?
   EE1A   D0 22         		BNE	READFIRSTBYTE	; no, read first data byte
   EE1C   A0 00         		LDY	#$00		; reset name string pointer
   EE1E   20 5D EE      READNAME	JSR	BYTE_IN		; read name char
   EE21   A5 DD         		LDA	OUTBYTE		; load it into A
   EE23   85 E3         		STA	IBYTES 		; and save value
   EE25   C9 1F         		CMP	#FILEMARK	; is it the file mark?
   EE27   F0 15         		BEQ	READFIRSTBYTE	; yes, read first data byte
   EE29   90 2D         		BCC	MARKERROR 	; is character < spac char? yes show error
   EE2B   20 52 E0      		JSR	COUT		; no, print current name char
   EE2E   B9 00 15      		LDA	RBUFF,Y		; load compare char
   EE31   C9 2A         		CMP	#'*'		; is it a '*'?
   EE33   F0 E9         		BEQ	READNAME	; yes, skip compare
   EE35   C8            		INY
   EE36   45 E3         		EOR	IBYTES		; is char of search name equal current name?
   EE38   F0 E4         		BEQ	READNAME	; yes, read next char
   EE3A   85 E1         		STA	EQUFLAG		; no, mark name as not equal
   EE3C   D0 E0         		BNE	READNAME	; and read next char
                        
   EE3E   A5 E1         READFIRSTBYTE	LDA	EQUFLAG		; is search name equal current name?
   EE40   D0 11         		BNE	NAMENEQ		; no, we need to skip the file
   EE42   B9 00 15      		LDA	RBUFF,Y
   EE45   C9 2A         		CMP	#'*'		; was last char in search name a '*'?
   EE47   F0 05         		BEQ	NAMEEQU		; yes, name is equal
   EE49   B9 00 15      		LDA	RBUFF,Y		; no, is search name length equal current name length?
   EE4C   D0 05         		BNE	NAMENEQ		; no, we need to skip the file
   EE4E   20 5D EE      NAMEEQU		JSR	BYTE_IN		; yes, read first data Byte
   EE51   38            		SEC			; header OK, so set carry flag
   EE52   60            		RTS
                        
   EE53   20 73 F2      NAMENEQ		JSR	TAPE_SKIP_MSG	; print skip message
   EE56   18            NOHDRMARK	CLC			; header not OK, so clear carry flag
   EE57   60            		RTS
                        
   EE58   68            MARKERROR	PLA			; clear return address
   EE59   68            		PLA
   EE5A   4C F0 ED      		JMP	ERRLOAD		; and jump to error routine
                        
                        ; *** Tape Byte Read Routine ***************************************************
                        
                        ; ******************************************************************************
                        
   EE5D   98            BYTE_IN		TYA			; save Y register
   EE5E   48            		PHA
   EE5F   A0 10         		LDY	#PORTB		; select port B register
   EE61   B1 14         READBIT		LDA	(IOBASE),Y	; read port B Bits
   EE63   29 20         		AND	#$20		; test tape sense line at PB5
   EE65   D0 80         		BNE	BREAKREAD	; play key is no longer down, stop reading
   EE67   A5 ED         		LDA	BITCNT		; load bit counter
   EE69   D0 F6         		BNE	READBIT		; check again until bit counter = 0
   EE6B   A9 08         		LDA	#$08
   EE6D   85 ED         		STA	BITCNT		; reset bit counter
   EE6F   68            ENDBYTE_IN	PLA			; yes, restore Y register
   EE70   A8            		TAY
   EE71   60            		RTS
                        
                        ; *** Tape Save Routine ********************************************************
                        
                        ; ******************************************************************************
                        
   EE72   20 E4 EF      TAPESAVE	JSR	PREPFILENAME
   EE75   20 77 F2      		JSR	TAPE_REC_MSG	; Print press record message
   EE78   20 82 F2      		JSR	TAPE_ESC_MSG
   EE7B   20 5C E1      WAITRECORD	JSR	CHKESC		; <ESC> key pressed?
   EE7E   B0 64         		BCS	BREAKSAVE	; yes -> exit
   EE80   A5 E5         		LDA	KEY_SENSE	; Check if any Datasette key is pressed
   EE82   D0 F7         		BNE	WAITRECORD	; No, repeat check
   EE84   20 6B F2      		JSR	TAPE_SAVE_MSG	; Print save message
   EE87   78            		SEI			; Yes, disable interrupts
   EE88   20 83 E0      		JSR	STROUT		; Print file name
   EE8B   A9 FF         		LDA	#$FF
   EE8D   8D 94 1A      		STA  	CNTA		; Initialize timer value
   EE90   A9 06         		LDA	#$06		; Write 6x256 Byte blocks of sync marks
   EE92   20 EA EE      		JSR	WRITESYNC	; Write sync marks
   EE95   20 00 EF      		JSR	WRITEHEADER	; Write tape header
   EE98   A9 1F         		LDA	#FILEMARK
   EE9A   20 1F EF      		JSR	BYTE_OUT	; Write file mark
   EE9D   A9 00         		LDA	#$00
   EE9F   85 DC         		STA	CHECKSUM	; Initialize XOR data checksum
   EEA1   85 E2         		STA	BLKNO		; Initialize block numbers
   EEA3   AA            		TAX			; Initialize Byte counter
   EEA4   20 1F EF      NEXTBLOCK	JSR	BYTE_OUT	; Write block number to tape
   EEA7   A0 10         WRNXTBYTE	LDY	#PORTB
   EEA9   B1 14         		LDA	(IOBASE),Y	; Read Port B
   EEAB   29 20         		AND	#$20		; Test tape sense line at PB5
   EEAD   D0 35         		BNE	BREAKSAVE	; No Datasette key pressed. Stop saving
   EEAF   A0 00         		LDY	#$00
   EEB1   B1 FA         		LDA	(ADRL),Y	; Load current data Byte
   EEB3   A8            		TAY			; Save data to Y register
   EEB4   45 DC         		EOR	CHECKSUM	; XOR data with checksum
   EEB6   85 DC         		STA	CHECKSUM
   EEB8   98            		TYA			; Reload data into Accumulator
   EEB9   20 1F EF      		JSR	BYTE_OUT	; Write data Byte to tape
   EEBC   20 49 E7      		JSR	CMPADDR		; See if there's more to copy
   EEBF   B0 12                         BCS  	ENDDATA  	; No more data to copy
   EEC1   20 7C E9      		JSR	INCADR		; Increment current save address
   EEC4   E8            		INX			; Increment Byte counter
   EEC5   D0 E0         		BNE	WRNXTBYTE	; If less than 256 Bytes written, then write next data Byte
   EEC7   A5 DC         ENDBLOCK	LDA	CHECKSUM	; Else...
   EEC9   20 1F EF      		JSR	BYTE_OUT	; Write checksum at the end of block
   EECC   E6 E2         		INC	BLKNO		; Increment block number
   EECE   A5 E2         		LDA	BLKNO
   EED0   4C A4 EE      		JMP	NEXTBLOCK	; Write next block
   EED3   A5 DC         ENDDATA		LDA	CHECKSUM
   EED5   20 1F EF      		JSR	BYTE_OUT	; Write checksum at end of block
   EED8   A9 03         		LDA	#$03
   EEDA   20 1F EF      		JSR	BYTE_OUT	; Write End-Of-Text mark
   EEDD   20 5C F2      		JSR	TAPE_OK_MSG	; Print OK message
   EEE0   58            ENDSAVE		CLI			; Reenable interrupts
   EEE1   4C BE EF      		JMP	MOTOR_OFF	; Stop motor
                        
                        ; ******************************************************************************
                        
   EEE4   20 66 F2      BREAKSAVE	JSR	TAPE_BREAK_MSG	; Print Break message
   EEE7   4C E0 EE      		JMP	ENDSAVE
                        
                        ; **** Write Synchronization Bytes To Tape *************************************
                        
                        ; ******************************************************************************
                        
   EEEA   85 E9         WRITESYNC	STA	STOH
   EEEC   A9 00         		LDA	#$00
   EEEE   85 E8         		STA	STOL
   EEF0   A9 2E         		LDA	#SYNCMARK	; Load sync mark
   EEF2   85 DD         		STA	OUTBYTE		; and store it to output variable
   EEF4   20 21 EF      PLOOP		JSR	WRITEBYTE	; Write sync mark
   EEF7   C6 E8         		DEC	STOL		; Decrement loop counter
   EEF9   D0 F9         		BNE	PLOOP		; Repeat loop if counter low byte > 0
   EEFB   C6 E9         		DEC	STOH		; Overflow, decrement counter high byte
   EEFD   D0 F5         		BNE	PLOOP		; Repeat loop if counter high byte > 0
   EEFF   60            ENDPREAMBLE	RTS
                        
                        ; **** Write File Header To Tape ***********************************************
                        
                        ; ******************************************************************************
                        
   EF00   A2 06         WRITEHEADER	LDX	#$06
   EF02   A9 A1         		LDA	#ADDRMARK	; load address mark
   EF04   20 1F EF      WRITEADDR	JSR	BYTE_OUT	; write to tape
   EF07   B5 F5         		LDA	NUML-3,X	; load address byte
   EF09   CA            		DEX
   EF0A   10 F8         		BPL	WRITEADDR	; all address fields written? no repeat
   EF0C   A9 A0         		LDA	#NAMEMARK	; yes, load name mark
   EF0E   20 1F EF      		JSR	BYTE_OUT	; and write it to tape
   EF11   A0 00         		LDY	#$00		; index to first filename char
   EF13   B9 00 15      WRNXTCHAR	LDA	RBUFF,Y		; load filename char
   EF16   F0 06         		BEQ	ENDHEADER	; is it a NULL? yes -> exit
   EF18   20 1F EF      		JSR	BYTE_OUT	; no write filename char to tape
   EF1B   C8            		INY			; increment index to next filename char
   EF1C   D0 F5         		BNE	WRNXTCHAR	; and write it
   EF1E   60            ENDHEADER	RTS
                        
                        ; **** Write Tape Byte Routine *************************************************
                        
                        ; ******************************************************************************
                        
   EF1F   85 DD         BYTE_OUT	STA	OUTBYTE		; save output byte
   EF21   8A            WRITEBYTE	TXA			; save X register
   EF22   48            		PHA
   EF23   98            		TYA			; save Y register
   EF24   48            		PHA
   EF25   2C 9F 1A      WAIT_BIT1	BIT  	CNTIRQ		; timer counted to zero
   EF28   10 FB         		BPL  	WAIT_BIT1	; no, repeat test
   EF2A   A2 08         		LDX	#8		; initialize bit counter
   EF2C   A0 10         NEXT_BIT	LDY	#PORTB
   EF2E   A9 10         		LDA	#%00010000	; set CAS_WR output HIGH
   EF30   05 E4         		ORA	VIA_STATUS	; get old output status and set CAS_WR Pin
   EF32   91 14         		STA	(IOBASE),Y
   EF34   26 DD         		ROL	OUTBYTE		; rotate next output bit to carry flag
   EF36   90 04         		BCC	SET_SHORT	; if carry = 0 then write short pulse
   EF38   A0 BE         SET_LONG	LDY	#LPTIME		; else write long pulse
   EF3A   D0 02         		BNE	WRITE_BIT
   EF3C   A0 3C         SET_SHORT	LDY	#SPTIME		; set short pulse value
   EF3E   84 FD         WRITE_BIT	STY	YSAV		; save pulse width value for low phase
   EF40   20 53 E1      		JSR	SHORTDELAY1	; high phase delay
   EF43   A0 10         		LDY	#PORTB		; index to port B
   EF45   A9 EF         		LDA	#%11101111	; set CAS_WR output LOW
   EF47   25 E4         		AND	VIA_STATUS	; get old output status and clear CAS_WR pin
   EF49   91 14         		STA	(IOBASE),Y
   EF4B   A4 FD         		LDY	YSAV		; restore delay value for low phase of pulse
   EF4D   CA            		DEX
   EF4E   F0 06         		BEQ	ENDWRITE	; all bits done? yes, exit routine
   EF50   20 53 E1      		JSR	SHORTDELAY1	; low phase delay
   EF53   4C 2C EF      		JMP	NEXT_BIT	; continue bit send loop
   EF56   8C 94 1A      ENDWRITE	STY  	CNTA		; set timer for final low phase
   EF59   26 DD         		ROL	OUTBYTE		; rotate one bit to restore old Byte value
   EF5B   68            		PLA
   EF5C   A8            		TAY			; restore Y register
   EF5D   68            		PLA
   EF5E   AA            		TAX			; restore X register
   EF5F   60            		RTS
                        
                        ; **** VIA2 IRQ Routine ********************************************************
                        
                        ; ******************************************************************************
                        
   EF60   48            TAPEIRQ		PHA			; save accumulator
   EF61   98            		TYA
   EF62   48            		PHA			; save Y register
   EF63   A0 1D         		LDY	#IFR		; select interrupt flag register
   EF65   B1 14         		LDA	(IOBASE),Y
   EF67   10 27         		BPL	NOTAPEIRQ	; check if it was a VIA2 interrupt
   EF69   29 02         		AND	#$02		; yes, CA1 interrupt occured?
   EF6B   F0 13         		BEQ	CHECKKEY	; no, check key status
   EF6D   C6 ED         CHECKBIT	DEC	BITCNT		; decrement bit counter
   EF6F   A0 11         		LDY	#PORTA
   EF71   B1 14         		LDA	(IOBASE),Y	; clear CA1 interrupt flag
   EF73   AD 9F 1A      		LDA	CNTIRQ		; load timer IRQ status
   EF76   0A            		ASL	A		; and shift it into the carry flag
   EF77   26 DD         		ROL	OUTBYTE		; save carry as current bit value
   EF79   A9 31         		LDA	#RPTIME
   EF7B   8D 95 1A      		STA	CNTB		; set timer to Read-Point-Time
   EF7E   D0 0C         		BNE	ENDTAPEIRQ	; and exit IRQ routine
   EF80   20 A2 EF      CHECKKEY	JSR	CHECK_KEYSIG	; check tape sense line
   EF83   20 96 EF      		JSR	RESET_TIMER2	; reset Timer2 and interrupt flags
   EF86   A5 DA         		LDA     TICKCNT         ; load the tick counter
   EF88   F0 02         		BEQ     ENDTAPEIRQ      ; is it 0?
   EF8A   C6 DA         		DEC     TICKCNT         ; no, decrement tick counter
   EF8C   68            ENDTAPEIRQ	PLA
   EF8D   A8            		TAY			; restore Y register
   EF8E   68            		PLA			; restore accumulator
   EF8F   40            		RTI
                        
   EF90   68            NOTAPEIRQ	PLA
   EF91   A8            		TAY			; restore Y register
   EF92   68            	        PLA			; restore accumulator
   EF93   4C 15 F3      USRIRQ		JMP	IRQ		; call user interrupt routine
                        
                        ; **** Reset Timer2 Routine ****************************************************
                        
                        ; ******************************************************************************
                        
   EF96   A0 18         RESET_TIMER2	LDY	#T2CL		; select Timer2 lower byte register
   EF98   A9 4B         		LDA	#$4B		; reset Timer2
   EF9A   91 14         		STA	(IOBASE),Y	; store timer low value
   EF9C   A9 41         		LDA	#$41
   EF9E   C8            		INY			; select Timer2 higher byte register
   EF9F   91 14         		STA	(IOBASE),Y	; store timer high value
   EFA1   60            		RTS
                        
                        ; **** Check Tape Sense Line Routine *******************************************
                        
                        ; ******************************************************************************
                        
   EFA2   A0 10         CHECK_KEYSIG	LDY	#PORTB
   EFA4   B1 14         		LDA	(IOBASE),Y
   EFA6   29 20         		AND	#$20		; test tape sense line at PB5
   EFA8   C5 E5         		CMP	KEY_SENSE	; is it different to old tape sense line status?
   EFAA   F0 06         		BEQ	ENDCHECK	; no, just return
   EFAC   85 E5          		STA	KEY_SENSE	; yes, save new state value
   EFAE   B0 0E         		BCS	MOTOR_OFF
   EFB0   90 01         		BCC	MOTOR_ON
   EFB2   60            ENDCHECK	RTS
                        
                        ; **** Turn Tape Drive Motor On ************************************************
                        
                        ; ******************************************************************************
                        
   EFB3   A0 10         MOTOR_ON	LDY	#PORTB
   EFB5   A9 BF         		LDA	#%10111111	; set CAS_MOT line low
   EFB7   25 E4         		AND	VIA_STATUS
   EFB9   85 E4         		STA	VIA_STATUS
   EFBB   91 14         		STA	(IOBASE),Y
   EFBD   60            		RTS
                        
                        ; **** Turn Tape Drive Motor Off ***********************************************
                        
                        ; ******************************************************************************
                        
   EFBE   A0 10         MOTOR_OFF	LDY	#PORTB
   EFC0   A9 40         		LDA	#%01000000	; set CAS_MOT line high
   EFC2   05 E4         		ORA	VIA_STATUS
   EFC4   85 E4         		STA	VIA_STATUS
   EFC6   91 14         		STA	(IOBASE),Y
   EFC8   60            		RTS
                        
                        ; **** Tape IRQ Off ************************************************************
                        
                        ; ******************************************************************************
                        
   EFC9   A0 1E         TAPEIRQ_OFF     LDY	#IER		; select interrupt enable register
   EFCB   A5 15                         LDA     IOBASEH
   EFCD   F0 04                         BEQ     TAPEIRQ_OFF1    ; IO card available? No, just exit
   EFCF   A9 7F         		LDA	#$7F
   EFD1   91 14         		STA	(IOBASE),Y	; disable all VIA2 interrupts
   EFD3   60            TAPEIRQ_OFF1	RTS
                        
                        ; **** Turn Tape Read/Write Mode On ********************************************
                        
                        ; ******************************************************************************
                        
   EFD4   20 C9 EF      TAPERW_ON	JSR	TAPEIRQ_OFF
   EFD7   A9 82         		LDA	#$82
   EFD9   91 14         		STA	(IOBASE),Y	; set interrupt for CA1
   EFDB   60            		RTS
                        
                        ; **** Turn Tape Read/Write Mode Off *******************************************
                        
                        ; ******************************************************************************
                        
   EFDC   20 C9 EF      TAPERW_OFF	JSR	TAPEIRQ_OFF
   EFDF   A9 A0         		LDA	#$A0
   EFE1   91 14         		STA	(IOBASE),Y	; set interrupt for Timer2
   EFE3   60            		RTS
                        
                        ; **** Prepare Filename ********************************************************
                        
                        ; Input: X - low byte of string pointer
                        ;	 Y - high byte of string pointer
                        
                        ; ******************************************************************************
                        
   EFE4   20 48 E1      PREPFILENAME	JSR	SETSTRBUFF0
   EFE7   A0 00         		LDY	#$00
   EFE9   A2 00         		LDX	#$00
   EFEB   B1 EA         NEXTFNCHAR	LDA  	(PSTR),Y   	; get next input char
   EFED   F0 11         		BEQ	ENDFILENAME
   EFEF   C9 61         		CMP	#'a'		; char < 'a'?
   EFF1   90 06         		BCC	COPYNAME	; no, just copy char to buffer
   EFF3   C9 7B         		CMP	#'{'		; char > 'z'?
   EFF5   B0 02         		BCS	COPYNAME	; no, just copy char to buffer
   EFF7   29 DF         		AND	#$DF		; convert to upper case char
   EFF9   9D 00 15      COPYNAME	STA	RBUFF,X		; char to buffer
   EFFC   C8            		INY
   EFFD   E8            		INX
   EFFE   D0 EB         		BNE	NEXTFNCHAR	; read next char of filename
   F000   E0 00         ENDFILENAME	CPX	#$00
   F002   D0 07         		BNE	ENDPREP		; is X = 0? no -> exit
   F004   A9 2A         		LDA	#'*'		; yes, empty string.
   F006   9D 00 15      		STA	RBUFF,X		; make it "*"
   F009   E8            		INX
   F00A   98            		TYA
   F00B   9D 00 15      ENDPREP		STA	RBUFF,X		; terminate string with NULL
   F00E   20 44 E1      		JSR	SETSTRBUFF
   F011   60            		RTS
                        
                        ; ******************************************************************************
                        ; START OF XMODEM CODE
                        ; ******************************************************************************
                        ;
                        ; XMODEM/CRC Sender/Receiver for the 6502
                        ;
                        ; By Daryl Rictor Aug 2002
                        ;
                        ; A simple file transfer program to allow transfers between the SBC and a
                        ; console device utilizing the x-modem/CRC transfer protocol.
                        ;
                        ;*******************************************************************************
                        ; This implementation of XMODEM/CRC does NOT conform strictly to the
                        ; XMODEM protocol standard in that it (1) does not accurately time character
                        ; reception or (2) fall back to the Checksum mode.
                        
                        ; (1) For timing, it uses a crude timing loop to provide approximate
                        ; delays.  These have been calibrated against a 1MHz CPU clock.  I have
                        ; found that CPU clock speed of up to 5MHz also work but may not in
                        ; every case.  Windows HyperTerminal worked quite well at both speeds!
                        ;
                        ; (2) Most modern terminal programs support XMODEM/CRC which can detect a
                        ; wider range of transmission errors so the fallback to the simple checksum
                        ; calculation was not implemented to save space.
                        ;*******************************************************************************
                        ;
                        ; Files transferred via XMODEM-CRC will have the load address contained in
                        ; the first two bytes in little-endian format:
                        ;  FIRST BLOCK
                        ;     offset(0) = lo(load start address),
                        ;     offset(1) = hi(load start address)
                        ;     offset(2) = data byte (0)
                        ;     offset(n) = data byte (n-2)
                        ;
                        ; Subsequent blocks
                        ;     offset(n) = data byte (n)
                        ;
                        ; One note, XMODEM send 128 byte blocks.  If the block of memory that
                        ; you wish to save is smaller than the 128 byte block boundary, then
                        ; the last block will be padded with zeros.  Upon reloading, the
                        ; data will be written back to the original location.  In addition, the
                        ; padded zeros WILL also be written into RAM, which could overwrite other
                        ; data.
                        ;
                        ;*******************************************************************************
                        ;
                        ; Code extensions 2022 by Joerg Walke
                        ;
                        ; Included: CAN command in addition to ESC to cancel sending and receiving data.
                        ; Included: EOT command to signal end of transmition.
                        ; Included: address range for received data, to override the start address in
                        ;           the first data block and to prevent overwriting of data by
                        ;	    trailing zeros.
                        
                        ; XMODEM Receive Routine *******************************************************
                        
   F012   20 36 F2      XModemRcv       JSR     PrintXStart
   F015   85 E0         		STA	BLKEND		; set flag to false
   F017   A9 01                         LDA     #$01
   F019   85 E2                         STA     BLKNO           ; set block # to 1
   F01B   85 E1                         STA	BFLAG           ; set flag to get address from block 1
   F01D   A9 43         StartRcv        LDA     #"C"            ; "C" start with CRC mode
   F01F   20 78 F3                      JSR     SOUT	     	; send it
   F022   A9 FF                         LDA     #$FF
   F024   85 DF                         STA     RETRYH          ; set loop counter for ~3 sec delay
   F026   A9 00                         LDA     #$00
   F028   85 DC                         STA     CRCL
   F02A   85 DD                         STA     CRCH            ; init CRC value
   F02C   20 DF F1                      JSR     GetByte         ; wait for input
   F02F   B0 0C         		BCS     GotByte         ; byte received, process it
   F031   4C 1D F0      		JMP     StartRcv
   F034   A9 FF         StartBlk        LDA     #$FF
   F036   85 DF                         STA     RETRYH          ; set loop counter for ~3 sec delay
   F038   20 DF F1                      JSR     GetByte         ; get first byte of block
   F03B   90 F7                         BCC     StartBlk        ; timed out, keep waiting...
   F03D   C9 1B         GotByte         CMP     #ESC            ; quitting?
   F03F   F0 04                         BEQ     GotESC          ; yes
   F041   C9 18         		CMP	#CAN		; cancel?
   F043   D0 03         		BNE     GotByte1	; no
   F045   4C 3E F2      GotESC          JMP     PrintXErr       ; print error and return
   F048   C9 01         GotByte1        CMP     #SOH            ; start of block?
   F04A   F0 07                         BEQ     BegBlk          ; yes
   F04C   C9 04                         CMP     #EOT            ;
   F04E   D0 45                         BNE     BadCRC          ; Not SOH or EOT, so flush buffer & send NAK
   F050   4C F8 F0                      JMP     RDone           ; EOT - all done!
   F053   A2 00         BegBlk          LDX     #$00
   F055   A9 FF         GetBlk          LDA     #$FF            ; 3 sec window to receive characters
   F057   85 DF                         STA     RETRYH
   F059   20 CC F1      GetBlk1         JSR     GetData         ; get next character
   F05C   90 37                         BCC     BadCRC          ; chr rcv error, flush and send NAK
   F05E   9D 00 15      GetBlk2         STA     RBUFF,x         ; good char, save it in the rcv buffer
   F061   E8                            INX                     ; inc buffer pointer
   F062   E0 84                         CPX     #$84            ; <01> <FE> <128 bytes> <CRCH> <CRCL>
   F064   D0 EF                         BNE     GetBlk          ; get 132 characters
   F066   A2 00                         LDX     #$00
   F068   BD 00 15                      LDA     RBUFF,x         ; get block # from buffer
   F06B   C5 E2                         CMP     BLKNO           ; compare to expected block #
   F06D   F0 06                         BEQ     GoodBlk1        ; matched!
   F06F   20 3E F2                      JSR     PrintXErr       ; Unexpected block number - abort
   F072   4C 0C F2                      JMP     Flush           ; mismatched - flush buffer and return
   F075   49 FF         GoodBlk1        EOR     #$FF            ; 1's comp of block #
   F077   E8                            INX                     ;
   F078   DD 00 15                      CMP     RBUFF,x         ; compare with expected 1's comp of block #
   F07B   F0 06                         BEQ     GoodBlk2        ; matched!
   F07D   20 3E F2                      JSR     PrintXErr       ; Unexpected block number - abort
   F080   4C 0C F2                      JMP     Flush           ; mismatched - flush buffer and return
   F083   20 16 F2      GoodBlk2        JSR     CalcCRC         ; calc CRC
   F086   B9 00 15                      LDA     RBUFF,y         ; get hi CRC from buffer
   F089   C5 DD                         CMP     CRCH            ; compare to calculated hi CRC
   F08B   D0 08                         BNE     BadCRC          ; bad crc, send NAK
   F08D   C8                            INY                     ;
   F08E   B9 00 15                      LDA     RBUFF,y         ; get lo CRC from buffer
   F091   C5 DC                         CMP     CRCL            ; compare to calculated lo CRC
   F093   F0 0B                         BEQ     GoodCRC         ; good CRC
   F095   20 0C F2      BadCRC          JSR     Flush           ; flush the input port
   F098   A9 15                         LDA     #NAK            ;
   F09A   20 78 F3                      JSR     SOUT            ; send NAK to resend block
   F09D   4C 34 F0                      JMP     StartBlk        ; start over, get the block again
   F0A0   A2 02         GoodCRC         LDX     #$02            ;
   F0A2   A5 E2                         LDA     BLKNO           ; get the block number
   F0A4   C9 01                         CMP     #$01            ; 1st block?
   F0A6   D0 21                         BNE     CopyBlk         ; no, copy all 128 bytes
   F0A8   A5 E1                         LDA     BFLAG           ; is it really block 1, not block 257, 513 etc.
   F0AA   F0 1D                         BEQ     CopyBlk         ; no, copy all 128 bytes
   F0AC   A5 FF         		LDA     MODE		; address mode = 0?
   F0AE   F0 03         		BEQ	READADR         ; yes, read start address from data stream
   F0B0   E8                            INX
   F0B1   D0 0B         		BNE     READDATA	; branch always
   F0B3   BD 00 15      READADR         LDA     RBUFF,x         ; get target address from 1st 2 bytes of blk 1
   F0B6   85 FA         		STA     ADRL            ; save lo address
   F0B8   E8                            INX
   F0B9   BD 00 15                      LDA     RBUFF,x         ; get hi address
   F0BC   85 FB                         STA     ADRH            ; save it
   F0BE   A5 FA         READDATA        LDA	ADRL
   F0C0   85 E8         		STA	STOL		; save start address low byte
   F0C2   A5 FB         		LDA	ADRH
   F0C4   85 E9         		STA	STOH		; save start address high byte
   F0C6   E8            		INX                     ; point to first byte of data
   F0C7   C6 E1                         DEC     BFLAG           ; set the flag so we won't get another address
   F0C9   A0 00         CopyBlk         LDY     #$00            ; set offset to zero
   F0CB   A5 E0         CopyBlk3        LDA     BLKEND		; block end flag set?
   F0CD   D0 14         		BNE     CopyBlk5	; yes, skip reading data
   F0CF   BD 00 15      		LDA     RBUFF,x         ; get data byte from buffer
   F0D2   91 E8         		STA     (STOL),y        ; save to target
   F0D4   38            		SEC
   F0D5   A5 F8                         LDA     NUML
   F0D7   E5 E8                         SBC     STOL            ; are we at the last address?
   F0D9   D0 08                         BNE     CopyBlk5  	; no, inc pointer and continue
   F0DB   A5 F9                         LDA     NUMH
   F0DD   E5 E9                         SBC     STOH
   F0DF   D0 02                         BNE     CopyBlk5
   F0E1   E6 E0                         INC     BLKEND		; yes, set last byte flag
   F0E3   E6 E8         CopyBlk5	INC     STOL            ; point to next address
   F0E5   D0 02                         BNE     CopyBlk4        ; did it step over page boundary?
   F0E7   E6 E9                         INC     STOH            ; adjust high address for page crossing
   F0E9   E8            CopyBlk4        INX                     ; point to next data byte
   F0EA   E0 82                         CPX     #$82            ; is it the last byte
   F0EC   D0 DD                         BNE     CopyBlk3        ; no, get the next one
   F0EE   E6 E2         IncBlk          INC     BLKNO           ; done.  Inc the block #
   F0F0   A9 06                         LDA     #ACK            ; send ACK
   F0F2   20 78 F3                      JSR     SOUT
   F0F5   4C 34 F0                      JMP     StartBlk        ; get next block
   F0F8   A9 06         RDone           LDA     #ACK            ; last block, send ACK and exit.
   F0FA   20 78 F3                      JSR     SOUT
   F0FD   20 0C F2                      JSR     Flush           ; get leftover characters, if any
   F100   4C 46 F2                      JMP     PrintXSucc
                        
                        ; XMODEM Send Routine **********************************************************
                        
   F103   20 36 F2      XModemSnd       JSR     PrintXStart
   F106   85 E3         		STA     ERRCNT          ; error counter set to 0
   F108   85 E0         		STA     BLKEND          ; set flag to false
   F10A   A9 01         		LDA     #$01
   F10C   85 E2                         STA     BLKNO           ; set block # to 1
   F10E   A9 FF         Wait4CRC        LDA     #$FF            ; 3 seconds
   F110   85 DF                         STA     RETRYH
   F112   20 DF F1                      JSR     GetByte
   F115   90 F7                         BCC     Wait4CRC        ; wait for something to come in...
   F117   C9 43                         CMP     #"C"            ; is it the "C" to start a CRC xfer?
   F119   F0 0B                         BEQ     SetStoAddr      ; yes
   F11B   C9 1B                         CMP     #ESC            ; is it a cancel? <Esc> Key
   F11D   F0 04                         BEQ     DoCancel        ; No, wait for another character
   F11F   C9 18         		CMP     #CAN            ; is it a cancel?
   F121   D0 EB                         BNE     Wait4CRC        ; No, wait for another character
   F123   4C C3 F1      DoCancel        JMP     PrtAbort        ; Print abort msg and exit
   F126   A9 01         SetStoAddr	LDA     #$01            ; manually load blk number
   F128   8D 00 15                      STA     RBUFF           ; into 1st byte
   F12B   A9 FE                         LDA     #$FE            ; load 1's comp of block #
   F12D   8D 01 15                      STA     RBUFF+1         ; into 2nd byte
   F130   A5 FA                         LDA     ADRL            ; load low byte of start address
   F132   8D 02 15                      STA     RBUFF+2         ; into 3rd byte
   F135   A5 FB                         LDA     ADRH            ; load hi byte of start address
   F137   8D 03 15                      STA     RBUFF+3         ; into 4th byte
   F13A   A2 04         		LDX     #$04            ; preload X to receive buffer
   F13C   A0 00         		LDY     #$00            ; init data block offset to 0
   F13E   F0 17                         BEQ     LdBuff1         ; jump into buffer load routine
   F140   A5 E0         LdBuffer        LDA     BLKEND          ; was the last block sent?
   F142   F0 03                         BEQ     LdBuff0         ; no, send the next one
   F144   4C C9 F1                      JMP     SDone           ; yes, we're done
   F147   A2 02         LdBuff0         LDX     #$02            ; init pointers
   F149   A0 00                         LDY     #$00
   F14B   E6 E2                         INC     BLKNO           ; inc block counter
   F14D   A5 E2                         LDA     BLKNO
   F14F   8D 00 15                      STA     RBUFF           ; save in 1st byte of buffer
   F152   49 FF                         EOR     #$FF
   F154   8D 01 15                      STA     RBUFF+1         ; save 1's comp of blkno next
   F157   B1 FA         LdBuff1         LDA     (ADRL),y        ; save 128 bytes of data
   F159   9D 00 15                      STA     RBUFF,x
   F15C   38            LdBuff2         SEC
   F15D   A5 F8                         LDA     NUML
   F15F   E5 FA                         SBC     ADRL            ; are we at the last address?
   F161   D0 14                         BNE     LdBuff4         ; no, inc pointer and continue
   F163   A5 F9                         LDA     NUMH
   F165   E5 FB                         SBC     ADRH
   F167   D0 0E                         BNE     LdBuff4
   F169   E6 E0                         INC     BLKEND          ; yes, set last byte flag
   F16B   E8            LdBuff3         INX
   F16C   E0 82                         CPX     #$82            ; are we at the end of the 128 byte block?
   F16E   F0 12                         BEQ     SCalcCRC        ; yes, calc CRC
   F170   A9 00                         LDA     #$00            ; fill rest of 128 bytes with $00
   F172   9D 00 15                      STA     RBUFF,x
   F175   F0 F4                         BEQ     LdBuff3         ; branch always
   F177   E6 FA         LdBuff4         INC     ADRL            ; inc address pointer
   F179   D0 02                         BNE     LdBuff5
   F17B   E6 FB                         INC     ADRH
   F17D   E8            LdBuff5         INX
   F17E   E0 82                         CPX     #$82            ; last byte in block?
   F180   D0 D5                         BNE     LdBuff1         ; no, get the next
   F182   20 16 F2      SCalcCRC        JSR     CalcCRC
   F185   A5 DD                         LDA     CRCH            ; save hi byte of CRC to buffer
   F187   99 00 15                      STA     RBUFF,y
   F18A   C8                            INY
   F18B   A5 DC                         LDA     CRCL            ; save lo byte of CRC to buffer
   F18D   99 00 15                      STA     RBUFF,y
   F190   A2 00         Resend          LDX     #$00
   F192   A9 01                         LDA     #SOH
   F194   20 78 F3                      JSR     SOUT            ; send SOH
   F197   BD 00 15      SendBlk         LDA     RBUFF,x         ; send 132 bytes in buffer to the console
   F19A   20 78 F3                      JSR     SOUT
   F19D   E8                            INX
   F19E   E0 84                         CPX     #$84            ; last byte?
   F1A0   D0 F5                         BNE     SendBlk         ; no, get next
   F1A2   A9 FF                         LDA     #$FF            ; yes, set 3 second delay
   F1A4   85 DF                         STA     RETRYH          ; and
   F1A6   20 DF F1                      JSR     GetByte         ; wait for ACK/NACK
   F1A9   90 10                         BCC     SetError        ; no char received after 3 seconds, resend
   F1AB   C9 06                         CMP     #ACK            ; char received... is it:
   F1AD   F0 91                         BEQ     LdBuffer        ; ACK, send next block
   F1AF   C9 15                         CMP     #NAK
   F1B1   F0 08                         BEQ     SetError        ; NAK, inc errors and resend
   F1B3   C9 1B                         CMP     #ESC
   F1B5   F0 0C                         BEQ     PrtAbort        ; ESC pressed to abort
   F1B7   C9 18         		CMP	#CAN
   F1B9   F0 08         		BEQ     PrtAbort	; CANCEL send
                        					; fall through to error counter
   F1BB   E6 E3         SetError        INC     ERRCNT          ; inc error counter
   F1BD   A5 E3                         LDA     ERRCNT
   F1BF   C9 0A                         CMP     #$0A            ; are there 10 errors? (Xmodem spec for failure)
   F1C1   D0 CD                         BNE     Resend          ; no, resend block
                        
   F1C3   20 0C F2      PrtAbort        JSR     Flush           ; yes, too many errors, flush buffer,
   F1C6   4C 3E F2                      JMP     PrintXErr       ; print error msg and exit
   F1C9   4C 46 F2      SDone           JMP     PrintXSucc   	; All Done..Print msg and exit
                        
                        ; Get Data From Serial Port ****************************************************
                        
   F1CC   A9 00         GetData		LDA     #$00            ; wait for chr input and cycle timing loop
   F1CE   85 DE                         STA     RETRYL          ; set low value of timing loop
   F1D0   20 88 F3      LoopGetData     JSR     SIN        	; get chr from serial port, don't wait
   F1D3   B0 09                         BCS     EndGetData      ; got one, so exit
   F1D5   C6 DE                         DEC     RETRYL          ; no character received, so dec counter
   F1D7   D0 F7                         BNE     LoopGetData
   F1D9   C6 DF                         DEC     RETRYH          ; dec hi byte of counter
   F1DB   D0 F3                         BNE     LoopGetData     ; look for character again
   F1DD   18                            CLC                     ; if loop times out, CLC, else SEC and return
   F1DE   60            EndGetData      RTS                     ; with character in A
                        
                        ; Get Byte From Serial Port. Check if ESC pressed ******************************
                        
   F1DF   A9 00         GetByte		LDA     #$00            ; wait for chr input and cycle timing loop
   F1E1   85 DE                         STA     RETRYL          ; set low value of timing loop
   F1E3   A9 88         LoopGetByte     LDA     #LOW SIN        ; check low byte of serial in address
   F1E5   CD 6E 1A      		CMP	STDIN	        ; is Low(stdin) = Low(SIN)?
   F1E8   D0 07                         BNE     GetChar         ; no, use standard Get Char Routine
   F1EA   A9 F3                         LDA     #HIGH SIN       ; yes, check high byte of serial in address
   F1EC   CD 6F 1A                      CMP     STDIN+1         ; is High(stdin) = High(SIN)?
   F1EF   F0 0C                         BEQ	ReadByte	; yes, just read input stream
   F1F1   20 4D E0      GetChar		JSR	CGET
   F1F4   90 07         		BCC	ReadByte
   F1F6   C9 1B         		CMP	#ESC
   F1F8   D0 03         		BNE	ReadByte
   F1FA   38            		SEC
   F1FB   B0 0E         		BCS	EndGetByte
                        ;		JSR	CHKESC		; no, check stdin if ESC key pressed
                        ;		BCC	ReadByte	; no ESC pressed, read data byte from serial port
                        ;		LDA	#ESC
                        ;		BNE     EndGetByte      ; ESC pressed, so exit
   F1FD   20 88 F3      ReadByte	JSR     SIN        	; get chr from serial port, don't wait
   F200   B0 09                         BCS     EndGetByte      ; got one, so exit
   F202   C6 DE                         DEC     RETRYL          ; no character received, so dec counter
   F204   D0 DD                         BNE     LoopGetByte
   F206   C6 DF                         DEC     RETRYH          ; dec hi byte of counter
   F208   D0 D9                         BNE     LoopGetByte     ; look for character again
   F20A   18                            CLC                     ; if loop times out, CLC, else SEC and return
   F20B   60            EndGetByte      RTS                     ; with character in A
                        
                        ; Empty Buffer *****************************************************************
                        
   F20C   A9 1C         Flush           LDA     #$1C            ; flush receive buffer
   F20E   85 DF                         STA     RETRYH          ; flush until empty for ~1/4 sec.
   F210   20 CC F1      Flush1          JSR     GetData         ; read the port
   F213   B0 F7                         BCS     Flush           ; if char received, wait for another
   F215   60                            RTS
                        
                        ; Calculate CRC ****************************************************************
                        
   F216   A9 00         CalcCRC		LDA	#$00		; calculate the CRC for the 128 bytes
   F218   85 DC         		STA	CRCL
   F21A   85 DD         		STA	CRCH
   F21C   A0 02         		LDY	#$02
   F21E   B9 00 15      CalcCRC1	LDA	RBUFF,y
   F221   45 DD         		EOR 	CRCH 		; Quick CRC computation with lookup tables
   F223   AA                   		TAX		 	; updates the two bytes at crc & crc+1
   F224   A5 DC                		LDA 	CRCL		; with the byte send in the "A" register
   F226   5D 00 FB             		EOR 	CRCHI,x
   F229   85 DD                		STA 	CRCH
   F22B   BD 00 FA            	 	LDA 	CRCLO,x
   F22E   85 DC                		STA 	CRCL
   F230   C8            		INY
   F231   C0 82         		CPY	#$82		; done yet?
   F233   D0 E9         		BNE	CalcCRC1	; no, get next
   F235   60            		RTS			; y=82 on exit
                        
                        ; Print XModem Messages ********************************************************
                        
   F236   78            PrintXStart     SEI			; disable interrupts during XModem transfer
   F237   20 0C F2      		JSR	Flush		; clear buffer
   F23A   A0 00         		LDY     #$00		; load start message
   F23C   F0 0C         		BEQ	PrintXMsg
                        
   F23E   20 67 E1      PrintXErr       JSR	BEEP
   F241   A0 28         PrintXError	LDY     #(ERRX-MSGX)	; load error message
   F243   18            		CLC
   F244   D0 03         		BNE     PrintXEnd
                        
   F246   A0 39         PrintXSucc      LDY     #(SUCCX-MSGX)	; load success message
   F248   38            		SEC
   F249   58            PrintXEnd	CLI			; enable interrupts
                        
   F24A   A9 00         PrintXMsg	LDA     #$00
   F24C   2A            		ROL	A		; save carry
   F24D   48            		PHA
   F24E   B9 86 F2      PrintXMsg1	LDA  	MSGX,Y   	; load char at string pos y
   F251   F0 06         		BEQ  	EndXMsg  	; exit, if NULL char
   F253   20 52 E0      		JSR  	COUT       	; write character
   F256   C8            		INY             	; next index
   F257   D0 F5         		BNE  	PrintXMsg1
   F259   68            EndXMsg		PLA
   F25A   4A            		LSR	A		; restore carry and leave A = 0
   F25B   60            		RTS
                        
                        ; Tape Messages ****************************************************************
                        
   F25C   38            TAPE_OK_MSG	SEC
   F25D   A0 3C         		LDY	#(TAPEOK-MSGX)
   F25F   D0 E9         		BNE	PrintXMsg
                        
   F261   18            TAPE_ERR_MSG	CLC
   F262   A0 80         		LDY	#(TAPELDERR-MSGX)
   F264   D0 E4         		BNE	PrintXMsg
                        
   F266   18            TAPE_BREAK_MSG	CLC
   F267   A0 78         		LDY	#(TAPEBRK-MSGX)
   F269   D0 DF         		BNE	PrintXMsg
                        
   F26B   A0 57         TAPE_SAVE_MSG	LDY	#(TAPESAV-MSGX)
   F26D   D0 DB         		BNE	PrintXMsg
                        
   F26F   A0 69         TAPE_LOAD_MSG	LDY	#(TAPELOD-MSGX)
   F271   D0 D7         		BNE	PrintXMsg
                        
   F273   A0 60         TAPE_SKIP_MSG	LDY	#(TAPESKIP-MSGX)
   F275   D0 D3         		BNE	PrintXMsg
                        
   F277   20 7E F2      TAPE_REC_MSG	JSR	TAPE_PLAY_MSG
   F27A   A0 4D         		LDY	#(TAPEREC-MSGX)
   F27C   D0 CC         		BNE	PrintXMsg
                        
   F27E   A0 41         TAPE_PLAY_MSG	LDY	#(TAPEPLAY-MSGX)
   F280   D0 C8         		BNE	PrintXMsg
                        
   F282   A0 14         TAPE_ESC_MSG	LDY	#(ESCX-MSGX)
   F284   D0 C4         		BNE	PrintXMsg
                        
                        ; ******************************************************************************
                        ; String Data Section
                        ; ******************************************************************************
                        
   F286   0D            MSGX            DB      CR
   F287   42 65 67 69   		TEXT	"Begin data transfer"
   F28B   6E 20 64 61   
   F28F   74 61 20 74   
   F293   72 61 6E 73   
   F297   66 65 72      
   F29A   2C 20 3C 45   ESCX		TEXT	", <ESC> to cancel. "
   F29E   53 43 3E 20   
   F2A2   74 6F 20 63   
   F2A6   61 6E 63 65   
   F2AA   6C 2E 20      
   F2AD   00            		DB     	$00
   F2AE   0D            ERRX		DB	CR
   F2AF   54 72 61 6E   		TEXT	"Transfer Error"
   F2B3   73 66 65 72   
   F2B7   20 45 72 72   
   F2BB   6F 72         
   F2BD   0D 00         		DB      CR,$00
   F2BF   04 04 04      SUCCX           DB	EOT,EOT,EOT
                        
   F2C2   0D            TAPEOK		DB	CR
   F2C3   4F 4B         		TEXT 	"OK"
   F2C5   0D 00         		DB  	CR,$00
   F2C7   0D            TAPEPLAY	DB	CR
   F2C8   50 72 65 73   		TEXT	"Press PLAY"
   F2CC   73 20 50 4C   
   F2D0   41 59         
   F2D2   00            		DB	$00
   F2D3   20 26 20 52   TAPEREC		TEXT	" & RECORD"
   F2D7   45 43 4F 52   
   F2DB   44            
   F2DC   00            		DB	$00
   F2DD   0D            TAPESAV		DB	CR
   F2DE   73 61 76 69   		TEXT	"saving "
   F2E2   6E 67 20      
   F2E5   00            		DB	$00
   F2E6   2C 20 73 6B   TAPESKIP	TEXT	", skipped"
   F2EA   69 70 70 65   
   F2EE   64            
   F2EF   0D            TAPELOD		DB	CR
   F2F0   6C 6F 61 64   		TEXT	"loading"
   F2F4   69 6E 67      
   F2F7   00            		DB	$00
   F2F8   66 6F 75 6E   TAPEFND		TEXT	"found "
   F2FC   64 20         
   F2FE   0D            TAPEBRK		DB	CR
   F2FF   42 72 65 61   		TEXT	"Break"
   F303   6B            
   F304   0D 00         		DB	CR,$00
   F306   0D            TAPELDERR	DB	CR
   F307   4C 6F 61 64   		TEXT	"Load Error"
   F30B   20 45 72 72   
   F30F   6F 72         
   F311   0D 00         		DB	CR,$00
   F313   2A            TAPEANYNAME	TEXT	"*"
   F314   00            		DB	$00
                        
                        ; **** IRQ, NMI and BREAK Service Routines *************************************
                        
                        ; ******************************************************************************
                        
   F315   8D 77 1A      IRQ		STA	STOACC		; save current accumulator
   F318   68            		PLA			; get current processor status in A
   F319   48            		PHA			; and push it back to stack
   F31A   29 10         		AND	#$10		; mask break flag
   F31C   D0 06         		BNE	USRBREAK	; if break flag set, jump to user break handler
   F31E   AD 77 1A      		LDA	STOACC
   F321   6C 7C 1A      		JMP	(IRQUSR)	; else jump to user IRQ routine
                        
   F324   AD 77 1A      USRBREAK	LDA	STOACC
   F327   6C 78 1A      		JMP	(BRKUSR)
                        
   F32A   85 F3         NMI		STA	ACC		; save current accumulator
                        
   F32C                 BREAK					; default IRQUSR & BRKUSR entry
   F32C   68            		PLA			; get current processor status in A
   F32D   85 F1         		STA	PREG		; save it
   F32F   48            		PHA			; and push it back to stack
   F330   86 F5         		STX	XREG		; save x-register
   F332   84 F4         		STY	YREG		; save y-register
   F334   20 AD E1      		JSR	RESET_STDIO	; always reset to standard I/O
   F337   28            		PLP			; get last processor status
   F338   68            		PLA			; get last program counter low byte
   F339   85 EF         		STA	PCL		; and store it
   F33B   85 FA         		STA	ADRL
   F33D   68            		PLA			; get last program counter high byte
   F33E   85 F0         		STA	PCH		; and store it
   F340   85 FB         		STA	ADRH
   F342   BA            		TSX			; get current stack pointer
   F343   86 F2         		STX	SPUSER		; and store it
   F345   D8            		CLD			; set binary mode
   F346   20 67 E1      		JSR	BEEP		; error beep
   F349   20 4B EC      		JSR	PRSTATUS	; print user program status
   F34C   A2 FF         		LDX     #$FF
   F34E   9A            		TXS			; initialize stack pointer
   F34F   58            		CLI			; enable interrupts
   F350   4C 38 E6      		JMP	MONRESET	; and return to monitor
                        
                        ; **** Try To Read Magic Number ************************************************
                        
                        ; ******************************************************************************
                        
   F353   A2 04         GETMAGIC	LDX	#$04
   F355   BD 61 E7      MAGICLOOP	LDA	MAGIC0-1,X
   F358   DD FB DF      		CMP	$DFFB,X
   F35B   D0 03         		BNE	NOMAGIC
   F35D   CA            		DEX
   F35E   D0 F5         		BNE	MAGICLOOP
   F360   8A            NOMAGIC		TXA
   F361   60            NOSTDPROC	RTS
                        
                        ; **** Write To TTY Routine *************************************************
                        ;
                        ; Input: A - Output Byte to RS232 handles $15 - CUR right, $0B - CUR up
                        ;
                        ; ******************************************************************************
                        
   F362   C9 0B         TTY_OUT         CMP     #$0B            ; VT sent?
   F364   D0 09                         BNE     TTY_OUT1
   F366   A9 1B                         LDA     #ESC            ; send ESC M
   F368   20 78 F3                      JSR     SERIALOUT
   F36B   A9 4D                         LDA     #'M'
   F36D   D0 09                         BNE     SERIALOUT       ; branch always
   F36F   C9 15         TTY_OUT1        CMP     #$15            ; HT sent?
   F371   D0 05                         BNE     SERIALOUT
   F373   20 62 E2                      JSR     TTY_ESCCODE     ; send ESC ] C
   F376   A9 43                         LDA     #'C'            ; fall through to SERIALOUT
                        
                        ; **** Write To Serial Routine *************************************************
                        
                        ; Input: A - Output Byte to RS232
                        
                        ; ******************************************************************************
                        
   F378                 SOUT
   F378   08            SERIALOUT	PHP			; save processor status
   F379   78            		SEI			; disable interrupts
   F37A   48            		PHA			; save character
   F37B   A9 10         		LDA  	#$10
   F37D   2C 01 16      EMPTY?		BIT  	STAT_REG	; ACIA output register empty?
   F380   F0 FB         		BEQ  	EMPTY?		; no, check again.
   F382   68            		PLA			; restore character
   F383   8D 00 16      		STA  	DATA_REG   	; write character to ACIA
   F386   28            		PLP			; restore processor status
   F387   60            		RTS
                        
                        ; **** Read From Serial Routine ************************************************
                        
                        ; Output: A - Input Byte from RS232
                        ;         C - 1 char get, 0 no char get
                        
                        ; ******************************************************************************
                        
   F388                 SIN
   F388   18            SERIALIN	CLC              	; set to no chr present
   F389   AD 01 16      		LDA	STAT_REG
   F38C   29 08         		AND	#$08		; ACIA input register full?
   F38E   F0 04         		BEQ	SERIALEND	; no, just exit
   F390   AD 00 16      		LDA	DATA_REG	; yes, read character
   F393   38            		SEC		 	; and set C = 1, char present
   F394   60            SERIALEND	RTS
                        
                        ; **** Read From ASCII Keyboard Routine ****************************************
                        
                        ; Output: A - Input Byte from Keyboard
                        ;         C - 1 char get, 0 no char get
                        
                        ; ******************************************************************************
                        
   F395   AD 81 1A      ASCIIKBD	LDA	PADD		; are we in read mode?
   F398   F0 03         		BEQ	READMODE	; yes, check if data available
   F39A   20 23 F4      		JSR	SETPPORTIN	; no, first set parallel port as an input
   F39D   18            READMODE	CLC			; set to no char present
   F39E   2C 85 1A      		BIT	WRDC		; test PA7 (DATA_AVAIL)
   F3A1   50 09         		BVC	NODATA		; no new data, just exit with C = 0
   F3A3   AD 85 1A      		LDA	WRDC		; clear PA7 flag
   F3A6   AD 80 1A      		LDA	PAD		; load keyboard ASCII code from port A
   F3A9   29 7F         		AND	#%01111111	; clear MSB
   F3AB   38            DATA_AVAIL	SEC			; and set C = 1, char present
   F3AC   60            NODATA		RTS
                        
                        ; **** PS2 Keyboard Driver Routine *********************************************
                        
                        ; Output: A - Input Byte from Keyboard
                        ;         C - 1 char get, 0 no char get
                        
                        ; ******************************************************************************
                        
   F3AD   18            PS2KBD          CLC                     ; set to no char present
   F3AE   84 F1                         STY     PREG            ; save current Y register
   F3B0   A0 0E                         LDY     #PIA_PORTC
   F3B2   B1 16                         LDA     (FGCBASE),Y     ; load data from Port C
   F3B4   29 20                         AND     #$20            ; and check Strobe line
   F3B6   F0 15                         BEQ     PS2_NODATA      ; no data received, just exit with C = 0
   F3B8   A0 0C                         LDY     #PIA_PORTA
   F3BA   B1 16                         LDA     (FGCBASE),Y     ; data received, load it from Port A
   F3BC   D0 0E                         BNE     PS2_DATA_AVAIL
   F3BE   A0 0E                         LDY     #PIA_PORTC      ; NULL Byte received, check for second byte
   F3C0   B1 16         PS2_CHECK       LDA     (FGCBASE),Y     ; load data from Port C
   F3C2   29 20                         AND     #$20            ; and check Strobe line
   F3C4   F0 FA                         BEQ     PS2_CHECK       ; no data received, repeat
   F3C6   A0 0C                         LDY     #PIA_PORTA
   F3C8   B1 16                         LDA     (FGCBASE),Y     ; data received, load it from Port A
   F3CA   09 80                         ORA     #$80            ; set bit 7
   F3CC   38            PS2_DATA_AVAIL  SEC			; and set C = 1, char present
   F3CD   A4 F1         PS2_NODATA      LDY     PREG            ; restore Y register
   F3CF   60                            RTS
                        
                        ; **** Detect ASCII Keyboard Routine *******************************************
                        
                        ; ******************************************************************************
                        
   F3D0   20 23 F4      DETECT_ASCIIKBD JSR	SETPPORTIN	; set parallel port as an input
   F3D3   AD 80 1A      		LDA	PAD		; read parallel port
   F3D6   C9 FF         		CMP	#$FF		; is there anything connected?
   F3D8   F0 0A         		BEQ	NOKBD		; no, just exit
   F3DA   A2 98                         LDX     #LOW  KEYBD_DEV
   F3DC   A0 F9                         LDY     #HIGH KEYBD_DEV
   F3DE   20 82 F7                      JSR     DEV_ADD         ; add ASCII keyboard driver
   F3E1   8D 74 1A      		STA	STDINDEV	; make it the standard input device
   F3E4   60            NOKBD		RTS
                        
                        ; **** Write To Parallel Port Routine ******************************************
                        
                        ; Input: A - Output Byte to parallel port
                        
                        ; ******************************************************************************
                        
   F3E5   48            PPORTOUT	PHA			; save character
   F3E6   A9 BE         		LDA	#$BE		; initialize handshake line I/O on port b
   F3E8   CD 83 1A      		CMP	PBDD		; already initialized?
   F3EB   F0 03         		BEQ	SETHSK		; yes, just set output values
   F3ED   8D 83 1A      		STA	PBDD		; no, PB7 = /strobe, PB6 = busy, PB5 = r/w, PB0 = speaker off
   F3F0   A9 86         SETHSK		LDA	#$86		; set handshake lines to their initial values
   F3F2   8D 82 1A      		STA	PBD		; r/w = L, strobe = H, PB1,PB2 = H -> hex-kbd disabled; speaker = H
   F3F5   A9 FF         		LDA	#$FF		; all port A lines are outputs
   F3F7   8D 81 1A      		STA	PADD
   F3FA   68            		PLA			; reload character in A
   F3FB   48            		PHA
   F3FC   8D 80 1A      		STA	PAD		; set output data
   F3FF   2C 82 1A      PPORTBSY?	BIT	PBD		; bussy line is high?
   F402   70 FB         		BVS	PPORTBSY?	; yes, check bussy line again
   F404   A9 06         		LDA	#$06		; generate strobe pulse
   F406   8D 82 1A      		STA	PBD		; set strobe line low
   F409   A9 86         		LDA	#$86
   F40B   8D 82 1A      		STA	PBD		; set strobe line high
   F40E   68            		PLA			; restore character
   F40F   60            		RTS
                        
                        ; **** Read From Parallel Port Routine *****************************************
                        
                        ; Output: A - Input Byte from parallel port
                        ;         C - 1 char get, 0 no char get
                        
                        ; ******************************************************************************
                        
   F410   20 23 F4      PPORTIN		JSR	SETPPORTIN	; set parallel port as input
   F413   18            		CLC
   F414   2C 82 1A      		BIT	PBD		; check if /STROBE = 0
   F417   30 09         		BMI	NOSTROBE	; no, just exit with C = 0
   F419   2C 82 1A      STROBE?		BIT	PBD		; yes, wait for strobe to come high again
   F41C   30 FB         		BMI	STROBE?
   F41E   AD 80 1A      		LDA	PAD		; load data from port A
   F421   38            		SEC			; and set C = 1, data present
   F422   60            NOSTROBE	RTS
                        
                        ; **** Switch Parallel Port To Data Input **************************************
                        
                        ; ******************************************************************************
                        
   F423   A9 00         SETPPORTIN	LDA	#$00		; initialize port A as input
   F425   8D 81 1A      		STA	PADD
   F428   A9 3E         		LDA	#$3E		; initialize port B bits for read operation
   F42A   8D 83 1A      		STA	PBDD
   F42D   A9 26         		LDA	#$26		; set PB5 = H (READ)
   F42F   8D 82 1A      		STA	PBD
   F432   8D 85 1A      		STA	WRDC		; set PA7 raising edge detection, no interrupt
   F435   AD 85 1A      		LDA	WRDC		; clear interrupt flag
   F438   60            		RTS
                        
                        ; ******************************************************************************
                        ; SPI Driver
                        ; ******************************************************************************
                        
                        ; ******************************************************************************
                        ; Initialize SPI Interface
                        ; ******************************************************************************
                        
   F439                 SPI_INIT					;fall trough to SPI_SLOW
                        
                        ; ******************************************************************************
                        ; Set SPI to Slow Mode (250KHz)
                        ; ******************************************************************************
                        
   F439   A9 04         SPI_SLOW        LDA	#$04
   F43B   A0 1B         		LDY	#ACR
   F43D   91 14         		STA	(IOBASE),Y		; set VIA mode "shift in under T2 control"
   F43F   A9 00         		LDA	#$00			; reset Timer2
   F441   A0 18         		LDY	#T2CL
   F443   91 14         		STA	(IOBASE),Y		; store timer low value
   F445   20 74 F4      		JSR	SPI_RESET		; flush shift register
   F448   60            		RTS				; Clock is set to 250 kHz
                        
                        ; ******************************************************************************
                        ; Set SPI to Fast Mode (500KHz)
                        ; ******************************************************************************
                        
   F449   A9 08         SPI_FAST	LDA	#$08
   F44B   A0 1B         		LDY	#ACR
   F44D   91 14         		STA	(IOBASE),Y		; set VIA mode "shift in under phi2 control"
   F44F   60            		RTS				; Clock is set to 500 kHz
                        
                        ; ******************************************************************************
                        ; Write a Single Byte to the SPI Interface
                        ;
                        ; Input: A = Byte to Send
                        ; ******************************************************************************
                        
   F450   84 FD         SPI_WRITE	STY	YSAV
   F452   A0 11         		LDY	#PORTA
   F454   91 14         		STA	(IOBASE),Y		; output data to shift register
   F456   A0 1D         		LDY	#IFR
   F458   A9 04         SPI_WRITE1	LDA	#$04			; set bit mask for data available flag
   F45A   31 14         		AND	(IOBASE),Y		; shift register full?
   F45C   F0 FA         		BEQ	SPI_WRITE1		; no, check again
   F45E   A0 10         		LDY	#PORTB
   F460   A9 42         		LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
   F462   91 14         		STA	(IOBASE),Y		; load data into shift register
   F464   A9 4A         		LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
   F466   91 14         		STA	(IOBASE),Y		; data is now in shift register
   F468   D0 0A         		BNE	SPI_RESET               ; branch always
                        
                        ; ******************************************************************************
                        ; Read a Single Byte from the SPI Interface
                        ;
                        ; Output: A = Received Byte
                        ; ******************************************************************************
                        
   F46A   84 FD         SPI_READ	STY	YSAV
   F46C   A0 1D         		LDY	#IFR
   F46E   A9 04         SPI_READ1	LDA	#$04			; set bit mask for data available flag
   F470   31 14         		AND	(IOBASE),Y		; shift register full?
   F472   F0 FA         		BEQ	SPI_READ1		; no, check again
   F474   A0 1A         SPI_RESET	LDY	#SR
   F476   B1 14         		LDA	(IOBASE),Y		; start next shifting, clear data available flag
   F478   A4 FD         		LDY	YSAV
   F47A   60            		RTS
                        
                        ; ******************************************************************************
                        ; SD-Card Driver Routines
                        ; ******************************************************************************
                        
                        ; ******************************************************************************
                        ; Initialize SD-Card
                        ; Output: C = 1 Init OK, C = 0 Error
                        ; ******************************************************************************
                        
   F47B   78            SD_INIT		SEI                             ; disable interrupts
   F47C   A9 00                         LDA	#$00
   F47E   85 DB         		STA	SD_TYPE
   F480   20 F4 F5      		JSR	SD_RESET		; reset SD-Card
   F483   C9 01         		CMP	#$01			; SD-Card present?
   F485   D0 57         		BNE	SDC_NOT_FOUND		; invalid response, no usable card found
   F487   20 E3 F4      		JSR	SD_GET_VERS		; get SD-Card version
   F48A   C9 05         		CMP	#$05			; seems to be a version 1 card
   F48C   F0 08         		BEQ	INIT_SD0		; so just try to initialize it
   F48E   C9 AA         		CMP	#$AA			; version 2 cards should response with $(01)AA
   F490   D0 4C         		BNE	SDC_NOT_FOUND		; invalid response, no usable card found
   F492   A9 40         		LDA	#$40			; try ACMD41($40000000) init (SD Ver. 2+)
   F494   D0 02         		BNE	INIT_SD1
   F496   A9 00         INIT_SD0	LDA	#$00			; try ACMD41($00000000) init (SD Ver. 1)
   F498   20 06 F5      INIT_SD1	JSR	SD_CLEAR_CMD		; prepare for new command
   F49B   85 DF         		STA	SD_PB3
   F49D   A9 77         INIT_SD2	LDA	#CMD55			; send prefix CMD55 (application cmd)
   F49F   20 15 F5      		JSR	SD_SEND_CMD
   F4A2   C9 01         		CMP	#$01
   F4A4   D0 38         		BNE	SDC_NOT_FOUND		; invalid response, no usable card found
   F4A6   A9 69         		LDA	#ACMD41			; send ACMD41 (initialize)
   F4A8   20 15 F5      		JSR	SD_SEND_CMD
   F4AB   F0 06         		BEQ	INIT_SD3		; response = 0 means card waked up,
   F4AD   C9 01         		CMP	#$01			; card still idle?
   F4AF   F0 EC         		BEQ	INIT_SD2		; yes, try again
   F4B1   D0 2B         		BNE	SDC_NOT_FOUND		; no, invalid response, no usable card found
   F4B3   A5 DF         INIT_SD3	LDA	SD_PB3			; Ver. 2+ Card?
   F4B5   F0 13         		BEQ	INIT_SD4		; no, just set block size
   F4B7   20 06 F5      		JSR	SD_CLEAR_CMD		; prepare for new command
   F4BA   A9 7A         		LDA	#CMD58			; send CMD58 (get OCR)
   F4BC   20 15 F5      		JSR	SD_SEND_CMD
   F4BF   D0 1D         		BNE	SDC_NOT_FOUND		; invalid response, no usable card found
   F4C1   20 F8 F4      		JSR	SD_WAIT_RESP3		; wait for OCR response
   F4C4   A5 DF         		LDA	SD_PB3			; Test Bit 30
   F4C6   29 40         		AND	#$40			; 1 if SDHC/SDXC card, 0 else
   F4C8   85 DB         		STA	SD_TYPE			; set type $00 Byte mode, $40 LBA mode
   F4CA   20 06 F5      INIT_SD4	JSR	SD_CLEAR_CMD		; prepare for new command
   F4CD   A9 02         		LDA	#$02			; set blocksize to 512 byte
   F4CF   85 E1         		STA	SD_PB1
   F4D1   A9 50         		LDA	#CMD16			; send CMD16 (set block size)
   F4D3   20 15 F5      		JSR	SD_SEND_CMD
   F4D6   D0 06         		BNE	SDC_NOT_FOUND		; invalid response, no usable card found
   F4D8   20 49 F4      		JSR	SPI_FAST		; and switch to SPI fast mode (500kHz)
   F4DB   58            		CLI                             ; reenable interrupts
   F4DC   38            		SEC				; everything gone well, set carry
   F4DD   60            		RTS
   F4DE   A9 80         SDC_NOT_FOUND	LDA	#$80
   F4E0   58                            CLI                             ; reenable interrupts
   F4E1   18            		CLC				; something went wrong, clear carry
   F4E2   60            		RTS				; to signal error
                        
                        ; ******************************************************************************
                        ; Get SD-Card Version
                        ; ******************************************************************************
                        
   F4E3   A9 01         SD_GET_VERS	LDA	#$01			; set parameter byte 1
   F4E5   85 E1         		STA	SD_PB1
   F4E7   A9 AA         		LDA	#$AA			; set parameter byte 0
   F4E9   85 E2         		STA	SD_PB0
   F4EB   A9 87         		LDA	#$87			; set crc
   F4ED   85 E3         		STA	SD_CRC
   F4EF   A9 48         		LDA	#CMD8			; send CMD8($000001AA) (get version)
   F4F1   20 15 F5      		JSR	SD_SEND_CMD		; response should be $01
   F4F4   C9 01         		CMP	#$01			; SD-Card present?
   F4F6   D0 0D         		BNE	END_GET_VERS		; no, exit with result <> $01
                        						; yes, fall through to sd_wait_resp
                        
                        ; ******************************************************************************
                        ; Wait for a 32 Bit Command R3 Response from SD-Card
                        ; ******************************************************************************
                        
   F4F8   A0 00         SD_WAIT_RESP3	LDY	#$00
   F4FA   20 26 F5      READ_RESP3	JSR	SD_WAIT_RESP		; yes, receive 4 response bytes
   F4FD   99 DF 00      		STA	SD_PB3,Y		; store response bytes in PB0..3
   F500   C8            		INY
   F501   C0 04         		CPY	#$04
   F503   D0 F5         		BNE	READ_RESP3
   F505   60            END_GET_VERS	RTS
                        
                        ; ******************************************************************************
                        ; Clear SD-Card Command Parameters
                        ; ******************************************************************************
                        
   F506   A9 00         SD_CLEAR_CMD	LDA	#$00
   F508   A0 04         		LDY	#$04			; 4 parameter bytes to clear
   F50A   99 DE 00      NEXT_PARAM	STA	SD_CMD,Y		; clear parameter byte
   F50D   88            		DEY
   F50E   D0 FA         		BNE	NEXT_PARAM		; more to clear?
   F510   A9 FF         		LDA	#$FF
   F512   85 E3         		STA	SD_CRC			; no, finally set CRC byte to $FF
   F514   60            		RTS
                        
                        ; ******************************************************************************
                        ; Send Command to SD-Card
                        ; Input: A = Command Index
                        ; ******************************************************************************
                        
   F515   85 DE         SD_SEND_CMD	STA	SD_CMD
   F517   20 6A F4      		JSR	SPI_READ		; send one dummy
   F51A   A2 00         		LDX	#$00
   F51C   B5 DE         SEND_BYTE	LDA	SD_CMD,X		; get one command byte
   F51E   20 50 F4      		JSR	SPI_WRITE		; and send it
   F521   E8            		INX
   F522   E0 06         		CPX	#$06			; all 6 cmd bytes send?
   F524   D0 F6         		BNE	SEND_BYTE		; no, send more bytes
                        						; yes, fall through to sd_wait_resp
                        
                        ; ******************************************************************************
                        ; Wait for a 8 Bit Command R1 Response from SD-Card
                        ; Output: A = Response Byte
                        ; ******************************************************************************
                        
   F526   A2 08         SD_WAIT_RESP	LDX	#$08			; wait for max 8 cycles
   F528   20 6A F4      READ_RESP1	JSR	SPI_READ		; receive data
   F52B   C9 FF         		CMP	#$FF			; is it a $FF?
   F52D   D0 03         		BNE	RESPONSE		; no, card did response
   F52F   CA            		DEX				; yes, try again
   F530   D0 F6         		BNE	READ_RESP1		; check for timeout
   F532   AA            RESPONSE	TAX
   F533   8A            		TXA				; set proper status flags for A
   F534   60            		RTS
                        
                        ; ******************************************************************************
                        ; Wait for a Special Token Response from SD-Card
                        ; Input:  A = Token Byte
                        ; Output: A = Response Byte
                        ; ******************************************************************************
                        
   F535   85 FC         SD_WAIT_TOKEN	STA	TEMP			; store token into TEMP variable
   F537   A0 FF         		LDY	#$FF			; load low byte of time out counter
   F539   A2 0A         		LDX	#$0A			; load high byte of time out counter
   F53B   20 6A F4      WAIT_RESP	JSR	SPI_READ		; read byte from SPI
   F53E   88            		DEY				; decrement wait counter
   F53F   D0 03         		BNE	WAIT_RESP0
   F541   CA            		DEX
   F542   F0 04         		BEQ	WAIT_RESP_END		; wait counter is 0 -> time out
   F544   C5 FC         WAIT_RESP0	CMP	TEMP			; did we read the token we are waiting for?
   F546   D0 F3         		BNE	WAIT_RESP		; no, read next byte
   F548   60            WAIT_RESP_END	RTS
                        
                        ; ******************************************************************************
                        ; Read Single Data Block to Std. Block Buffer
                        ; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
                        ; Output: C = 0 Error, C = 1 Read OK
                        ;	  A = Error Code
                        ; ******************************************************************************
                        
   F549   20 9E F6      SD_RD_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   F54C   F0 06         		BEQ	SD_RD_BLK
                        
                        ; ******************************************************************************
                        ; Read Single Data Block from Logical Address to Std. Block Buffer
                        ; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
                        ; Output: C = 0 Error, C = 1 Data OK
                        ;	  A = Error Code
                        ; ******************************************************************************
                        
   F54E   20 9E F6      SD_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
                        						; fall through to sd_rd_lblk
                        
                        ; ******************************************************************************
                        ; Read Single Data Block from Logical Address
                        ; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
                        ;	  BLKBUF,BLKBUFH = 16 Bit Destination Address
                        ; Output: C = 0 Error, C = 1 Data OK
                        ;	  A = Error Code
                        ; ******************************************************************************
                        
   F551   20 A7 F6      SD_RD_LBLK	JSR	LOAD_LBA		; convert LBA CMD ADR
                        						; fall through to sd_rd_blk
                        
                        ; ******************************************************************************
                        ; Read Single Data Block
                        ; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
                        ;         BLKBUF,BLKBUFH = 16 Bit Destination Address
                        ; Output: C = 0 Error, C = 1 Read OK
                        ;	  A = Error Code
                        ; ******************************************************************************
                        
   F554   A9 51         SD_RD_BLK	LDA	#CMD17			; send CMD17 (blk read)
   F556   20 D5 F5      		JSR	SD_SEND_BLK_CMD
   F559   20 35 F5      		JSR	SD_WAIT_TOKEN		; wait for data token $FE
   F55C   C9 FE         		CMP	#$FE			; is card ready for block read?
   F55E   18            		CLC
   F55F   D0 1F         		BNE	SD_RD_END		; did not receive data token, exit with C = 0
   F561   A2 01         		LDX	#$01			; initialize page counter
   F563   A0 00         		LDY	#$00			; initialize byte counter
   F565   84 FD         SD_RD_BLK0	STY	YSAV			; read a byte
   F567   A0 1A         		LDY 	#SR
   F569   B1 14         		LDA	(IOBASE),Y
   F56B   A4 FD         		LDY	YSAV
   F56D   91 DC         		STA	(BLKBUF),Y		; and store it into the block buffer
   F56F   C8            		INY				; increment destination pointer
   F570   D0 F3         		BNE	SD_RD_BLK0		; pointer overflow? No, read next byte
   F572   E6 DD         		INC	BLKBUFH			; yes, increment block buffer page
   F574   CA            		DEX
   F575   10 EE         		BPL	SD_RD_BLK0		; two pages read? no, read next byte
   F577   20 6A F4      SD_RD_BLK1	JSR	SPI_READ		; yes, read 3 more bytes (CRC H, CRC L, dummy)
   F57A   C8            		INY
   F57B   C0 03         		CPY	#$03			; all 3 bytes read?
   F57D   D0 F8         		BNE	SD_RD_BLK1		; no, read next byte
   F57F   38            		SEC				; yes, all data read, set C = 1
   F580   60            SD_RD_END	RTS
                        
                        ; ******************************************************************************
                        ; Write Single Data Block from Std. Block Buffer
                        ; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Destination Address
                        ; Output: C = 0 Error, C = 1 Read OK
                        ;	  A = Error Code
                        ; ******************************************************************************
                        
   F581   20 9E F6      SD_WR_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   F584   F0 06         		BEQ	SD_WR_BLK
                        
                        ; ******************************************************************************
                        ; Write Single Data Block from Std. Block Buffer to Logical Address
                        ; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
                        ; Output: C = 0 Error, C = 1 Data OK
                        ;	  A = Error Code
                        ; ******************************************************************************
                        
   F586   20 9E F6      SD_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
                        						; fall through to sd_rd_lblk
                        
                        ; ******************************************************************************
                        ; Write Single Data Block to Logical Address
                        ; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
                        ;	  BLKBUF,BLKBUFH = 16 Bit Source Address
                        ; Output: C = 0 Error, C = 1 Data OK
                        ;	  A = Error Code
                        ; ******************************************************************************
                        
   F589   20 A7 F6      SD_WR_LBLK	JSR	LOAD_LBA		; convert LBA CMD ADR
                        						; fall through to sd_rd_blk
                        
                        ; ******************************************************************************
                        ; Write Single Data Block
                        ; Input:  SD_PB3..SD_PB0 = 32 Bit CommandBlock Destination Address
                        ;	  BLKBUF,BLKBUFH = 16 Bit Source Address
                        ; Output: C = 0 Error, C = 1 Write OK
                        ;	  A = Error Code
                        ; ******************************************************************************
                        
   F58C   A9 58         SD_WR_BLK	LDA	#CMD24			; send CMD24 (blk write)
   F58E   20 D5 F5      		JSR	SD_SEND_BLK_CMD
   F591   20 50 F4      		JSR	SPI_WRITE		; write data token
   F594   A2 01         		LDX	#1			; initialize page counter
   F596   86 FD         		STX	YSAV
   F598   CA            		DEX				; initialize byte counter
   F599   8A            SD_WR_BLK0	TXA
   F59A   A8            		TAY
   F59B   B1 DC         		LDA	(BLKBUF),Y		; read next byte from buffer
   F59D   A0 11         		LDY	#PORTA			; and write it to the card
   F59F   91 14         		STA	(IOBASE),Y		; output data to shift register
   F5A1   88            		DEY				; set for PORTB
   F5A2   A9 42         		LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
   F5A4   91 14         		STA	(IOBASE),Y		; load data into shift register
   F5A6   A9 4A         		LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
   F5A8   91 14         		STA	(IOBASE),Y		; data is now in shift register
   F5AA   A0 1A         		LDY 	#SR
   F5AC   B1 14         		LDA	(IOBASE),Y		; and start clk'ing
   F5AE   E8            		INX				; increment source pointer
   F5AF   D0 E8         		BNE	SD_WR_BLK0		; pointer overflow? No, write next byte
   F5B1   E6 DD         		INC	BLKBUFH			; yes, increment block buffer page
   F5B3   C6 FD         		DEC	YSAV
   F5B5   10 E2         		BPL	SD_WR_BLK0		; two pages written? no, write next byte
   F5B7   20 6A F4      		JSR	SPI_READ		; yes, send a (dummy) CRC ($FFFF)
   F5BA   20 6A F4      		JSR	SPI_READ
   F5BD   20 6A F4      		JSR	SPI_READ		; read one dummy byte
   F5C0   20 6A F4      		JSR	SPI_READ		; read response byte
   F5C3   48                            PHA                             ; and save it onto the stack
   F5C4   20 6A F4      SD_WR_BUSY?	JSR	SPI_READ		; read next byte
   F5C7   C9 00         		CMP	#0
   F5C9   F0 F9         		BEQ	SD_WR_BUSY?		; check if busy ($00)
   F5CB   68            		PLA
   F5CC   29 1F         		AND	#$1F			; mask result bits
   F5CE   C9 05         		CMP	#$05			; data accepted?
   F5D0   18            		CLC
   F5D1   D0 01         		BNE	SD_WR_END		; no, exit with C = 0
   F5D3   38            		SEC				; yes, exit with C = 1
   F5D4   60            SD_WR_END	RTS
                        
                        ; ******************************************************************************
                        ; Send Block Read or Write Command
                        ; Input :  A = Command (CMD17,CMD24)
                        ; Output : A = Data Token
                        ; ******************************************************************************
                        
   F5D5   20 15 F5      SD_SEND_BLK_CMD	JSR	SD_SEND_CMD
   F5D8   D0 03         		BNE	SD_RESP_ERR		; response <> 0 check error type
   F5DA   A9 FE         		LDA	#DATA_TOKEN
   F5DC   60            		RTS
                        
                        ; ******************************************************************************
                        ; Check Error
                        ; ******************************************************************************
                        
   F5DD   29 01         SD_RESP_ERR	AND	#$01			; is card in idle mode?
   F5DF   F0 0B         		BEQ	SD_DISK_RW		; no, print error
   F5E1   20 39 F4      		JSR	SPI_SLOW		; set SPI slow mode
   F5E4   20 7B F4      		JSR	SD_INIT			; yes, maybe card changed, reset
   F5E7   B0 07         		BCS	SD_DISK_CHNG
   F5E9   A9 80         SD_NO_DISK	LDA	#$80
   F5EB   60            		RTS
   F5EC   A9 81         SD_DISK_RW	LDA	#$81
   F5EE   18            		CLC
   F5EF   60            		RTS
   F5F0   A9 82         SD_DISK_CHNG	LDA	#$82
   F5F2   18            		CLC
   F5F3   60            		RTS
                        
                        ; ******************************************************************************
                        ; Reset SD-Card
                        ; ******************************************************************************
                        
   F5F4   20 06 F5      SD_RESET	JSR	SD_CLEAR_CMD		; clear command parameters
   F5F7   A9 95         		LDA	#$95
   F5F9   85 E3         		STA	SD_CRC			; and set crc to $95 for CMD0
   F5FB   20 12 F6      		JSR	SD_PREPARE		; send dummy sequence to SD-Card
   F5FE   D0 0A         		BNE	RESET_SDC		; is MISO line high?
   F600   A9 40         		LDA	#CMD0			; no, send CMD0 (reset) to SD-Card
   F602   20 15 F5      		JSR	SD_SEND_CMD
   F605   20 12 F6      		JSR	SD_PREPARE		; send init dummy sequence again
   F608   F0 05         		BEQ	END_SD_RESET		; MISO still low? Exit with A = $FF
   F60A   A9 40         RESET_SDC	LDA	#CMD0			; send CMD0 (reset) to SD-Card
   F60C   4C 15 F5      		JMP	SD_SEND_CMD		; response should be $01
                        
   F60F   A9 FF         END_SD_RESET	LDA	#$FF			; reset failed
   F611   60            		RTS
                        
                        ; **** Prepare SD-Card for Communication ***************************************
                        ;
                        ; ******************************************************************************
                        
   F612   20 39 F4      SD_PREPARE	JSR	SPI_SLOW		; set SPI slow mode
   F615   A0 10         		LDY	#PORTB			; initialize VIA Port B
   F617   A9 4E         		LDA	#$4E			; set /SPI_CS = H and /SPI_LOAD = H
   F619   91 14         		STA	(IOBASE),Y
   F61B   A2 0A         		LDX	#10			; first send 80 clocks to SD-Card
   F61D   20 6A F4      SEND_CLOCK	JSR	SPI_READ		; send 8 clock cycles
   F620   CA            		DEX
   F621   D0 FA         		BNE	SEND_CLOCK		; send more clock cycles
   F623   AA            		TAX
   F624   A0 1D         		LDY	#IFR
   F626   A9 04         SD_PREPARE1	LDA	#$04
   F628   31 14         		AND	(IOBASE),Y
   F62A   F0 FA         		BEQ	SD_PREPARE1
   F62C   A0 10         		LDY	#PORTB
   F62E   A9 4A         		LDA	#$4A			; set /SPI_CS = L and /SPI_LOAD = H
   F630   91 14         		STA	(IOBASE),Y
   F632   8A            		TXA				; set proper status flags
   F633   60            SD_END		RTS
                        
                        ; **** SD-Card Boot Routine ****************************************************
                        ;
                        ; ******************************************************************************
                        
   F634   20 06 F5      SD_BOOT         JSR	SD_CLEAR_CMD
   F637   20 49 F5      		JSR	SD_RD_BLK_BUF           ; read MBR
   F63A   90 F7                         BCC     SD_END                  ; error reading MBR. Exit
   F63C   20 01 F7                      JSR     SYS_MBR_ID              ; check boot block ID tag
   F63F   90 F2                         BCC     SD_END                  ; error, wrong ID. Exit
   F641   AD BC 07                      LDA     PART0-2                 ; check if partition ID1 is $65
   F644   C9 65                         CMP     #$65
   F646   D0 20                         BNE     LOAD_PART0              ; no, just load partition 0
   F648   AD BD 07                      LDA     PART0-1                 ; check if partition ID2 is $02
   F64B   C9 02                         CMP     #$02
   F64D   D0 19                         BNE     LOAD_PART0              ; no, just load partition 0
   F64F   20 00 06                      JSR     MBR                     ; partition ID $65 $02 found. Call MBR code
   F652   D0 02                         BNE     LOAD_PART1              ; is boot menu result 1,2,3, or 4 ?
   F654   18                            CLC                             ; no, ESC pressed or no valid partition found
   F655   60                            RTS                             ; abort booting from SD-Card
                        
   F656   CA            LOAD_PART1      DEX                             ; set result to 0,1,2 or 3
   F657   8A                            TXA                             ; transfer result to Accu
   F658   A8                            TAY                             ; and to Y-Register
   F659   0A                            ASL     A                       ; multiply result by 16
   F65A   0A                            ASL     A
   F65B   0A                            ASL     A
   F65C   0A                            ASL     A
   F65D   09 08                         ORA     #$08                    ; and add 8
   F65F   AA                            TAX                             ; move partition table index into X
   F660   98                            TYA
   F661   18                            CLC
   F662   69 31                         ADC     #49                     ; convert partition number to ASCII char (+1)
   F664   85 EE                         STA     PSAV                    ; and store it to PSAV
   F666   D0 0B                         BNE     LOAD_PART               ; branch always
   F668   A2 08         LOAD_PART0      LDX     #$08                    ; for partition 0 the table index is 8
   F66A   A9 31                         LDA     #'1'                    ; partition 0 number as ASCII char (+1)
   F66C   85 EE                         STA     PSAV                    ; store it in PSAV
   F66E   AD BE 07                      LDA     PART0                   ; read boot indicator
   F671   F0 7F                         BEQ     SYS_MSG_ERR             ; if $00 then exit
   F673   A0 08         LOAD_PART       LDY     #$08
   F675   BD C6 07      SD_BOOT1        LDA     PART0_RS,X              ; load partition start and length
   F678   99 00 04                      STA     BOOT_PART,Y             ; and save it to boot device descriptor
   F67B   CA                            DEX
   F67C   88                            DEY
   F67D   10 F6                         BPL     SD_BOOT1
   F67F   A2 00                         LDX	#LOW  BOOT_PART         ; read partition boot blk ptr
   F681   A0 04         		LDY	#HIGH BOOT_PART
   F683   20 FA F6      		JSR     SYS_LD_BOOTBLK          ; load partition boot block
   F686   90 AB                         BCC     SD_END                  ; block not found. Exit
   F688   20 13 F7                      JSR     SYS_CHECK_OS            ; check OS OEM string
   F68B   90 A6                         BCC     SD_END                  ; wrong OEM string. Exit
   F68D   A0 45                         LDY     #SDCDEV-STRINGP2        ; load pointer to device name
   F68F   20 EC F6                      JSR     SYS_MSG                 ; print device name to screen
   F692   A9 5F                         LDA     #'_'
   F694   20 52 E0                      JSR     COUT
   F697   A5 EE                         LDA     PSAV                    ; add partition number to name (_1.._4)
   F699   20 52 E0                      JSR     COUT
   F69C   38                            SEC                             ; normal boot, set carry flag
   F69D   60                            RTS
                        
                        ; ******************************************************************************
                        ; Initialize Block Buffer Pointer
                        ; ******************************************************************************
                        
   F69E   A9 06         INIT_BLKBUF	LDA	#HIGH BLOCK_BUF         ; set pointer to standard block buffer
   F6A0   85 DD         		STA	BLKBUFH
   F6A2   A9 00         		LDA	#$00
   F6A4   85 DC         		STA	BLKBUF
   F6A6   60            		RTS
                        
                        ; ******************************************************************************
                        ; Load Logical Block Address into Command Address.
                        ; Swap Endian and Shift Bits if Desired
                        ; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Address
                        ; Output: ADR in SD_PB3..SD_PB0
                        ; ******************************************************************************
                        
   F6A7   86 E6         LOAD_LBA	STX	PLBAL
   F6A9   84 E7         		STY	PLBAH
   F6AB   A2 04         		LDX	#$04
   F6AD   A0 00         		LDY	#$00
   F6AF   A5 DB         		LDA	SD_TYPE
   F6B1   D0 0F         		BNE	BLK_MODE
   F6B3   18            		CLC
   F6B4   98            		TYA
   F6B5   95 DE                         STA	SD_CMD,X
   F6B7   CA            		DEX
   F6B8   B1 E6         BIT_MODE	LDA	(PLBA),Y
   F6BA   2A            		ROL	A
   F6BB   95 DE                         STA	SD_CMD,X
   F6BD   C8            		INY
   F6BE   CA            		DEX
   F6BF   D0 F7         		BNE	BIT_MODE
   F6C1   60            		RTS
   F6C2   B1 E6         BLK_MODE	LDA	(PLBA),Y
   F6C4   95 DE         		STA	SD_CMD,X
   F6C6   C8            		INY
   F6C7   CA            		DEX
   F6C8   D0 F8         		BNE	BLK_MODE
   F6CA   60            		RTS
                        
                        ; ******************************************************************************
                        ; Boot Routines
                        ; ******************************************************************************
                        
                        ; **** Main Boot Routine *******************************************************
                        ;
                        ; Find first bootable device
                        ; Output : C = 0 No Boot Device Found
                        ;          C = 1 Boot Device Found. Boot Code at $0600 Available
                        ;
                        ; ******************************************************************************
                        
   F6CB   A0 20         SYS_BOOT        LDY     #STORAGE_DEV            ; boot from storage device only
   F6CD   84 F4         SYS_BOOT1       STY     YREG
   F6CF   98                            TYA
   F6D0   20 D1 F7                      JSR     DEV_OPEN                ; open device descriptor
   F6D3   90 0E                         BCC     SYS_BOOT2               ; device not found, try next one
   F6D5   A9 00                         LDA     #CMD_INIT
   F6D7   20 BA E0                      JSR     CMDDEV                  ; initialize device
   F6DA   90 07                         BCC     SYS_BOOT2               ; could not initialize, try next one
   F6DC   A9 24                         LDA     #CMD_BOOT
   F6DE   20 BA E0                      JSR     CMDDEV                  ; can we boot from device?
   F6E1   B0 11                         BCS     SYS_BOOT_END            ; yes, exit
   F6E3   A4 F4         SYS_BOOT2       LDY     YREG                    ; no, try next device
   F6E5   C8                            INY
   F6E6   C0 2F                         CPY     #$2F                    ; all devices checked?
   F6E8   D0 E3                         BNE     SYS_BOOT1               ; no, try next one
   F6EA   A0 30                         LDY     #NOBOOTDEV-STRINGP2     ; yes, no boot device found
                        
                        ; ***** Show System Message ****************************************************
                        ;
                        ; Input:  Y - Index To Message String
                        ; Output: C = 0
                        ;
                        ; ******************************************************************************
                        
   F6EC   20 49 E5      SYS_MSG         JSR     LOADSTRING2
   F6EF   20 85 E0                      JSR  	WRSTR                   ; show error message
   F6F2   18            SYS_MSG_ERR     CLC
   F6F3   60            SYS_MSG_END     RTS
                        
                        ; ***** Finalize Boot Procedure ************************************************
                        
   F6F4   A9 B0         SYS_BOOT_END    LDA     #$B0                    ; boot block could be loaded
   F6F6   8D 00 06                      STA     $0600                   ; modify jump opcode in boot block into BCS
   F6F9   60                            RTS
                        
                        ; ***** Load Boot Block From Device ********************************************
                        ;
                        ; Input:  X - Pointer to Boot Block Low Address
                        ;         Y - Pointer to Boot Block High Address
                        ; Output: C = 0 No Boot Block Found
                        ;         C = 1 Boot Block Loaded at $0600
                        ;
                        ; ******************************************************************************
                        
   F6FA   A9 25         SYS_LD_BOOTBLK  LDA     #CMD_READ_BUF
   F6FC   20 BA E0                      JSR     CMDDEV                   ; load master boot block
   F6FF   90 10                         BCC     SYS_TAG_ERR
                        
                        ; ***** Check Boot Block ID Tag ($55 $AA) **************************************
                        ;
                        ; Output: C = 0 No Boot Block Tag Found
                        ;         C = 1 Boot Block Tag Found
                        ;
                        ; ******************************************************************************
                        
   F701   AD FE 07      SYS_MBR_ID      LDA     BOOTBLK_TAG             ; check boot block ID tag
   F704   C9 55                         CMP     #$55
   F706   D0 09                         BNE     SYS_TAG_ERR
   F708   AD FF 07                      LDA     BOOTBLK_TAG+1
   F70B   C9 AA                         CMP     #$AA
   F70D   D0 02                         BNE     SYS_TAG_ERR
   F70F   38                            SEC
   F710   60                            RTS
   F711   18            SYS_TAG_ERR     CLC
   F712   60                            RTS
                        
                        ; ***** Check OS OEM String ****************************************************
                        ;
                        ; Output: C = 0 OS OEM String Not Found
                        ;         C = 1 OS OEM String Found
                        ;
                        ; ******************************************************************************
                        
   F713   A2 04         SYS_CHECK_OS    LDX     #04                     ; check four characters of OEM string
   F715   BD 7A E8      SYS_ID_LOOP     LDA     OSID-1,X
   F718   DD 02 06                      CMP     BLOCK_BUF+2,X
   F71B   18                            CLC
   F71C   D0 09                         BNE     SYS_CHECK_END           ; wrong OEM string
   F71E   CA                            DEX
   F71F   D0 F4                         BNE     SYS_ID_LOOP             ; more charactrs to check
   F721   A0 20                         LDY     #BOOTDEV-STRINGP2
   F723   20 EC F6      SYS_BOOTMSG     JSR     SYS_MSG                 ; write boot message
   F726   38                            SEC
   F727   60            SYS_CHECK_END   RTS
                        
                        ; ******************************************************************************
                        ; Miscellanious Routines
                        ; ******************************************************************************
                        
                        ; **** Read Joystick Port ******************************************************
                        
                        ; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
                        ;         X - vertical joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
                        ;         Y - horizontal joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
                        
                        ; ******************************************************************************
                        
   F728   A5 17         READ_JOY_PORT   LDA     FGCBASEH
   F72A   F0 47                         BEQ     NO_JOY_PORT             ; check if Floppy-/Graphisc-Controller installed
   F72C   A0 0D                         LDY     #PIA_PORTB
   F72E   B1 16                         LDA     (FGCBASE),Y             ; yes, read joystick port
   F730   A2 00         DECODE_JOY_PORT LDX     #$00                    ; preset x position to CENTER
   F732   A0 00                         LDY     #$00                    ; preset y position to CENTER
   F734   86 FC                         STX     TEMP                    ; clear temp value
   F736   4A            JP_UP           LSR     A                       ; get /UP flag
   F737   B0 06                         BCS     JP_DOWN                 ; not set, check DOWN position
   F739   A0 FF                         LDY     #$FF                    ; set y position to -1 (UP)
   F73B   4A                            LSR     A                       ; skip DOWN bit
   F73C   4C 44 F7                      JMP     JP_LEFT                 ; and test x position
   F73F   4A            JP_DOWN         LSR     A                       ; get /DOWN flag
   F740   B0 02                         BCS     JP_LEFT                 ; not set, test x position
   F742   A0 01                         LDY     #$01                    ; set y position to 1 (DOWN)
   F744   4A            JP_LEFT         LSR     A                       ; get /LEFT flag
   F745   B0 06                         BCS     JP_RIGHT                ; not set, check RIGHT position
   F747   A2 FF                         LDX     #$FF                    ; set x position to -1 (UP)
   F749   4A                            LSR     A                       ; skip RIGHT bit
   F74A   4C 52 F7                      JMP     JP_BUTTON3              ; and test button 3
   F74D   4A            JP_RIGHT        LSR     A                       ; get /RIGHT flag
   F74E   B0 02                         BCS     JP_BUTTON3              ; not set, test button 3
   F750   A2 01                         LDX     #$01                    ; set x position to 1 (RIGHT)
   F752   4A            JP_BUTTON3      LSR     A                       ; get /BUTTON3 flag
   F753   B0 06                         BCS     JP_BUTTON1              ; not set, test button 1
   F755   48                            PHA                             ; save joystick port value
   F756   A9 04                         LDA     #$04
   F758   85 FC                         STA     TEMP                    ; set bit 2 of temp button result
   F75A   68                            PLA                             ; restore joystick port value
   F75B   4A            JP_BUTTON1      LSR     A                       ; get /BUTTON1 flag
   F75C   B0 08                         BCS     JP_BUTTON2              ; not set, test button 2
   F75E   48                            PHA                             ; save joystick port value
   F75F   A9 01                         LDA     #$01
   F761   05 FC                         ORA     TEMP
   F763   85 FC                         STA     TEMP                    ; set bit 0 of temp button result
   F765   68                            PLA                             ; restore joystick port value
   F766   4A            JP_BUTTON2      LSR     A                       ; get /BUTTON2 flag
   F767   B0 06                         BCS     END_JOY_PORT            ; not set, exit
   F769   A9 02                         LDA     #$02
   F76B   05 FC                         ORA     TEMP
   F76D   85 FC                         STA     TEMP                    ; set bit 1 of temp button result
   F76F   A5 FC         END_JOY_PORT    LDA     TEMP                    ; load temp button result into A
   F771   38                            SEC                             ; data valid
   F772   60                            RTS
   F773   AA            NO_JOY_PORT     TAX                             ; no joystick port available, clear X
   F774   A8                            TAY                             ; and Y
   F775   18                            CLC                             ; no joystick port available, data invalid
   F776   60                            RTS
                        
                        ; ******************************************************************************
                        ; Device Driver Routines
                        ; ******************************************************************************
                        
                        ; **** Initialize Device Driver List *******************************************
                        ;
                        ; ******************************************************************************
                        
   F777   A0 3E         DEV_INIT	LDY	#$3E                    ; clear entire list
   F779   A9 00                         LDA     #$00                    ; and fill it with zeros
   F77B   99 28 1A      DEV_INIT1       STA     DEVLIST,Y
   F77E   88                            DEY
   F77F   10 FA         		BPL	DEV_INIT1
   F781   60            END_DEV_INIT	RTS
                        
                        ; **** Add Device Driver *******************************************************
                        ;
                        ; Input  - X : Driver Descriptor Address Low Byte
                        ;          Y : Driver Descriptor Address High Byte
                        ; Output - C = 1 Success, C = 0 Error
                        ;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
                        ;
                        ; ******************************************************************************
                        
   F782   86 DE         DEV_ADD		STX	PDEVL
   F784   84 DF         		STY	PDEVH
   F786   A0 00         		LDY	#$00
   F788   B1 DE         		LDA	(PDEV),Y                ; load device ID into A
   F78A   85 FC         		STA     TEMP
   F78C   20 C5 F7                      JSR     DEV_CHECK
   F78F   90 2F                         BCC     END_DEV_ADD
   F791   4A                            LSR     A
   F792   29 0F                         AND     #$0F
   F794   C9 0F                         CMP     #$0F
   F796   D0 14                         BNE     ADD_DEV
   F798   98            FIND_FREE_DEV   TYA
   F799   29 E0                         AND     #$E0
   F79B   A8                            TAY
   F79C   A2 00                         LDX     #$00
   F79E   B9 08 1A      FIND_NEXT_DEV   LDA     DEVLIST-$20,Y
   F7A1   F0 0A                         BEQ     ADD_DEV1
   F7A3   C8                            INY
   F7A4   C8                            INY
   F7A5   E8                            INX
   F7A6   E0 0F                         CPX     #$0F
   F7A8   90 F4                         BCC     FIND_NEXT_DEV
   F7AA   18                            CLC
   F7AB   60                            RTS
   F7AC   AA            ADD_DEV         TAX
   F7AD   A5 DE         ADD_DEV1        LDA     PDEVL
   F7AF   99 08 1A                      STA     DEVLIST-$20,Y
   F7B2   A5 DF                         LDA     PDEVH
   F7B4   99 09 1A                      STA     DEVLIST-$1F,Y
   F7B7   A5 FC                         LDA     TEMP
   F7B9   29 F0                         AND     #$F0
   F7BB   86 FC                         STX     TEMP
   F7BD   05 FC                         ORA     TEMP
   F7BF   38                            SEC
   F7C0   60            END_DEV_ADD     RTS
                        
   F7C1   A2 FF         DEV_ERR         LDX     #$FF
   F7C3   18                            CLC
   F7C4   60                           	RTS
                        
   F7C5   C9 30         DEV_CHECK       CMP     #STORAGE_DEV+$10
   F7C7   B0 F8         		BCS     DEV_ERR
   F7C9   C9 10         		CMP     #COM_DEV
   F7CB   90 F4                         BCC     DEV_ERR
   F7CD   0A                            ASL     A
   F7CE   A8                            TAY
   F7CF   38                            SEC
   F7D0   60                            RTS
                        
                        ; **** Open Device Driver ******************************************************
                        ;
                        ; Input  - A : Device ID
                        ; Output - C = 1 Success, C = 0 Error
                        ;          X : Descriptor Address Low Byte
                        ;          Y : Descriptor Address High Byte
                        ;
                        ; ******************************************************************************
                        
   F7D1   20 C5 F7      DEV_OPEN        JSR     DEV_CHECK
   F7D4   90 26                         BCC     END_DEV_OPEN
   F7D6   B9 08 1A                      LDA     DEVLIST-$20,Y
   F7D9   D0 02                         BNE     DEV_OPEN1
   F7DB   A9 80                         LDA	#LOW NULL_DEV   ; no device found use NULL device
   F7DD   85 DE         DEV_OPEN1       STA     PDEVL
   F7DF   B9 09 1A                      LDA     DEVLIST-$1F,Y
   F7E2   D0 02                         BNE     DEV_OPEN2
   F7E4   A9 F9                         LDA	#HIGH NULL_DEV  ; no device found use NULL device
   F7E6   85 DF         DEV_OPEN2       STA     PDEVH
   F7E8   A0 02         		LDY	#$02
   F7EA   A2 00         		LDX	#$00
   F7EC   B1 DE         DEV_OPEN3	LDA	(PDEV),Y
   F7EE   9D 68 1A      		STA	DEVIN,X
   F7F1   C8            		INY
   F7F2   E8            		INX
   F7F3   E0 06         		CPX	#$06
   F7F5   D0 F5         		BNE	DEV_OPEN3
   F7F7   A6 DE         		LDX	PDEVL
   F7F9   A4 DF         		LDY	PDEVH
   F7FB   38            		SEC
   F7FC   60            END_DEV_OPEN    RTS
                        
                        ; ******************************************************************************
                        ; Standard Driver Command Routines
                        ; ******************************************************************************
                        
                        ; ******************************************************************************
                        ; XModem Command Interpreter
                        ; ******************************************************************************
                        
   F7FD   C9 20         XMODEM_CMD	CMP	#CMD_LOAD
   F7FF   D0 03         		BNE	XM_SAVE
   F801   4C 12 F0      		JMP	XModemRcv
   F804   C9 21         XM_SAVE  	CMP	#CMD_SAVE
   F806   D0 45         		BNE     COM_CMD
   F808   4C 03 F1      		JMP	XModemSnd
                        
                        ; ******************************************************************************
                        ; Tape Device Command Interpreter
                        ; ******************************************************************************
                        
   F80B   C9 20         TAPE_CMD	CMP	#CMD_LOAD
   F80D   D0 03         		BNE	TP_SAVE
   F80F   4C 50 ED      		JMP	TAPELOAD
   F812   C9 21         TP_SAVE 	CMP	#CMD_SAVE
   F814   D0 37         		BNE     COM_CMD
   F816   4C 72 EE      		JMP	TAPESAVE
                        
                        ; ******************************************************************************
                        ; XSD_Card Command Interpreter
                        ; ******************************************************************************
                        
   F819   C9 00         SDC_CMD         CMP     #CMD_INIT
   F81B   D0 03                         BNE     SDC_READ
   F81D   4C 7B F4                      JMP     SD_INIT
   F820   C9 22         SDC_READ        CMP     #CMD_READ
   F822   D0 03                         BNE     SDC_WRITE
   F824   4C 51 F5                      JMP     SD_RD_LBLK
   F827   C9 23         SDC_WRITE       CMP     #CMD_WRITE
   F829   D0 03                         BNE     SDC_RD_BUF
   F82B   4C 89 F5                      JMP     SD_WR_LBLK
   F82E   C9 25         SDC_RD_BUF      CMP     #CMD_READ_BUF
   F830   D0 03                         BNE     SDC_WR_BUF
   F832   4C 4E F5                      JMP     SD_RD_LBLK_BUF
   F835   C9 26         SDC_WR_BUF      CMP     #CMD_WRITE_BUF
   F837   D0 03                         BNE     SDC_SETADR
   F839   4C 86 F5                      JMP     SD_WR_LBLK_BUF
   F83C   C9 10         SDC_SETADR      CMP     #CMD_SETSTARTADR
   F83E   D0 06                         BNE     SDC_BOOT
   F840   86 DC                         STX     BLKBUFL
   F842   84 DD                         STY     BLKBUFH
   F844   38                            SEC
   F845   60                            RTS
   F846   C9 24         SDC_BOOT        CMP     #CMD_BOOT
   F848   D0 17                         BNE     _EMPTY_
   F84A   4C 34 F6                      JMP     SD_BOOT
                        
                        ; ******************************************************************************
                        ; Common Command Interpreter
                        ; ******************************************************************************
                        
   F84D   C9 10         COM_CMD	        CMP	#CMD_SETSTARTADR
   F84F   D0 06         		BNE     COM_SETENDADR
   F851   86 FA         		STX	ADRL
   F853   84 FB         		STY	ADRH
   F855   38            		SEC
   F856   60            		RTS
   F857   C9 11         COM_SETENDADR	CMP	#CMD_SETENDADR
   F859   D0 06                         BNE     _EMPTY_
   F85B   86 F8         		STX	NUML
   F85D   84 F9         		STY	NUMH
   F85F   38            		SEC
   F860   60            		RTS
                        
                        ; EMPTY Command Handler ********************************************************
                        
   F861   18            _EMPTY_         CLC
   F862   60            _HANDLER_       RTS
                        
                        ; Command Handler For Floppy Drive 2 *******************************************
                        
   F863   09 80         FGC_FDC_CMD2    ORA     #$80            ; set bit 7 of command byte (drive 2 operation)
   F865   4C 17 10                      JMP     FGC_FDC_CMD     ; call command handler
                        
                        ; **** Floppy IRQ Routine ******************************************************
                        
                        ; ******************************************************************************
   F948                                 ORG     $F948
                        
   F948   48            MOTOR_IRQ       PHA
                                        ;LDA     FDC_OPT_REG     ; load option register
                                        ;AND     $04             ; watch dog interrupt pending?
                                        ;BEQ     VPU_IRQ         ; no, check VPU IRQ
                                        ;LDA     FDC_MOTOR1_REG  ; yes, clear interrupts
                                        ;LDA     FDC_MOTOR2_REG  ; by reading the motor registers
                        
                                        ;LDA     #$0C
                                        ;STA     FDC_OPT_REG     ; all motors off
                                        ;LDA     #$00
                                        ;STA     FDC_MOTOR       ; save current motor status
                                        ;PLA
                                        ;RTI
                        
                        ; **** VPU IRQ Routine *********************************************************
                        
                        ; ******************************************************************************
                        
   F949   A9 00         VPU_IRQ         LDA     #VPU_STAT0
   F94B   8D 09 10                      STA     VPU_PORT1
   F94E   A9 8F                         LDA     #VPU_REG15
   F950   8D 09 10                      STA     VPU_PORT1
   F953   AD 09 10                      LDA     VPU_PORT1       ; is it a line interrupt?
   F956   10 08                         BPL     NO_VPU_IRQ      ; no, exit
   F958   A5 DA                         LDA     TICKCNT         ; yes, load the tick counter
   F95A   F0 02         		BEQ     IRQ_END         ; is it 0?
   F95C   C6 DA         		DEC     TICKCNT         ; no, decrement tick counter
   F95E   68            IRQ_END         PLA
   F95F   40                            RTI
   F960   68            NO_VPU_IRQ	PLA			; restore accumulator
   F961   4C 15 F3      		JMP	IRQ		; call user interrupt routine
                        
                        ; ******************************************************************************
                        ; Standard Driver Descriptors
                        ; ******************************************************************************
                        
   F980                                 ORG     $FA00-16*8
                        
   F980   00 00         NULL_DEV	DB	NULL_ID, $00     ; Null Device Driver Descriptor
   F982   61 F8         		DW	_EMPTY_
   F984   61 F8         		DW	_EMPTY_
   F986   61 F8         		DW	_EMPTY_
                        
   F988   10 00         TTY_DEV		DB	TTY1_ID, $00     ; Terminal Driver Descriptor
   F98A   88 F3         		DW	SERIALIN
   F98C   62 F3         		DW	TTY_OUT          ; redirected call to SERIALOUT
   F98E   E2 E1         		DW	TTY_CMD
                        
   F990   11 00         PPRINT_DEV	DB	PRINTER1_ID, $00 ; Parallel Printer Driver Descriptor
   F992   61 F8         		DW	_EMPTY_
   F994   E5 F3         		DW	PPORTOUT
   F996   61 F8         		DW	_EMPTY_
                        
   F998   13 00         KEYBD_DEV       DB	KEYBD1_ID, $00   ; ASCII Keyboard Driver Descriptor
   F99A   95 F3         		DW	ASCIIKBD
   F99C   61 F8         		DW	_EMPTY_
   F99E   61 F8         		DW	_EMPTY_
                        
   F9A0   15 00         VDP_DEV         DB	VDP1_ID, $00     ; Video Display Processor Driver Descriptor
   F9A2   AD F3         		DW      PS2KBD
   F9A4   27 10                         DW      FGC_VPU_OUT
   F9A6   1F 10         		DW      FGC_VPU_CMD
                        
   F9A8   20 00         XMODEM_DEV	DB	XMODEM1_ID, $00  ; XModem Device Driver Descriptor
   F9AA   88 F3         		DW	SERIALIN
   F9AC   78 F3         		DW	SERIALOUT
   F9AE   FD F7         		DW	XMODEM_CMD
                        
   F9B0   21 00         TAPE_DEV	DB	TAPE1_ID, $00    ; Tape Device Driver Descriptor
   F9B2   61 F8         		DW	_EMPTY_
   F9B4   61 F8         		DW	_EMPTY_
   F9B6   0B F8         		DW	TAPE_CMD
                        
   F9B8   24 00         SDC_DEV	        DB	SDC1_ID, $00     ; SD-Card Driver Descriptor
   F9BA   61 F8         		DW	_EMPTY_
   F9BC   61 F8         		DW	_EMPTY_
   F9BE   19 F8         		DW      SDC_CMD
                        
   F9C0   22 00         FDD1_DEV	DB	FDD1_ID, $00     ; Floppy Disk Drive 1 Driver Descriptor
   F9C2   61 F8         		DW	_EMPTY_
   F9C4   61 F8         		DW	_EMPTY_
   F9C6   17 10         		DW      FGC_FDC_CMD
                        
   F9C8   23 00         FDD2_DEV	DB	FDD2_ID, $00     ; Floppy Disk Drive 2 Driver Descriptor
   F9CA   61 F8         		DW	_EMPTY_
   F9CC   61 F8         		DW	_EMPTY_
   F9CE   63 F8         		DW      FGC_FDC_CMD2
                        
                        ; ******************************************************************************
                        ; Low Byte CRC Lookup Table (XMODEM)
                        ; ******************************************************************************
                        
   FA00                                 ORG 	$FA00
   FA00                 CRCLO
   FA00   00 21 42 63    		DB 	$00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
   FA04   84 A5 C6 E7   
   FA08   08 29 4A 6B   
   FA0C   8C AD CE EF   
   FA10   31 10 73 52    		DB 	$31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
   FA14   B5 94 F7 D6   
   FA18   39 18 7B 5A   
   FA1C   BD 9C FF DE   
   FA20   62 43 20 01    		DB 	$62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
   FA24   E6 C7 A4 85   
   FA28   6A 4B 28 09   
   FA2C   EE CF AC 8D   
   FA30   53 72 11 30    		DB 	$53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
   FA34   D7 F6 95 B4   
   FA38   5B 7A 19 38   
   FA3C   DF FE 9D BC   
   FA40   C4 E5 86 A7    		DB 	$C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
   FA44   40 61 02 23   
   FA48   CC ED 8E AF   
   FA4C   48 69 0A 2B   
   FA50   F5 D4 B7 96    		DB 	$F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
   FA54   71 50 33 12   
   FA58   FD DC BF 9E   
   FA5C   79 58 3B 1A   
   FA60   A6 87 E4 C5    		DB 	$A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
   FA64   22 03 60 41   
   FA68   AE 8F EC CD   
   FA6C   2A 0B 68 49   
   FA70   97 B6 D5 F4    		DB 	$97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
   FA74   13 32 51 70   
   FA78   9F BE DD FC   
   FA7C   1B 3A 59 78   
   FA80   88 A9 CA EB    		DB 	$88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
   FA84   0C 2D 4E 6F   
   FA88   80 A1 C2 E3   
   FA8C   04 25 46 67   
   FA90   B9 98 FB DA    		DB 	$B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
   FA94   3D 1C 7F 5E   
   FA98   B1 90 F3 D2   
   FA9C   35 14 77 56   
   FAA0   EA CB A8 89    		DB 	$EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
   FAA4   6E 4F 2C 0D   
   FAA8   E2 C3 A0 81   
   FAAC   66 47 24 05   
   FAB0   DB FA 99 B8    		DB 	$DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
   FAB4   5F 7E 1D 3C   
   FAB8   D3 F2 91 B0   
   FABC   57 76 15 34   
   FAC0   4C 6D 0E 2F    		DB 	$4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
   FAC4   C8 E9 8A AB   
   FAC8   44 65 06 27   
   FACC   C0 E1 82 A3   
   FAD0   7D 5C 3F 1E    		DB 	$7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
   FAD4   F9 D8 BB 9A   
   FAD8   75 54 37 16   
   FADC   F1 D0 B3 92   
   FAE0   2E 0F 6C 4D    		DB 	$2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
   FAE4   AA 8B E8 C9   
   FAE8   26 07 64 45   
   FAEC   A2 83 E0 C1   
   FAF0   1F 3E 5D 7C    		DB 	$1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0
   FAF4   9B BA D9 F8   
   FAF8   17 36 55 74   
   FAFC   93 B2 D1 F0   
                        
                        ; ******************************************************************************
                        ; Hi Byte CRC Lookup Table (XMODEM)
                        ; ******************************************************************************
                        
   FB00                                 ORG 	$FB00
   FB00                 CRCHI
   FB00   00 10 20 30    		DB 	$00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
   FB04   40 50 60 70   
   FB08   81 91 A1 B1   
   FB0C   C1 D1 E1 F1   
   FB10   12 02 32 22    		DB 	$12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
   FB14   52 42 72 62   
   FB18   93 83 B3 A3   
   FB1C   D3 C3 F3 E3   
   FB20   24 34 04 14    		DB 	$24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
   FB24   64 74 44 54   
   FB28   A5 B5 85 95   
   FB2C   E5 F5 C5 D5   
   FB30   36 26 16 06    		DB 	$36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
   FB34   76 66 56 46   
   FB38   B7 A7 97 87   
   FB3C   F7 E7 D7 C7   
   FB40   48 58 68 78    		DB 	$48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
   FB44   08 18 28 38   
   FB48   C9 D9 E9 F9   
   FB4C   89 99 A9 B9   
   FB50   5A 4A 7A 6A    		DB 	$5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
   FB54   1A 0A 3A 2A   
   FB58   DB CB FB EB   
   FB5C   9B 8B BB AB   
   FB60   6C 7C 4C 5C    		DB 	$6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
   FB64   2C 3C 0C 1C   
   FB68   ED FD CD DD   
   FB6C   AD BD 8D 9D   
   FB70   7E 6E 5E 4E    		DB 	$7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
   FB74   3E 2E 1E 0E   
   FB78   FF EF DF CF   
   FB7C   BF AF 9F 8F   
   FB80   91 81 B1 A1    		DB 	$91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
   FB84   D1 C1 F1 E1   
   FB88   10 00 30 20   
   FB8C   50 40 70 60   
   FB90   83 93 A3 B3    		DB 	$83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
   FB94   C3 D3 E3 F3   
   FB98   02 12 22 32   
   FB9C   42 52 62 72   
   FBA0   B5 A5 95 85    		DB 	$B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
   FBA4   F5 E5 D5 C5   
   FBA8   34 24 14 04   
   FBAC   74 64 54 44   
   FBB0   A7 B7 87 97    		DB 	$A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
   FBB4   E7 F7 C7 D7   
   FBB8   26 36 06 16   
   FBBC   66 76 46 56   
   FBC0   D9 C9 F9 E9    		DB 	$D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
   FBC4   99 89 B9 A9   
   FBC8   58 48 78 68   
   FBCC   18 08 38 28   
   FBD0   CB DB EB FB    		DB 	$CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
   FBD4   8B 9B AB BB   
   FBD8   4A 5A 6A 7A   
   FBDC   0A 1A 2A 3A   
   FBE0   FD ED DD CD    		DB 	$FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
   FBE4   BD AD 9D 8D   
   FBE8   7C 6C 5C 4C   
   FBEC   3C 2C 1C 0C   
   FBF0   EF FF CF DF    		DB 	$EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E
   FBF4   AF BF 8F 9F   
   FBF8   6E 7E 4E 5E   
   FBFC   2E 3E 0E 1E   
                        
                        
   FC00                 		END
00f3  ACC           0006  ACK           0069  ACMD41        001b  ACR       
e997  ADDOFS        00a1  ADDRMARK      f7ac  ADD_DEV       f7ad  ADD_DEV1  
e1a7  ADD_DEVICE    002d  ADIV          00fb  ADRH          00fa  ADRL      
00e2  ADRMODE       e9d1  ADRMODEC      e9c2  ADRMODEM      e9e0  ADRMODER  
e9ef  ADRMSTRL      e9f4  ADRMSTRR      e6db  ADRNEXT       00e7  ASCH      
f395  ASCIIKBD      00e6  ASCL          e728  ASCOUT        e064  BACKSPACE 
00e0  BAUDRATE      e167  BEEP          e176  BEEPLOOP      00e1  BFLAG     
00ed  BITCNT        f6b8  BIT_MODE      00dc  BLKBUF        00dd  BLKBUFH   
00dc  BLKBUFL       00e0  BLKEND        00e2  BLKNO         f6c2  BLK_MODE  
0600  BLOCK_BUF     07fe  BOOTBLK_TAG    e87f  BOOTDEV       0400  BOOT_PART 
e044  BOUT          f32c  BREAK         ede7  BREAKREAD     eee4  BREAKSAVE 
edea  BREAKSYNC     1a78  BRKUSR        0008  BS            ee5d  BYTE_IN   
ef1f  BYTE_OUT      f095  BadCRC        f053  BegBlk        e983  CALCADR   
e9ba  CALCTAB       e56c  CALL_INFO     0018  CAN           0018  CARD3BASE 
0019  CARD3BASEH    0018  CARD3BASEL    0020  CENTURY       e04d  CGET      
e1d4  CHAR_GET      ef6d  CHECKBIT      eb40  CHECKDATETIME    ef80  CHECKKEY  
00dc  CHECKSUM      efa2  CHECK_KEYSIG    e15c  CHKESC        e5ef  CHKNEXTCMD
e557  CHK_IO_0      e561  CHK_IO_1      e4c6  CHK_IO_CARD    e047  CIN       
e398  CLKDOWN       eb31  CLOCKSTART    e53d  CLRLOADSTR    e0b5  CLRSCRN   
0040  CMD0          0041  CMD1          004d  CMD13         0050  CMD16     
0051  CMD17         0058  CMD24         0077  CMD55         007a  CMD58     
0048  CMD8          e0ba  CMDDEV        e6aa  CMDEND        e0b7  CMDPRINT  
0081  CMD_AND_BAR    0071  CMD_AND_LINE    0051  CMD_AND_PIXEL    0061  CMD_AND_RECT
000c  CMD_BACK_COLOR    0024  CMD_BOOT      0006  CMD_CLRLINE    0007  CMD_CLRSCRN
000a  CMD_COLOR     0009  CMD_CRSR_ONOFF    0080  CMD_DRAW_BAR    0070  CMD_DRAW_LINE
0060  CMD_DRAW_RECT    0004  CMD_FLASH     0005  CMD_HOME      0001  CMD_IDENTIFY
0000  CMD_INIT      0003  CMD_INVERSE    0020  CMD_LOAD      000f  CMD_MODE  
0008  CMD_MOVE_TO    0002  CMD_NORMAL    0084  CMD_NOT_BAR    0074  CMD_NOT_LINE
0054  CMD_NOT_PIXEL    0064  CMD_NOT_RECT    0082  CMD_OR_BAR    0072  CMD_OR_LINE
0052  CMD_OR_PIXEL    0062  CMD_OR_RECT    0050  CMD_PUT_PIXEL    0022  CMD_READ  
0025  CMD_READ_BUF    0021  CMD_SAVE      0008  CMD_SETCURSOR    0011  CMD_SETENDADR
0010  CMD_SETSTARTADR    000d  CMD_STD_PALETTE    000b  CMD_TEXT_COLOR    0089  CMD_T_AND_BAR
0079  CMD_T_AND_LINE    0059  CMD_T_AND_PIXEL    0069  CMD_T_AND_RECT    0088  CMD_T_DRAW_BAR
0078  CMD_T_DRAW_LINE    0068  CMD_T_DRAW_RECT    008c  CMD_T_NOT_BAR    007c  CMD_T_NOT_LINE
005c  CMD_T_NOT_PIXEL    006c  CMD_T_NOT_RECT    008a  CMD_T_OR_BAR    007a  CMD_T_OR_LINE
005a  CMD_T_OR_PIXEL    006a  CMD_T_OR_RECT    0058  CMD_T_PUT_PIXEL    008b  CMD_T_XOR_BAR
007b  CMD_T_XOR_LINE    005b  CMD_T_XOR_PIXEL    006b  CMD_T_XOR_RECT    0023  CMD_WRITE 
0026  CMD_WRITE_BUF    0083  CMD_XOR_BAR    0073  CMD_XOR_LINE    0053  CMD_XOR_PIXEL
0063  CMD_XOR_RECT    e749  CMPADDR       1a94  CNTA          1a95  CNTB      
1a96  CNTC          1a97  CNTD          1a9f  CNTIRQ        1602  COMM_REG  
ecbd  COMP_LOOP     f84d  COM_CMD       0010  COM_DEV       f857  COM_SETENDADR
eff9  COPYNAME      e052  COUT          000d  CR            00dd  CRCH      
fb00  CRCHI         00dc  CRCL          fa00  CRCLO         e05a  CROUT     
1603  CTRL_REG      f216  CalcCRC       f21e  CalcCRC1      f0c9  CopyBlk   
f0cb  CopyBlk3      f0e9  CopyBlk4      f0e3  CopyBlk5      f3ab  DATA_AVAIL
1600  DATA_REG      00fe  DATA_TOKEN    002e  DATEDIV       e82d  DATEINPUT 
eb4e  DATETIMELOST    e85f  DAYS          0013  DDRA          0012  DDRB      
e0bd  DEC2STR       e8db  DECODE        e8e4  DECODEMNEM    e1bc  DECODE_JOYSTICK
f730  DECODE_JOY_PORT    e14d  DELAY         f3d0  DETECT_ASCIIKBD    eca6  DETECT_IO 
ecce  DETECT_IOL_CARD    ecb2  DETECT_LOOP    1a6c  DEVCMD        0003  DEVID     
1a68  DEVIN         1a28  DEVLIST       1a6a  DEVOUT        f782  DEV_ADD   
f7c5  DEV_CHECK     f7c1  DEV_ERR       f777  DEV_INIT      f77b  DEV_INIT1 
f7d1  DEV_OPEN      f7dd  DEV_OPEN1     f7e6  DEV_OPEN2     f7ec  DEV_OPEN3 
00f8  DIG0          00f9  DIG1          00fa  DIG2          e8a9  DISASSEM  
00f2  DIVCHAR       e6e3  DIVCHK        e16a  DOBEEP        e817  DT_NOT_SET
e6bd  DUMP          f123  DoCancel      f37d  EMPTY?        eec7  ENDBLOCK  
ee6f  ENDBYTE_IN    efb2  ENDCHECK      e6a6  ENDCMD        eed3  ENDDATA   
e8c7  ENDDISASSEM    e702  ENDDUMP       f000  ENDFILENAME    ef1e  ENDHEADER 
e982  ENDINC        e591  ENDINP        edd5  ENDLDDATA     ede1  ENDLOAD   
e931  ENDMASK       e973  ENDMODE       eeff  ENDPREAMBLE    f00b  ENDPREP   
eee0  ENDSAVE       e080  ENDSTRIN      e13f  ENDSTRING     e090  ENDSTROUT 
ef8c  ENDTAPEIRQ    ef56  ENDWRITE      f7c0  END_DEV_ADD    f781  END_DEV_INIT
f7fc  END_DEV_OPEN    f505  END_GET_VERS    f76f  END_JOY_PORT    f60f  END_SD_RESET
e1f9  END_TTY_CMD    0004  EOT           00e1  EQUFLAG       00e3  ERRCNT    
edf0  ERRLOAD       f2ae  ERRX          001b  ESC           e780  ESCBLNK   
e775  ESCCLL        e76f  ESCCLS        e778  ESCGID        e773  ESCHOME   
e77d  ESCINV        e77b  ESCNORM       f29a  ESCX          e62d  EXECPROG  
f20b  EndGetByte    f1de  EndGetData    f259  EndXMsg       00c1  FDC_MOTOR 
1004  FDC_MOTOR1_REG    1005  FDC_MOTOR2_REG    1003  FDC_OPT_REG    f9c0  FDD1_DEV  
0022  FDD1_ID       f9c8  FDD2_DEV      0023  FDD2_ID       0016  FGCBASE   
0017  FGCBASEH      0016  FGCBASEL      1000  FGC_BASE      1017  FGC_FDC_CMD
f863  FGC_FDC_CMD2    1010  FGC_INFO      1013  FGC_SET_PAGE    101f  FGC_VPU_CMD
1027  FGC_VPU_OUT    001f  FILEMARK      f798  FIND_FREE_DEV    f79e  FIND_NEXT_DEV
e6f8  FINISHED?     f20c  Flush         f210  Flush1        ed85  GETBYTE?  
e0d9  GETDIG0       e0cf  GETDIG1       e0c5  GETDIG2       ebad  GETDIGIT  
ebb0  GETDIGIT1     ebc6  GETDIGIT2     ebe0  GETDIGITEND    f353  GETMAGIC  
f055  GetBlk        f059  GetBlk1       f05e  GetBlk2       f1df  GetByte   
f1f1  GetChar       f1cc  GetData       f075  GoodBlk1      f083  GoodBlk2  
f0a0  GoodCRC       f03d  GotByte       f048  GotByte1      f045  GotESC    
0025  HDD1_ID       0026  HDD2_ID       e956  HEX1          e09a  HEXDIG    
e0fd  HEXDIGIT      e0ea  HEXINPUT      e091  HEXOUT        e344  I2C_ACK   
e384  I2C_ACK?      00e0  I2C_DATA      e353  I2C_NACK      e39f  I2C_RCV   
e362  I2C_READ_DEV    0068  I2C_RTC_ADR    e367  I2C_SEND      e326  I2C_START 
e335  I2C_STOP      e366  I2C_WRITE_DEV    00e3  IBYTES        001e  IER       
001d  IFR           e97c  INCADR        e48e  INIT          ec67  INITIO    
ec6b  INITIO1       e454  INITRESET     e41a  INITVECT      ec96  INIT_BEEP 
f69e  INIT_BLKBUF    e4b2  INIT_END      ecfe  INIT_IOCARD    f496  INIT_SD0  
f498  INIT_SD1      f49d  INIT_SD2      f4b3  INIT_SD3      f4ca  INIT_SD4  
ed1f  INIT_SDCARD    ed29  INIT_TAPE     ed08  INIT_VIA      0014  IOBASE    
0015  IOBASEH       0014  IOBASEL       e7c6  IOCARD        1a00  IO_INFO   
e56b  IO_INFO_END    eca3  IO_INITIALIZE    f315  IRQ           1a7c  IRQUSR    
1a7e  IRQVECT       f95e  IRQ_END       e397  ISACK         ebf4  ISNUM     
f0ee  IncBlk        e752  JCRESET       f75b  JP_BUTTON1    f766  JP_BUTTON2
f752  JP_BUTTON3    f73f  JP_DOWN       f744  JP_LEFT       f74d  JP_RIGHT  
f736  JP_UP         0800  K2            ecf1  K2?           0c00  K3        
ece7  K3?           1000  K4            ecdd  K4?           e7dd  KBDSTR    
0081  KBD_MAGIC_NUM    0013  KEYBD1_ID     0014  KEYBD2_ID     f998  KEYBD_DEV 
1a24  KEY_HANDLER    00e5  KEY_SENSE     dff0  LANGKEY       dff1  LANGNAME  
000a  LF            e050  LFOUT         00e1  LINECNT       e615  LOAD      
e8c8  LOADOPCODE    e5e4  LOADSAVE      e540  LOADSTRING    e549  LOADSTRING2
f6a7  LOAD_LBA      f673  LOAD_PART     f668  LOAD_PART0    f656  LOAD_PART1
e156  LOOPDELAY     e411  LOOP_NXT      00be  LPTIME        f147  LdBuff0   
f157  LdBuff1       f15c  LdBuff2       f16b  LdBuff3       f177  LdBuff4   
f17d  LdBuff5       f140  LdBuffer      f1e3  LoopGetByte    f1d0  LoopGetData
e762  MAGIC0        e766  MAGIC1        f355  MAGICLOOP     e4b3  MAIN      
e43c  MAINSTART     ee58  MARKERROR     0600  MBR           e6c4  MEMDUMP   
e7fd  MENU          e520  MLOOP         ea38  MNEMONICSH    e9ff  MNEMONICSL
e537  MNEXT         e52c  MNEXT1        e6ec  MOD16CHK      00ff  MODE      
e6ad  MONEND        e649  MONINIT       e63b  MONINP        e630  MONITOR   
e638  MONRESET      e809  MONSTR        e000  MON_COLD_START    e003  MON_WARM_START
e8b6  MORE?         f948  MOTOR_IRQ     efbe  MOTOR_OFF     efb3  MOTOR_ON  
0400  MOUNT_TABLE    f286  MSGX          0015  NAK           ee4e  NAMEEQU   
00a0  NAMEMARK      ee53  NAMENEQ       e968  NEXTAMCHR     e71c  NEXTASC   
e217  NEXTBAUD      eda6  NEXTBLK       eea4  NEXTBLOCK     e9aa  NEXTBYTE  
e3d2  NEXTCHANNEL    e067  NEXTCHR       e679  NEXTCMD       e64d  NEXTCMDCHR
edac  NEXTDATA      e0f0  NEXTDIGIT     efeb  NEXTFNCHAR    e6ba  NEXTITEM  
e8ae  NEXTLINE1     e8c0  NEXTLINE2     e91f  NEXTMASK      e902  NEXTMCHR  
e0ac  NEXTNUMOUT    e8b3  NEXTOP        e906  NEXTSHIFT     e11a  NEXTSTRCHAR
ef2c  NEXT_BIT      f50a  NEXT_PARAM    1a26  NKEY_HANDLER    f32a  NMI       
1a7a  NMIVECT       e717  NOADJUST      e726  NOASC         e88f  NOBOOTDEV 
ecfb  NOCARD        f3ac  NODATA        e234  NOESC         ee56  NOHDRMARK 
f3e4  NOKBD         f360  NOMAGIC       f361  NOSTDPROC     f422  NOSTROBE  
ef90  NOTAPEIRQ     e166  NOTESC        e118  NOTHEX        ebf2  NOTNUM    
e60e  NOTVALID      e4f3  NO_BOOT_DEV    e1dc  NO_CHAR_GET    f773  NO_JOY_PORT
ecca  NO_MATCH      f960  NO_VPU_IRQ    f980  NULL_DEV      0000  NULL_ID   
e107  NUMDIGIT      00f9  NUMH          ebe7  NUMINPUT      00f8  NUML      
e0a7  NUMOUT        ec50  NXTREG        00e0  OPCODE        ea71  OPCODES   
e5d0  OPENTAPE      e1aa  OPEN_DEVICE    e87b  OSID          00dd  OUTBYTE   
1a80  PAD           1a81  PADD          001f  PANOHS        e5af  PARALLEL  
e5bc  PARALLELL     07be  PART0         07c6  PART0_RS      07ce  PART0_SIZE
1a82  PBD           1a83  PBDD          00f0  PCH           00ef  PCL       
001c  PCR           00fe  PDBCNT        00de  PDEV          00df  PDEVH     
00de  PDEVL         000f  PIA_CONTROL    000c  PIA_PORTA     000d  PIA_PORTB 
000e  PIA_PORTC     00e6  PLBA          00e7  PLBAH         00e6  PLBAL     
eef4  PLOOP         0011  PORTA         0010  PORTB         f3ff  PPORTBSY? 
f410  PPORTIN       2000  PPORTLOAD     f3e5  PPORTOUT      2003  PPORTSAVE 
f990  PPRINT_DEV    e733  PRADDRESS     e6ce  PRADR         e704  PRASCII   
e6d1  PRDATA        00f1  PREG          efe4  PREPFILENAME    e0a4  PRHEX     
e619  PRINT         ec28  PRINTDATE     ebf6  PRINTDATETIME    ec43  PRINTDIGIT
ec46  PRINTDIVCHAR    e589  PRINTDUMP     0011  PRINTER1_ID    0012  PRINTER2_ID
e259  PRINTESC      ec14  PRINTFULLDATE    e99e  PRINTOFFS     e56f  PRINTOUT  
e0e2  PRINTTAB      ec02  PRINTTIME     e93f  PRINTVAL      e198  PRINT_DATE
e192  PRINT_DATETIME    e19b  PRINT_FULLDATE    e195  PRINT_TIME    002a  PROMPT    
ec4b  PRSTATUS      f3ad  PS2KBD        f3c0  PS2_CHECK     f3cc  PS2_DATA_AVAIL
f3cd  PS2_NODATA    00ee  PSAV          e76a  PSSTR         00ea  PSTR      
00eb  PSTRH         00ea  PSTRL         f249  PrintXEnd     f23e  PrintXErr 
f241  PrintXError    f24a  PrintXMsg     f24e  PrintXMsg1    f236  PrintXStart
f246  PrintXSucc    f1c3  PrtAbort      1500  RBUFF         e3b8  RCVEND    
e3a1  RCVLOOP       f0f8  RDone         ee02  READADDR      f0b3  READADR   
ee61  READBIT       e2e6  READCLOCK     f0be  READDATA      e2e2  READDATE  
e292  READDOW       ee3e  READFIRSTBYTE    edf6  READHEADER    f39d  READMODE  
ee1e  READNAME      e12d  READSTRING    ed77  READSYNC      e2de  READTIME  
e1b9  READ_JOYSTICK    f728  READ_JOY_PORT    f528  READ_RESP1    f4fa  READ_RESP3
e1df  READ_STD_IN    e323  READ_VIA      1c1d  RESET         f60a  RESET_SDC 
e1ad  RESET_STDIO    ef96  RESET_TIMER2    f532  RESPONSE      00df  RETRYH    
00de  RETRYL        0001  RETURN_VECT    0031  RPTIME        e61c  RUN       
f1fd  ReadByte      f190  Resend        e614  SAVE          f182  SCalcCRC  
0024  SDC1_ID       e8a4  SDCDEV        f846  SDC_BOOT      f819  SDC_CMD   
f9b8  SDC_DEV       f4de  SDC_NOT_FOUND    f82e  SDC_RD_BUF    f820  SDC_READ  
f83c  SDC_SETADR    f827  SDC_WRITE     f835  SDC_WR_BUF    f634  SD_BOOT   
f675  SD_BOOT1      f506  SD_CLEAR_CMD    00de  SD_CMD        00e3  SD_CRC    
f5f0  SD_DISK_CHNG    f5ec  SD_DISK_RW    f633  SD_END        f4e3  SD_GET_VERS
f47b  SD_INIT       f5e9  SD_NO_DISK    00e2  SD_PB0        00e1  SD_PB1    
00e0  SD_PB2        00df  SD_PB3        f612  SD_PREPARE    f626  SD_PREPARE1
f554  SD_RD_BLK     f565  SD_RD_BLK0    f577  SD_RD_BLK1    f549  SD_RD_BLK_BUF
f580  SD_RD_END     f551  SD_RD_LBLK    f54e  SD_RD_LBLK_BUF    f5f4  SD_RESET  
f5dd  SD_RESP_ERR    f5d5  SD_SEND_BLK_CMD    f515  SD_SEND_CMD    00db  SD_TYPE   
f526  SD_WAIT_RESP    f4f8  SD_WAIT_RESP3    f535  SD_WAIT_TOKEN    f58c  SD_WR_BLK 
f599  SD_WR_BLK0    f581  SD_WR_BLK_BUF    f5c4  SD_WR_BUSY?    f5d4  SD_WR_END 
f589  SD_WR_LBLK    f586  SD_WR_LBLK_BUF    f1c9  SDone         e375  SENDH     
e36d  SENDLOOP      f51c  SEND_BYTE     f61d  SEND_CLOCK    f394  SERIALEND 
f388  SERIALIN      f378  SERIALOUT     e64a  SETADRMODE    e377  SETBIT    
e6a2  SETBLKMODE    eb59  SETDATE       eb56  SETDATETIME    f3f0  SETHSK    
ed46  SETIRQVECT    e698  SETMODE       e69e  SETMODE2      f423  SETPPORTIN
e313  SETRTCADR     e144  SETSTRBUFF    e148  SETSTRBUFF0    eb83  SETTIME   
e4a7  SET_CRTDEV    e1a4  SET_DATE      e19e  SET_DATETIME    ef38  SET_LONG  
e3f2  SET_NOISE     ec89  SET_PRINTER_DEV    ef3c  SET_SHORT     e032  SET_STDIN 
e02f  SET_STDINID    e012  SET_STDIO     e00f  SET_STDIOID    e01b  SET_STDOUT
e01f  SET_STDOUT0    e023  SET_STDOUT1    e018  SET_STDOUTID    e1a1  SET_TIME  
ec73  SET_TTY_DEV    ec82  SET_XMODEM_DEV    e10d  SHIFT         e152  SHORTDELAY
e153  SHORTDELAY1    e8bc  SHOW1PAGE     e9a8  SHOWHEX       e53a  SHOWMON   
e4e8  SHOW_CLOCK    f388  SIN           e64c  SKIPCMDCHR    0001  SOH       
e3da  SOUND_MUTE    e3d0  SOUND_MUTEALL    e1bf  SOUND_MUTE_ALL    e1c2  SOUND_MUTE_CHAN
e3ea  SOUND_PNOISE    e1c8  SOUND_P_NOISE    e3bb  SOUND_SENDBYTE    e3dc  SOUND_SETATN
e3fb  SOUND_SETFREQ    e3f0  SOUND_SETNOISE    e1c5  SOUND_SET_ATN    e1d1  SOUND_SET_FREQ
e1ce  SOUND_SET_NOISE    e3ee  SOUND_WNOISE    e1cb  SOUND_W_NOISE    f378  SOUT      
e7f8  SPACE         0020  SPC           e05e  SPCOUT        f449  SPI_FAST  
f439  SPI_INIT      f46a  SPI_READ      f46e  SPI_READ1     f474  SPI_RESET 
f439  SPI_SLOW      f450  SPI_WRITE     f458  SPI_WRITE1    003c  SPTIME    
00f2  SPUSER        001a  SR            ed65  STARTLOAD     e529  STARTMON  
ed6b  STARTSYNC     1601  STAT_REG      1a66  STDBEEP       1a72  STDCMD    
1a6e  STDIN         1a74  STDINDEV      1a70  STDOUT        1a75  STDOUTDEV 
1a76  STDPRINTDEV    1a77  STOACC        00e9  STOH          00e8  STOL      
0020  STORAGE_DEV    e68e  STOREADR      ecfc  STOREBASE     e6b0  STOREDATA 
1400  STRBUF        e062  STRIN         e76f  STRINGP       e85f  STRINGP2  
e119  STRINPUT      f419  STROBE?       e083  STROUT        f2bf  SUCCX     
e00c  SWITCH        e006  SWITCH_TO_RAM    e00a  SWITCH_TO_ROM    ed99  SYNCEND?  
002e  SYNCMARK      f6cb  SYS_BOOT      f6cd  SYS_BOOT1     f6e3  SYS_BOOT2 
f723  SYS_BOOTMSG    f6f4  SYS_BOOT_END    f727  SYS_CHECK_END    f713  SYS_CHECK_OS
f715  SYS_ID_LOOP    f6fa  SYS_LD_BOOTBLK    f701  SYS_MBR_ID    f6ec  SYS_MSG   
f6f3  SYS_MSG_END    f6f2  SYS_MSG_ERR    f711  SYS_TAG_ERR    f197  SendBlk   
f1bb  SetError      f126  SetStoAddr    f034  StartBlk      f01d  StartRcv  
0015  T1CH          0014  T1CL          0017  T1LH          0016  T1LL      
0019  T2CH          0018  T2CL          e0de  TAB           e5c2  TAPE      
0021  TAPE1_ID      f313  TAPEANYNAME    f2fe  TAPEBRK       ed4d  TAPEESC   
f2f8  TAPEFND       ef60  TAPEIRQ       efc9  TAPEIRQ_OFF    efd3  TAPEIRQ_OFF1
e5ce  TAPEL         f306  TAPELDERR     ed50  TAPELOAD      f2ef  TAPELOD   
f2c2  TAPEOK        f2c7  TAPEPLAY      f2d3  TAPEREC       efdc  TAPERW_OFF
efd4  TAPERW_ON     f2dd  TAPESAV       ee72  TAPESAVE      f2e6  TAPESKIP  
f266  TAPE_BREAK_MSG    f80b  TAPE_CMD      f9b0  TAPE_DEV      f261  TAPE_ERR_MSG
f282  TAPE_ESC_MSG    f26f  TAPE_LOAD_MSG    f25c  TAPE_OK_MSG    f27e  TAPE_PLAY_MSG
f277  TAPE_REC_MSG    f26b  TAPE_SAVE_MSG    f273  TAPE_SKIP_MSG    00fc  TEMP      
00da  TICKCNT       003a  TIMEDIV       e846  TIMEINPUT     e783  TITLE     
f812  TP_SAVE       0010  TTY1_ID       e24e  TTY_CLRLINE    e257  TTY_CLRSCRN
e1e2  TTY_CMD       e1fa  TTY_CMD_TABLE    f988  TTY_DEV       e262  TTY_ESCCODE
e246  TTY_FLASH     e24a  TTY_HOME      e23a  TTY_IDENTIFY    e20c  TTY_INIT  
e242  TTY_INVERSE    e23e  TTY_NORMAL    f362  TTY_OUT       f36f  TTY_OUT1  
e26c  TTY_SETCURSOR    f324  USRBREAK      ef93  USRIRQ        0015  VDP1_ID   
f9a0  VDP_DEV       0031  VERMAIN       0031  VERPSUB       0037  VERSSUB   
000b  VIA_ACR       0003  VIA_DDRA      0002  VIA_DDRB      000e  VIA_IER   
000d  VIA_IFR       000f  VIA_PANOHS    000c  VIA_PCR       0001  VIA_PORTA 
0000  VIA_PORTB     000a  VIA_SR        00e4  VIA_STATUS    0005  VIA_T1CH  
0004  VIA_T1CL      0007  VIA_T1LH      0006  VIA_T1LL      0009  VIA_T2CH  
0008  VIA_T2CL      f949  VPU_IRQ       1009  VPU_PORT1     0080  VPU_REG0  
008f  VPU_REG15     0000  VPU_STAT0     e464  VTDETECT      ed6f  WAITBIT   
ed59  WAITPLAY      ee7b  WAITRECORD    ef25  WAIT_BIT1     f53b  WAIT_RESP 
f544  WAIT_RESP0    f548  WAIT_RESP_END    00ec  WBUF          1a85  WRDC      
ef04  WRITEADDR     ef21  WRITEBYTE     e2c9  WRITECLOCK    e2b1  WRITEDATE 
e2b7  WRITEDATE2    e283  WRITEDOW      ef00  WRITEHEADER    eeea  WRITESYNC 
e299  WRITETIME     e29f  WRITETIME2    ef3e  WRITE_BIT     e552  WRITE_IO_INFO
e320  WRITE_VIA     eea7  WRNXTBYTE     ef13  WRNXTCHAR     e085  WRSTR     
f10e  Wait4CRC      e59d  XMODEM        0020  XMODEM1_ID    e5ac  XMODEME   
e5a9  XMODEML       f7fd  XMODEM_CMD    f9a8  XMODEM_DEV    f804  XM_SAVE   
f012  XModemRcv     f103  XModemSnd     00f5  XREG          00f4  YREG      
00fd  YSAV          f861  _EMPTY_       f862  _HANDLER_     
